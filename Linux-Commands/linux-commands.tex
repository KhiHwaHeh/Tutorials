
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{linux-commands}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{\texorpdfstring{မြန်မာကျောင်းသားများအတွက် အခြေခံ bash command
များ}{မြန်မာကျောင်းသားများအတွက်  အခြေခံ bash command များ}}\label{ux1019ux1014ux1019ux1000ux1004ux101eux1019ux1021ux1010ux1000-ux1021ux1001ux1001-bash-command-ux1019}

    bash or linux command တွေကို ကောင်းကောင်းသုံးတတ်ရင် ကွန်ပြူတာနဲ့
အလုပ်လုပ်တဲ့အခါမှာ ပိုပြီးမြန်ဆန်လာပါလိမ့်မယ်။

ဒီ tutorial က မြန်မာ ကျောင်းသားတွေအားလုံးကို ရည်ရွယ်ပါတယ်။\\
အထူးသဖြင့် ကွန်ပြူတာတက္ကသိုလ်တွေ၊ အင်ဂျင်နီယာတက္ကသိုလ်တွေက မဟာဘွဲ့၊
ဒေါက်တာဘွဲ့ ယူဖို့ ရည်ရွယ်ထားကြသူတွေ၊ သုတေသနကို လုပ်ချင်ကြတဲ့
ကျောင်းသားတွေက linux command တွေကို ကျွမ်းကျင်စွာ သုံးနိုင်ကြရမယ်။
ဘာ့ကြောင့်လဲ ဆိုတော့ ခင်ဗျားတို့ linux ကို မသုံးလို့ကို မဖြစ်လို့ပါ။

သုတေသနအတွက်၊ လက်ရှိရှိနေပြီးသား သုတေသနပရိုပိုဇယ်တွေမှာသုံးထားကြတဲ့
ပရိုဂရမ်တွေ၊ မှီငြမ်းလို့ ရနိုင်မဲ့ နမူနာ prototype system တွေ၊ open
source အနေနဲ့ ရရှိနိုင်တဲ့ source code အများစုကလည်း linux OS ပေါ်မှာပဲ
develop လုပ်ကြတာမို့လို့ပါ။ နောက်ပြီးတော့ linux/Unix command (သို့)
command line interface (CLI) ကို အသုံးပြုရခြင်းရဲ့ အားသာတဲ့ အချက်တွေကို
သိထားသင့်ပါတယ်။

လေ့လာတဲ့အခါ ရရှိမဲ့ နောက်ဆက်တွဲ ဗဟုသုတနဲ့ အကျိုးကျေးဇူးတွေက
အများကြီးမို့လို့ပါ။ 　　

အဲဒါကြောင့် ပထမဆုံးအဆင့်အနေနဲ့ လက်တွေ့မှာ အသုံးဝင်မဲ့၊ မသိမဖြစ်သိသင့်တဲ့
command တွေကို အသုံးများတဲ့ option တွေကိုပဲ သုံးပြီး ရှင်းပြပါမယ်။
Command တွေကို လက်တွေ့ စမ်းရိုက်၊ မော်နီတာစကရင်မှာ မြင်ရတဲ့ output
တွေကို လေ့လာကြည့်ရင်း၊ မြန်မြန်ဆန်ဆန် နားလည်ပြီး၊ ကိုယ်လုပ်ချင်တဲ့
သုတေသနအလုပ်တွေအတွက် စတင်အသုံးပြုနိုင်ဖို့ကို အဓိက ရည်ရွယ်ပါတယ်။ 　

\subsection{1. ls (list directory
contents)}\label{ls-list-directory-contents}

လက်ရှိ ရောက်နေတဲ့ ဖိုလ်ဒါ မှာရှိတဲ့ ဖိုင်တွေ၊ ဖိုလ်ဒါတွေကို ကြည်ချင်ရင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} ls
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
all-vi-info.txt  \textcolor{ansi-blue-intense}{\textbf{data5}}    \textcolor{ansi-blue-intense}{\textbf{folderA}}                   ls.out   otest.tag
\textcolor{ansi-blue-intense}{\textbf{data1}}            echo     \textcolor{ansi-blue-intense}{\textbf{folder-new}}                my-news  otest.word
\textcolor{ansi-blue-intense}{\textbf{data2}}            fileA    item-list                 newfile  \textcolor{ansi-blue-intense}{\textbf{screen}}
\textcolor{ansi-blue-intense}{\textbf{data3}}            fileB    linux-commands.ipynb      news     sorted-names
\textcolor{ansi-blue-intense}{\textbf{data4}}            fmt.out  linux-commands.ipynb.bak  otest    \textcolor{ansi-blue-intense}{\textbf{wildcard}}

    \end{Verbatim}

    လက်ရှိရောက်နေတဲ့ ဖိုလ်ဒါအောက်မှာ ရှိတာတွေကို ရိုက်ပြပါလိမ့်မယ်။

    အဲဒီ နာမည်တွေက ဖိုင်တွေလည်းဖြစ်နိုင်သလို၊ ဖိုလ်ဒါတွေကော
မဖြစ်နိုင်ဘူးလားလို့ မေးရင်၊ Linux OS မှာက ဖိုလ်ဒါဆိုရင် နာမည်နောက်က /
(forward slash) လိုက်တယ်။ ပုံမှန်အားဖြင့်က setting မလုပ်ထားရင် /
ကိုတွဲမပြဘူး။ ဘာကြောင့်လဲ ဆိုတော့ တကယ်တမ်းက ဖိုင်နဲ့ ဖိုလ်ဒါနဲ့က
အရောင်မတူဘူး။ အဲဒါကြောင့် အရောင်ကို ကြည့်ပြီး ဖိုင်လား၊ ဖိုလ်ဒါလားက
သိသာလို့ပါ။

ဖိုလ်ဒါ အသစ် တစ်ခုဆောက်ချင်ရင် mkdir ဆိုတဲ့ command ကိုသုံးတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} mkdir folder\PYZhy{}athit
\end{Verbatim}

    ls command ကိုပြန်ရိုက်ကြည့်မယ်။ ဆောက်လိုက်တဲ့ ဖိုလ်ဒါအသစ် folder-athit
ကိုမြင်ရလိမ့်မယ်။

ဖိုလ်ဒါတွေကို / နဲ့တွဲပြစေချင်ရင် ls command ကို option -p ထည့်ပြီး run
ကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} ls \PYZhy{}p
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
all-vi-info.txt  fileA          linux-commands.ipynb      otest.tag
\textcolor{ansi-blue-intense}{\textbf{data1}}/           fileB          linux-commands.ipynb.bak  otest.word
\textcolor{ansi-blue-intense}{\textbf{data2}}/           fmt.out        ls.out                    \textcolor{ansi-blue-intense}{\textbf{screen}}/
\textcolor{ansi-blue-intense}{\textbf{data3}}/           \textcolor{ansi-blue-intense}{\textbf{folderA}}/       my-news                   sorted-names
\textcolor{ansi-blue-intense}{\textbf{data4}}/           \textcolor{ansi-blue-intense}{\textbf{folder-athit}}/  newfile                   \textcolor{ansi-blue-intense}{\textbf{wildcard}}/
\textcolor{ansi-blue-intense}{\textbf{data5}}/           \textcolor{ansi-blue-intense}{\textbf{folder-new}}/    news
echo             item-list      otest

    \end{Verbatim}

    ဖိုလ်ဒါ ဖြစ်တဲ့ folder-athit ရဲ့နောက်မှာ / ပါလာတာကို တွေ့ရလိမ့်မယ်။

ဖိုင်အမျိုးအစားတွေကို အသေးစိတ်ပြပေးစေချင်ရင် -F option
ကိုသုံးပြီးကြည့်တယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} ls \PYZhy{}F /usr/bin/r*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-cyan-intense}{\textbf{/usr/bin/ranlib}}@           \textcolor{ansi-green-intense}{\textbf{/usr/bin/rfcomm}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/rasttopnm}}*        \textcolor{ansi-green-intense}{\textbf{/usr/bin/rgb3toppm}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/rawtopgm}}*         \textcolor{ansi-green-intense}{\textbf{/usr/bin/rgrep}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/rawtoppm}}*         \textcolor{ansi-green-intense}{\textbf{/usr/bin/rhythmbox}}*
\textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rcc}}@              \textcolor{ansi-green-intense}{\textbf{/usr/bin/rhythmbox-client}}*
\textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rcp}}@              \textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rimraf}}@
\textcolor{ansi-green-intense}{\textbf{/usr/bin/rctest}}*           \textcolor{ansi-green-intense}{\textbf{/usr/bin/rletopnm}}*
\textcolor{ansi-cyan-intense}{\textbf{/usr/bin/readelf}}@          \textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rlogin}}@
\textcolor{ansi-green-intense}{\textbf{/usr/bin/realpath}}*         \textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rmid}}@
\textcolor{ansi-green-intense}{\textbf{/usr/bin/recode-sr-latin}}*  \textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rmiregistry}}@
\textcolor{ansi-green-intense}{\textbf{/usr/bin/recountdiff}}*      \textcolor{ansi-green-intense}{\textbf{/usr/bin/routef}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/rediff}}*           \textcolor{ansi-green-intense}{\textbf{/usr/bin/routel}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/remmina}}*          \textcolor{ansi-green-intense}{\textbf{/usr/bin/rpcgen}}*
\textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rename}}@           \textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rsh}}@
\textcolor{ansi-green-intense}{\textbf{/usr/bin/rename.ul}}*        \textcolor{ansi-green-intense}{\textbf{/usr/bin/rstart}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/rendercheck}}*      \textcolor{ansi-green-intense}{\textbf{/usr/bin/rstartd}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/renice}}*           \textcolor{ansi-green-intense}{\textbf{/usr/bin/rsync}}*
\textcolor{ansi-cyan-intense}{\textbf{/usr/bin/reset}}@            \textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rtstat}}@
\textcolor{ansi-green-intense}{\textbf{/usr/bin/resize}}*           \textcolor{ansi-green-intense}{\textbf{/usr/bin/runcon}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/resizecons}}*       \textcolor{ansi-green-intense}{\textbf{/usr/bin/run-mailcap}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/resizepart}}*       \textcolor{ansi-green-intense}{\textbf{/usr/bin/run-with-aspell}}*
\textcolor{ansi-green-intense}{\textbf{/usr/bin/rev}}*              \textcolor{ansi-cyan-intense}{\textbf{/usr/bin/rview}}@

    \end{Verbatim}

    -F option နဲ့ /usr/bin/ ဖိုလ်ဒါအောက်မှာရှိတဲ့ rစာလုံးနဲ့စတဲ့ ဖိုင်တွေကို
ပြခိုင်းတဲ့ အခါမှာ ဖိုင်နာမည်တွေရဲ့ နောက်မှာ @ နဲ့ *
အမှတ်အသားတွေပါလာတာကို တွေ့ရပါ လိမ့်မယ်။ * အမှတ်အသားက executable
လုပ်လို့ရတဲ့ဖိုင်၊ run လို့ရတဲ့ ဖိုင်ကို ဆိုလိုပြီး၊ @ အမှတ်အသားကတော့
symbolic link အနေနဲ့ ချိတ်ထားတဲ့ ဖိုင်လို့ ဆိုလိုတာပါ။\\
symbolic link ကိစ္စကိုတော့ နောက်ပိုင်းမှာ ln command ကို သင်တဲ့အခါ
ရှင်းပါမယ်။ အခုလောလောဆယ်တော့ ls command ရဲ့ -F option နဲ့ပတ်သတ်တာကိုပဲ
အာရုံစိုက်ကြရအောင်။

-F option က * နဲ့ @ အမှတ်အသားတွေ အပြင်၊ အောက်ပါ အမှတ်အသားတွေကိုလဲ
ဖိုင်အမျိုးအစားပေါ်မူတည်ပြီး ပြပေးပါလိမ့်မယ်။

/ ဖိုလ်ဒါ\\
\textbar{} named pipe ဖိုင်အမျိုးအစား။ FIFO ဖိုင်လို့လဲ ခေါ်တယ်။
နောက်ပိုင်းမှာ အသေးစိတ်ရှင်းပြမယ်။\\
= socket ဖိုင်\\
\textgreater{} door ဖိုင်အမျိုးအစားပါ။ Linux မှာ မသုံးပါဘူး။ Sun/Solaris
Unix system မှာသုံးတယ်။

ဖွက်ထားတဲ့ ဖိုင်တွေကို ကြည့်ချင်ရင် ls command ရဲ့ option တခုဖြစ်တဲ့ -a
သုံးတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} ls \PYZhy{}a
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-blue-intense}{\textbf{.}}                echo          \textcolor{ansi-blue-intense}{\textbf{.ipynb\_checkpoints}}        otest
\textcolor{ansi-blue-intense}{\textbf{..}}               fileA         item-list                 otest.tag
all-vi-info.txt  fileB         linux-commands.ipynb      otest.word
\textcolor{ansi-blue-intense}{\textbf{data1}}            .fileC        linux-commands.ipynb.bak  \textcolor{ansi-blue-intense}{\textbf{screen}}
\textcolor{ansi-blue-intense}{\textbf{data2}}            fmt.out       ls.out                    sorted-names
\textcolor{ansi-blue-intense}{\textbf{data3}}            \textcolor{ansi-blue-intense}{\textbf{folderA}}       my-news                   \textcolor{ansi-blue-intense}{\textbf{wildcard}}
\textcolor{ansi-blue-intense}{\textbf{data4}}            \textcolor{ansi-blue-intense}{\textbf{folder-athit}}  newfile
\textcolor{ansi-blue-intense}{\textbf{data5}}            \textcolor{ansi-blue-intense}{\textbf{folder-new}}    news

    \end{Verbatim}

    အထက်မှာ မြင်ခဲ့ရတာနဲ့ မတူတာက "." ရယ်၊ ".." ရယ်၊ ".fileC" ရယ် ဆိုတာကို
သတိပြုမိလိမ့်မယ်။\\
. က လက်ရှိရောက်နေတဲ့ path ကို ညွှန်းတဲ့ အခါမှာ သုံးတယ်။\\
.. က လက်ရှိရောက်နေတဲ့ path ကနေ အထက်တဆင့်မှာရှိတဲ့ path ကိုညွှန်းတဲ့
အခါမှာ အသုံးပြုတယ်။ (နောက်ပိုင်းမှာ cd command နဲ့အတူရှင်းပြမယ်)\\
.fileC နဲ့ .ipynb\_checkpoints ဖိုင်က ဖွက်ထားတဲ့ ဖိုင်ပါ။
အများသောအားဖြင့် ဖွက်ထားတဲ့ ဖိုင်တွေက application၊ shell တို့ရဲ့ setting
ဖိုင်တွေ ဖြစ်ကြပါတယ်။\\
Linux OS မှာက "." နဲ့စတဲ့ ဖိုင်နာမည်တွေဆိုရင် ls command က ပြမပေးပါဘူး။
မှားပြီး ဖျက်မိတာမျိုး၊ ဝင်ပြင်ရေးမိတဲ့ အမှားတွေကို လျော့နည်းစေဖို့
ရည်ရွယ်ပါတယ်။

ဖိုင်တွေ၊ ဖိုလ်ဒါတွေ ရဲ့ information ကိုအသေးစိတ်ပြပေးစေချင်ရင် ls
command ကို -l option နဲ့တွဲရိုက်ကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} ls \PYZhy{}l
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
total 1272
-rw-rw-r-- 1 lar lar  16937  8月 11 11:14 all-vi-info.txt
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data1}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data2}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data3}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data4}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data5}}
-rw-rw-r-- 1 lar lar      0  8月 11 11:14 echo
-rw-rw-r-- 1 lar lar     67  8月 11 17:48 fileA
-rw-rw-r-- 1 lar lar     61  8月 11 11:14 fileB
-rw-rw-r-- 1 lar lar   3117  8月 11 11:14 fmt.out
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folderA}}
drwxrwxr-x 2 lar lar   4096  8月 11 18:04 \textcolor{ansi-blue-intense}{\textbf{folder-athit}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folder-new}}
-rw-rw-r-- 1 lar lar     51  8月 11 17:46 item-list
-rw-rw-r-- 1 lar lar 237013  8月 11 18:02 linux-commands.ipynb
-rw-rw-r-- 1 lar lar 202186  8月 11 11:14 linux-commands.ipynb.bak
-rw-rw-r-- 1 lar lar    177  8月 11 11:14 ls.out
-rw-rw-r-- 1 lar lar   3117  8月 11 11:14 my-news
-rw-rw-r-- 1 lar lar      0  2月  3  2015 newfile
-rw-rw-r-- 1 lar lar   4246  8月 11 11:14 news
-rw-r--r-- 1 lar lar 377269  8月 11 11:14 otest
-rw-r--r-- 1 lar lar  73420  8月 11 11:14 otest.tag
-rw-r--r-- 1 lar lar 303849  8月 11 11:14 otest.word
drwxrwxr-x 2 lar lar   4096  8月 11 18:01 \textcolor{ansi-blue-intense}{\textbf{screen}}
-rw-rw-r-- 1 lar lar     68  8月 11 11:14 sorted-names
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{wildcard}}

    \end{Verbatim}

    ဘာတွေပြနေသလဲ ဆိုတော့

-rw-rw-r-\/- 1 lar lar 67 8月 11 11:14 fileA ဆိုတဲ့ စာကြောင်းမှာ\\
ပထမဆုံး စာလုံး "-" (dash) က ပုံမှန်ဖိုင် လို့ဆိုလိုတယ်။\\
အဲဒီနေရာမှာ "d" ဆိုရင် directory (or) folder လို့ဆိုလိုတယ်။\\
rw-rw-r-\/- (စာလုံး ၉လုံး) က ဖိုင်နဲ့ ပတ်သက်တဲ့ permission တွေကို
ပြပေးတာ။\\
ဘယ်သူက၊ ဘယ်အုပ်စုက ဒီဖိုင်ကို ဖတ်လို့ရတယ် ဆိုတာကို "r" နဲ့၊
ဝင်ပြင်လို့ရတယ် ဆိုတာကို "w" နဲ့၊ ပရိုဂရမ်အနေနဲ့ execute (or) run
လုပ်လို့ရတယ် ဆိုတာကို "x" သင်္ကေတနဲ့ ပြပေးလိမ့်မယ်။\\
1 ဆိုတာက link ဘယ်နှစ်ခုရှိနေသလဲ ဆိုတာကို ပြပေးတာ။\\
ပထမဆုံးတွေ့ရတဲ့ lar က ဖိုင်ရဲ့ ပိုင်ရှင်က ဘယ်သူလဲ (သို့) ဘယ် acount name
လဲ ဆိုတာကို ပြပေးတာ။\\
ဒုတိယတွေ့ရတဲ့ lar က ဘယ်အုပ်စု (group) နဲဆိုင်တယ် ဆိုတာကိုပြပေးတာ။\\
67 ဆိုတာက ဖိုင်ရဲ့ အရွယ်အစား (size) ကို bit နဲ့ပြပေးတာ။\\
ဥပမာ 1 KB = 1024 bits, 1 MB = 1024 KB။

8月 11 11:14 ဆိုတာက ဖိုင်ကို နောက်ဆုံးပြင်ခဲ့တဲ့ လ၊ ရက်၊ နာရီကို
ပြေနေတာ။\\
မပြောလဲ မြင်မှာပါ။ fileA ဆိုတာက ဖိုင်နာမည်ပါ။

    size ကြီးတဲ့ အစီအစဉ်အတိုင်း ပြပေးစေချင်ရင် option -S ကိုသုံးတယ်။\\
ဖိုင် Size အကြီးဆုံးက ထိပ်ဆုံးမှာ ရှိပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} ls \PYZhy{}lS
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
total 1272
-rw-r--r-- 1 lar lar 377269  8月 11 11:14 otest
-rw-r--r-- 1 lar lar 303849  8月 11 11:14 otest.word
-rw-rw-r-- 1 lar lar 237013  8月 11 18:02 linux-commands.ipynb
-rw-rw-r-- 1 lar lar 202186  8月 11 11:14 linux-commands.ipynb.bak
-rw-r--r-- 1 lar lar  73420  8月 11 11:14 otest.tag
-rw-rw-r-- 1 lar lar  16937  8月 11 11:14 all-vi-info.txt
-rw-rw-r-- 1 lar lar   4246  8月 11 11:14 news
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data1}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data2}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data3}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data4}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data5}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folderA}}
drwxrwxr-x 2 lar lar   4096  8月 11 18:04 \textcolor{ansi-blue-intense}{\textbf{folder-athit}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folder-new}}
drwxrwxr-x 2 lar lar   4096  8月 11 18:01 \textcolor{ansi-blue-intense}{\textbf{screen}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{wildcard}}
-rw-rw-r-- 1 lar lar   3117  8月 11 11:14 fmt.out
-rw-rw-r-- 1 lar lar   3117  8月 11 11:14 my-news
-rw-rw-r-- 1 lar lar    177  8月 11 11:14 ls.out
-rw-rw-r-- 1 lar lar     68  8月 11 11:14 sorted-names
-rw-rw-r-- 1 lar lar     67  8月 11 17:48 fileA
-rw-rw-r-- 1 lar lar     61  8月 11 11:14 fileB
-rw-rw-r-- 1 lar lar     51  8月 11 17:46 item-list
-rw-rw-r-- 1 lar lar      0  8月 11 11:14 echo
-rw-rw-r-- 1 lar lar      0  2月  3  2015 newfile

    \end{Verbatim}

    ဖိုင်ရဲ့ size ငယ်စဉ်ကြီးလိုက် အစီအစဉ်နဲ့ စီပြပေးစေချင်ရင် -r (reverse)
ကို သုံးပါတယ်။ option အပြည့်အစုံကတော့ -lSr ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} ls \PYZhy{}lSr
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
total 1272
-rw-rw-r-- 1 lar lar      0  2月  3  2015 newfile
-rw-rw-r-- 1 lar lar      0  8月 11 11:14 echo
-rw-rw-r-- 1 lar lar     51  8月 11 17:46 item-list
-rw-rw-r-- 1 lar lar     61  8月 11 11:14 fileB
-rw-rw-r-- 1 lar lar     67  8月 11 17:48 fileA
-rw-rw-r-- 1 lar lar     68  8月 11 11:14 sorted-names
-rw-rw-r-- 1 lar lar    177  8月 11 11:14 ls.out
-rw-rw-r-- 1 lar lar   3117  8月 11 11:14 my-news
-rw-rw-r-- 1 lar lar   3117  8月 11 11:14 fmt.out
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{wildcard}}
drwxrwxr-x 2 lar lar   4096  8月 11 18:01 \textcolor{ansi-blue-intense}{\textbf{screen}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folder-new}}
drwxrwxr-x 2 lar lar   4096  8月 11 18:04 \textcolor{ansi-blue-intense}{\textbf{folder-athit}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folderA}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data5}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data4}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data3}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data2}}
drwxrwxr-x 2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data1}}
-rw-rw-r-- 1 lar lar   4246  8月 11 11:14 news
-rw-rw-r-- 1 lar lar  16937  8月 11 11:14 all-vi-info.txt
-rw-r--r-- 1 lar lar  73420  8月 11 11:14 otest.tag
-rw-rw-r-- 1 lar lar 202186  8月 11 11:14 linux-commands.ipynb.bak
-rw-rw-r-- 1 lar lar 237013  8月 11 18:02 linux-commands.ipynb
-rw-r--r-- 1 lar lar 303849  8月 11 11:14 otest.word
-rw-r--r-- 1 lar lar 377269  8月 11 11:14 otest

    \end{Verbatim}

    ဖိုင်ရဲ့ အရွယ်အစား (size) တွေကို လူကဖတ်လို့လွယ်တဲ့ format (ဥပမာ၊ KB, MB,
GB, TB) နဲ့ ပြပေးစေချင်ရင် -h option ကိုသုံးပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} ls \PYZhy{}lh
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
total 1.3M
-rw-rw-r-- 1 lar lar  17K  8月 11 11:14 all-vi-info.txt
drwxrwxr-x 2 lar lar 4.0K  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data1}}
drwxrwxr-x 2 lar lar 4.0K  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data2}}
drwxrwxr-x 2 lar lar 4.0K  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data3}}
drwxrwxr-x 2 lar lar 4.0K  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data4}}
drwxrwxr-x 2 lar lar 4.0K  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data5}}
-rw-rw-r-- 1 lar lar    0  8月 11 11:14 echo
-rw-rw-r-- 1 lar lar   67  8月 11 17:48 fileA
-rw-rw-r-- 1 lar lar   61  8月 11 11:14 fileB
-rw-rw-r-- 1 lar lar 3.1K  8月 11 11:14 fmt.out
drwxrwxr-x 2 lar lar 4.0K  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folderA}}
drwxrwxr-x 2 lar lar 4.0K  8月 11 18:04 \textcolor{ansi-blue-intense}{\textbf{folder-athit}}
drwxrwxr-x 2 lar lar 4.0K  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folder-new}}
-rw-rw-r-- 1 lar lar   51  8月 11 17:46 item-list
-rw-rw-r-- 1 lar lar 232K  8月 11 18:02 linux-commands.ipynb
-rw-rw-r-- 1 lar lar 198K  8月 11 11:14 linux-commands.ipynb.bak
-rw-rw-r-- 1 lar lar  177  8月 11 11:14 ls.out
-rw-rw-r-- 1 lar lar 3.1K  8月 11 11:14 my-news
-rw-rw-r-- 1 lar lar    0  2月  3  2015 newfile
-rw-rw-r-- 1 lar lar 4.2K  8月 11 11:14 news
-rw-r--r-- 1 lar lar 369K  8月 11 11:14 otest
-rw-r--r-- 1 lar lar  72K  8月 11 11:14 otest.tag
-rw-r--r-- 1 lar lar 297K  8月 11 11:14 otest.word
drwxrwxr-x 2 lar lar 4.0K  8月 11 18:01 \textcolor{ansi-blue-intense}{\textbf{screen}}
-rw-rw-r-- 1 lar lar   68  8月 11 11:14 sorted-names
drwxrwxr-x 2 lar lar 4.0K  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{wildcard}}

    \end{Verbatim}

    -lt option နဲ့ ဖိုင်တွေ၊ ဖိုလ်ဒါတွေကို အချိန်နဲစီခိုင်းလို့ရပါတယ်။\\
t option က နောက်ဆုံးပြင်ခဲ့၊ ရေးခဲ့တဲ့ဖိုင်ကို ထိပ်ဆုံးမှာထားပေးပြီး
စီပေးပါလိမ့်မယ်။\\
အောက်ပါ command က ကိုယ်ဒေါင်းလုဒ် လုပ်ခဲ့တဲ့ ဖိုင်တွေကို အချိန်နဲ့
စီကြည့်တဲ့ ဥပမာပါ။\\
ပုံမှန်အားဖြင့် (default setting) က အင်တာနက်ကနေ ဒေါင်းလုဒ်လုပ်လိုက်တဲ့
ဖိုင်တွေက ဟုမ်းဖိုလ်ဒါအောက်က Downloads ဆိုတဲ့ ဖိုလ်ဒါအောက်မှာ
သိမ်းပါတယ်။\\
(ဒီနေရာမှာ "\textasciitilde{}" က လက်ရှိ login ဝင်ထားတဲ့ account ရဲ့ home
directory ကိုဆိုလိုပါတယ်။)

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} ls \PYZti{}/Downloads \PYZhy{}lt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
total 922700
-rw-rw-r--  1 lar lar      7370  8月 10 04:20 \textcolor{ansi-red-intense}{\textbf{bash\_kernel-master (1).zip}}
drwxrwxr-x  7 lar lar      4096  8月 10 04:12 \textcolor{ansi-blue-intense}{\textbf{jupyter-nodejs}}
-rwxrwxr-x  1 lar lar       222  8月 10 03:52 \textcolor{ansi-green-intense}{\textbf{js-kernel-install.sh}}
-rw-rw-r--  1 lar lar     71197  8月 10 03:47 \textcolor{ansi-red-intense}{\textbf{jupyter-scala-master.zip}}
-rw-rw-r--  1 lar lar      7370  8月 10 03:43 \textcolor{ansi-red-intense}{\textbf{bash\_kernel-master.zip}}
-rw-rw-r--  1 lar lar     85041  8月  8 17:49 kaigaikoutei-icdl2017.pdf
drwxrwxr-x  6 lar lar      4096  8月  6 14:58 \textcolor{ansi-blue-intense}{\textbf{ocr-data}}
-rw-rw-r--  1 lar lar 141808408  8月  6 14:35 \textcolor{ansi-red-intense}{\textbf{ocr-demo-site7.zip}}
-rw-rw-r--  1 lar lar   1104821  8月  6 14:35 \textcolor{ansi-red-intense}{\textbf{train-tif-box-original.zip}}
-rw-rw-r--  1 lar lar  23875368  8月  6 14:35 \textcolor{ansi-red-intense}{\textbf{icu4c-52\_1-src.tgz}}
-rw-rw-r--  1 lar lar   6126586  8月  6 14:35 \textcolor{ansi-red-intense}{\textbf{jTessBoxEditor-my-rule1.zip}}
drwxrwxr-x 31 lar lar      4096  8月  6 13:07 \textcolor{ansi-blue-intense}{\textbf{tesseract-master}}
-rw-rw-r--  1 lar lar  43779562  8月  6 13:06 \textcolor{ansi-red-intense}{\textbf{opencv\_python\_examples-master.zip}}
drwxrwxr-x  8 lar lar      4096  8月  6 12:30 \textcolor{ansi-blue-intense}{\textbf{leptonica-1.74.4}}
-rw-rw-r--  1 lar lar  12349877  8月  6 12:29 \textcolor{ansi-red-intense}{\textbf{leptonica-1.74.4.tar.gz}}
-rw-rw-r--  1 lar lar   4524383  8月  6 10:56 \textcolor{ansi-red-intense}{\textbf{tesseract-master.zip}}
drwxrwxr-x  4 lar lar      4096  8月  6 10:52 \textcolor{ansi-blue-intense}{\textbf{tesseract-ocr.github.io-master}}
-rw-rw-r--  1 lar lar  43793679  8月  6 10:52 \textcolor{ansi-red-intense}{\textbf{tesseract-ocr.github.io-master.zip}}
drwxrwxr-x  3 lar lar      4096  8月  4 18:47 \textcolor{ansi-blue-intense}{\textbf{bash\_kernel-master}}
drwxrwxr-x  2 lar lar      4096  8月  3 15:29 \textcolor{ansi-blue-intense}{\textbf{ebook}}
-rw-rw-r--  1 lar lar  40686466  8月  1 22:34 \textcolor{ansi-red-intense}{\textbf{introduction\_to\_ml\_with\_python-master.zip}}
-rw-rw-r--  1 lar lar 523283080  8月  1 21:25 Anaconda3-4.4.0-Linux-x86\_64.sh
-rw-rw-r--  1 lar lar  51327604  7月 16 15:36 \textcolor{ansi-red-intense}{\textbf{skypeforlinux-64.deb}}
drwxrwxr-x 11 lar lar      4096  7月  5 04:11 \textcolor{ansi-blue-intense}{\textbf{jupyter-scala-master}}
-rw-rw-r--  1 lar lar     67600  5月 21 21:42 ctest2.nopipe.word
-rw-rw-r--  1 lar lar   3737012  4月 29 09:33 1505.00687.pdf
-rw-rw-r--  1 lar lar    479931  4月 19 16:29 flexcrfs.pdf
-rw-------  1 lar lar    194870  4月 19 16:25 Introduction to Conditional Random Fields.pdf
-rw-rw-r--  1 lar lar  47321450  4月 19 14:14 \textcolor{ansi-red-intense}{\textbf{google-chrome-stable\_current\_amd64.deb}}
-rw-rw-r--  1 lar lar     47389  4月 12 21:53 \textcolor{ansi-red-intense}{\textbf{myanmar3.zip}}
drwx------  3 lar lar      4096 10月 31  2015 \textcolor{ansi-blue-intense}{\textbf{jTessBoxEditor-1.4-src-edit-myanmar-rule1-only}}

    \end{Verbatim}

    လက်ရှိ နေရာအောက်မှာရှိတဲ့ "ဖိုလ်ဒါတွေကိုပဲ" ပြပေးပါဆိုရင် -d option နဲ့
*/ pattern ကို တွဲသုံးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} ls \PYZhy{}d */
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-blue-intense}{\textbf{data1/}}  \textcolor{ansi-blue-intense}{\textbf{data3/}}  \textcolor{ansi-blue-intense}{\textbf{data5/}}    \textcolor{ansi-blue-intense}{\textbf{folder-athit/}}  \textcolor{ansi-blue-intense}{\textbf{screen/}}
\textcolor{ansi-blue-intense}{\textbf{data2/}}  \textcolor{ansi-blue-intense}{\textbf{data4/}}  \textcolor{ansi-blue-intense}{\textbf{folderA/}}  \textcolor{ansi-blue-intense}{\textbf{folder-new/}}    \textcolor{ansi-blue-intense}{\textbf{wildcard/}}

    \end{Verbatim}

    -R option နဲ့ ဖိုလ်ဒါရဲ့ အောက်မှာရှိနေတဲ့ ဖိုင်တွေ၊ ဖိုလ်ဒါ အဆင့်ဆင့်တွေ
အားလုံးကို ပြခိုင်းလို့ ရပါတယ်။

ဥပမာ \textasciitilde{}/Pictures/ ရဲ့ အောက်မှာ ရှိသမျှ ဖိုင်တွေ၊
ဖိုလ်ဒါတွေကို ပြခိုင်းစေချင်ရင် အောက်ပါအတိုင်း ရိုက်ကြည့်ပါ။\\
(ဒီနေရာမှာ "\textasciitilde{}" က လက်ရှိ login ဝင်ထားတဲ့ account ရဲ့ home
directory ကိုဆိုလိုပါတယ်။)\\
လက်ရှိ ကျွန်တော် သုံးနေတဲ့ ကွန်ပြူတာ ရဲ့ ဟုမ်းဖိုလ်ဒါအောက်က Pictures
ဖိုလ်ဒါအောက်မှာ layout ဆိုတဲ့ ဖိုလ်ဒါကရှိနေတော့\\
အဲဒီအောက်မှာ ရှိတဲ့ ဖိုင်တွေကို ပြသပေးပါတယ်။\\
လောလောဆယ် လက်ရှိမှာရှိတဲ့ ဖိုင်နှစ်ဖိုင်ဖြစ်တဲ့ kkg-ver0.1.pdf ဖိုင်နဲ့
Selection\_001.png ဖိုင်ကို ပြပေးပါလိမ့်မယ်။\\
တကယ်လို့ အဲဒီ layout ဆိုတဲ့ ဖိုလ်ဒါအောက်မှာ နောက်တစ်ဆင့်
ဖိုလ်ဒါတွေသာရှိခဲ့ရင်၊ အဲဒီဖိုလ်ဒါအောက်မှာရှိတဲ့ ဖိုင်တွေ၊ ဖိုလ်ဒါတွေကို
ဆင့်ကဲဆင့်ကဲ ပြသပေးမှာဖြစ်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} ls \PYZhy{}R \PYZti{}/Pictures/
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/Pictures/:
\textcolor{ansi-magenta-intense}{\textbf{Choose an input source\_003.png}}  \textcolor{ansi-magenta-intense}{\textbf{Menu\_005.png}}          \textcolor{ansi-magenta-intense}{\textbf{selecting-kkg.png}}
\textcolor{ansi-magenta-intense}{\textbf{ChooseAnInputSource.jpg}}         \textcolor{ansi-magenta-intense}{\textbf{selecting-kkg-eg.jpg}}  \textcolor{ansi-magenta-intense}{\textbf{Selection\_006.png}}
\textcolor{ansi-blue-intense}{\textbf{layout}}                          \textcolor{ansi-magenta-intense}{\textbf{selecting-kkg-eg.png}}  \textcolor{ansi-magenta-intense}{\textbf{Text Entry\_002.png}}
\textcolor{ansi-magenta-intense}{\textbf{Menu\_004.png}}                    \textcolor{ansi-magenta-intense}{\textbf{selecting-kkg.jpg}}     \textcolor{ansi-magenta-intense}{\textbf{Text-Entry-Dbox.jpg}}

/home/lar/Pictures/layout:
kkg-ver0.1.pdf  \textcolor{ansi-magenta-intense}{\textbf{Selection\_001.png}}

    \end{Verbatim}

    \subsection{2. pwd (print name of current/working
directory)}\label{pwd-print-name-of-currentworking-directory}

လက်ရှိ ရောက်နေတဲ့ ဖိုလ်ဒါကို သိချင်ရင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{n+nb}{pwd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/linux-cmd

    \end{Verbatim}

    Linux မှာ ဖိုလ်ဒါတခုနဲ့ တခုအကြားကို / (forward slash) နဲ့ ခွဲပြီးပြတယ်။

တစ်ခုသိထားစေချင်တာက linux command တွေမှာက အင်္ဂလိပ်စာလုံး အကြီး၊ အသေးကို
ခွဲခြားပြီးသုံးတယ်။ အဲဒါကြောင့် pwd ကို ရိုက်တဲ့ အခါမှာ စာလုံးအားလုံးက
အသေးဖြစ်ရမယ်။ တကယ်လို့ အခုအချိန်ထိသင်ပေးခဲ့တဲ့ command နှစ်ခုဖြစ်တဲ့
"ls" နဲ့ "pwd" ကို LS, lS, PWD, pWd စသည်ဖြင့်ရိုက်ရင် အလုပ်မလုပ်ပါဘူး။
error message ပေးပါလိမ့်မယ်။

    \subsection{3. cd (change the shell working
directory)}\label{cd-change-the-shell-working-directory}

ဖိုလ်ဒါ တခုကနေ နောက်ဖိုလ်ဒါ တခုကို ရွှေ့မယ်ဆိုရင် သုံးတဲ့ command ပါ။\\
ဥပမာ လက်ရှိရောက်နေတဲ့ နေရာအောက်မှာ ဖိုလ်ဒါနာမည် folderA ရှိတယ်။ အဲဒီ
ဖိုလ်ဒါဆီကို ရွှေ့ပေးပါဆိုရင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n+nb}{cd} folderA
\end{Verbatim}

    လက်ရှိရောက်နေတဲ့ folder path ကနေ ကိုယ့်ရဲ့ home ဖိုလ်ဒါဆီ ကို
ရွှေ့ချင်ရင် \textasciitilde{} (tilde) option ကို သုံးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n+nb}{cd} \PYZti{}
\end{Verbatim}

    ပြီးတော့ လက်ရှိရောက်နေတဲ့ ဖိုလ်ဒါနေရာကို confirm လုပ်ဖို့အတွက်၊ အထက်မှာ
ပြောခဲ့တဲ့ pwd command သုံးကြည့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n+nb}{pwd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar

    \end{Verbatim}

    လက်ရှိရောက်နေတဲ့ /home/hb/ နေရာကနေ့ အထက်တဆင့် path ကိုတက်ချင်တဲ့ အခါမှာ
.. ကို သုံးပြီးတက်နိုင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n+nb}{cd} ..
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{n+nb}{pwd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home

    \end{Verbatim}

    - option ကို သုံးပြီး နောက်ဆုံးဝင်ခဲ့တဲ့ ဖိုလ်ဒါနေရာ (path) ဆီကို
ပြန်ရွှေ့လို့ရပါတယ်။

အောက်ပါဥပမာက ပထမ လက်ရှိရှိနေရာတဲ့ နေရာကနေ ရှည်လျားတဲ့ ဖိုလ်ဒါ တခုအောက်
(/usr/share/X11/xkb/geometry/) ကို ဝင်ပါတယ်။ အဲဒီမှာ ရှိတဲ့ ဖိုင်တွေကို
ls နဲ့ list လုပ်ကြည့်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{n+nb}{cd} /usr/share/X11/xkb/geometry/
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} ls
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
amiga    \textcolor{ansi-blue-intense}{\textbf{digital\_vndr}}  hp         microsoft  pc        sony      typematrix
ataritt  everex        keytronic  nec        README    sun       winbook
chicony  fujitsu       kinesis    nokia      sanwa     teck
dell     hhk           macintosh  northgate  \textcolor{ansi-blue-intense}{\textbf{sgi\_vndr}}  thinkpad

    \end{Verbatim}

    ပြီးတော့ ကိုယ်ရဲ့ home folder အောက်ကို cd \textasciitilde{} နဲ့
သွားပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{n+nb}{cd} \PYZti{}
\end{Verbatim}

    မြင်သာအောင် pwd နဲ့ home folder အောက်ကိုရောက်နေတာကို ရိုက်ပြထားတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n+nb}{pwd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar

    \end{Verbatim}

    စိတ်ကူးပြောင်းသွားပြီး ခုနက နောက်ဆုံးရှိနေခဲ့တဲ့ဖိုလ်ဒါအောက်ဖြစ်တဲ့
/usr/share/X11/xkb/geometry/ ဆီကို ပြန်ဝင်ချင်တဲ့ အခါမှာ
ဖိုလ်ဒါနာမည်တွေကို ပြန်ရိုက်စရာမလိုပဲ - (dash option)
ကိုသုံးလို့ရကြောင်းကို လုပ်ပြတာပါ။ တကယ်တမ်း command တွေကို
သုံးပြီးအလုပ်လုပ်တဲ့ အခါမှာ မြန်ဆန်ဖို့အတွက် ဒီ - option က အရမ်းကို
အသုံးဝင်ပါတယ်။ အထူးသဖြင့် ရှည်လျားတဲ့ ဖိုလ်ဒါ path တွေ တစ်ခုကနေ တစ်ခုကို
ရွှေ့ပြောင်းပြီး အလုပ်လုပ်တဲ့ အခါမျိုးမှာပါ။ မှတ်ထားသင့်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n+nb}{cd} \PYZhy{}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/usr/share/X11/xkb/geometry

    \end{Verbatim}

    \subsection{4. cat (concatenate files and print on the standard
output)}\label{cat-concatenate-files-and-print-on-the-standard-output}

cat command က ဖိုင်တဖိုင်ရဲ့ အထဲမှာ ရှိတဲ့ စာကြောင်းတွေ အားလုံးကို
ရိုက်ထုတ်ပြဖို့ သုံးပါတယ်။\\
cat command ကို မသုံးခင်၊ အရင်ဆုံး linux command တွေကို သင်ကြားဖို့အတွက်
ကျွန်တော်က ပြင်ဆင်ထားတဲ့ path ဆီကို ရွှေ့မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{n+nb}{cd} \PYZti{}/linux\PYZhy{}cmd
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{n+nb}{pwd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/linux-cmd

    \end{Verbatim}

    ဘာဖိုင်တွေ၊ ဘာဖိုလ်ဒါတွေ ရှိသလဲ ဆိုတာကို ls နဲ့အရင်ကြည့်မယ်။\\
ဒီတခါတော့ option ကို -1X ကိုသုံးကြည့်မယ်။\\
-1X နဲ့ဆိုရင် ရှိတဲ့ ဖိုင်နာမည်၊ ဖိုလ်ဒါနာမည်တွေကို တစ်ကြောင်းချင်းစီ
ရိုက်ပြလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} ls \PYZhy{}1X
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-blue-intense}{\textbf{data1}}
\textcolor{ansi-blue-intense}{\textbf{data2}}
\textcolor{ansi-blue-intense}{\textbf{data3}}
\textcolor{ansi-blue-intense}{\textbf{data4}}
\textcolor{ansi-blue-intense}{\textbf{data5}}
echo
fileA
fileB
\textcolor{ansi-blue-intense}{\textbf{folderA}}
\textcolor{ansi-blue-intense}{\textbf{folder-athit}}
\textcolor{ansi-blue-intense}{\textbf{folder-new}}
item-list
my-news
newfile
news
otest
\textcolor{ansi-blue-intense}{\textbf{screen}}
sorted-names
\textcolor{ansi-blue-intense}{\textbf{wildcard}}
linux-commands.ipynb.bak
linux-commands.ipynb
fmt.out
ls.out
otest.tag
all-vi-info.txt
otest.word

    \end{Verbatim}

    ဒီနေရာမှာ -1 က စာကြောင်းတစ်ကြောင်းမှာ ဖိုင်တစ်ဖိုင်စီ ရိုက်ပြတဲ့အလုပ်
(list one file per line) ကို လုပ်ပေးတဲ့ ls command ရဲ့ option ပါ။\\
-X (Capital X option) ကတော့ ဖိုင်တွေရဲ့ extension နဲ့
အက္ခရာစဉ်အလိုက်စီပေးပါတယ်။

Extension ဆိုတာက ဖိုင်နာမည်တွေရဲ့ နောက်ဆုံးမှာ ရှိနေတဲ့ dot
နဲ့ခွဲပြီးရေးထားတဲ့ အပိုင်းတွေကို ဆိုလိုပါတယ်။\\
ဥပမာ PDF ဖိုင်ဆိုရင် .pdf၊ ပုံဖိုင်အမျိုးအစားတစ်မျိုးဖြစ်တဲ့ .jpeg၊ bash
shell script ဖိုင်ဖြစ်တဲ့ .sh စတာမျိုးတွေပါ။

    cat command ကိုသုံးပြီး fileA ရဲ့အထဲမှာ ဘာတွေရေးထားလဲ ဆိုတာကို
ရိုက်ထုပ်ကြည့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} cat fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Mingalar bar!
I am fileA.
I was born in April.
My blood type is O.

    \end{Verbatim}

    ဖိုင်ထဲမှာရှိတဲ့ စာကြောင်းတွေကို ရိုက်ပြတဲ့ အခါမှာ လိုင်းနံပါတ်တွေ
တပ်ပြီးရိုက်ပြစေချင်ရင် -n option ကိုသုံးပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} cat \PYZhy{}n fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
     1	Mingalar bar!
     2	I am fileA.
     3	I was born in April.
     4	My blood type is O.

    \end{Verbatim}

    cat command ရဲ့ အသုံးဝင်တဲ့ option နှစ်ခုဖြစ်တဲ့ -T နဲ့ -E ကို
သုံးပြဖို့အတွက် item-list ဆိုတဲ့ ဖိုင်အသစ်တစ်ဖိုင်ကို echo command ကို
သုံးပြီး အောက်ပါအတိုင်းဆောက်ပါမယ်။ ဒီနေရာမှာ "\t" က tab ကီး "\n" က
စာကြောင်းတစ်ကြောင်း အောက်ကိုဆင်းဖို့အတွက် သုံးတဲ့ escape စာလုံးတွေပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}No\PYZbs{}tItem\PYZbs{}tStock\PYZbs{}n1\PYZbs{}tpencil\PYZbs{}t10\PYZbs{}n2\PYZbs{}truler\PYZbs{}t1000\PYZbs{}n3\PYZbs{}teraser\PYZbs{}t42\PYZdq{}} \PYZgt{} item\PYZhy{}list
\end{Verbatim}

    အခုဆောက်ခဲ့တဲ့ item-list ထဲမှာ ဘယ်လိုစာကြောင်းတွေရှိနေသလဲဆိုတာကို cat
command နဲ့ ရိုက်ကြည့်ပါမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} cat ./item\PYZhy{}list
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
No	Item	Stock
1	pencil	10
2	ruler	1000
3	eraser	42

    \end{Verbatim}

    အထက်ပါအတိုင်း No ရယ် Item ရယ် Stock ရယ်ဆိုပြီး ကော်လံသုံးခု ခွဲထားပြီး၊
ပစ္စည်း သုံးမျိုးဖြစ်တဲ့ pencil, ruler, eraser ရဲ့ ရှိနေတဲ့ အရေအတွက်ကို
သိမ်းထားတာတွေ့ရပါလိမ့်မယ်။ လက်တွေ့ item-list လို text file တွေကို၊
ကိုယ်လုပ်မဲ့ အလုပ်ပေါ်မူတည်ပြီးတော့ ပုံမှန်အားဖြင့် မမြင်နိုင်တဲ့ tab
ကီးတွေ၊ စာကြောင်း အဆုံးသင်္ကေတ တွေကို စစ်ဆေးကြည့်ဖို့၊ မြင်ရအောင်
ရိုက်ထုတ်ချင်တဲ့အခါမှာ cat command နဲ့ တကွ -T, -E option တွေကို
အသုံးပြုပါတယ်။

-T က tab ကီးကိုမြင်ရဖို့၊ -E က စာကြောင်းအဆုံးသင်္ကေတကို
မြင်ရဖို့သုံးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}31}]:} cat \PYZhy{}TE ./item\PYZhy{}list
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
No\^{}IItem\^{}IStock\$
1\^{}Ipencil\^{}I10\$
2\^{}Iruler\^{}I1000\$
3\^{}Ieraser\^{}I42\$

    \end{Verbatim}

    အထက်ပါ output မှာမြင်ရတဲ့အတိုင်း၊ \^{}I ဆိုတာက tab ကီးကို
ကိုယ်စားပြုပါတယ်။ \$ စာလုံးက စာကြောင်းအဆုံးကို ကိုယ်စားပြုပါတယ်။
ဒီသင်္ကေတတွေကို မျက်လုံးနဲ့ ဖိုင်တွေကိုစစ်ကြည့်ဖို့ တင်မကပဲ၊ ပရိုဂရမ်နဲ့
ဖိုင်ကိုဖတ်ပြီး စစ်ဆေးကြည့်တဲ့ အခါမှာလည်း အသုံးပြုပါတယ်။

    \subsection{5. file (determine file
type)}\label{file-determine-file-type}

ဖိုင်တဖိုင်က ဘာဖိုင်လဲ၊ ဘယ်လို ဖိုင်အမျိုးအစားလဲ ဆိုတာကို သိချင်ရင် file
ဆိုတဲ့ command ကိုသုံးတယ်။\\
ဖိုင်ရဲ့ အမျိုးအစားဆိုတာက စာသားတွေအနေနဲ့ သိမ်းထားတဲ့ text file လား၊
အလုပ်လုပ်ခိုင်းလို့ရတဲ့ (အင်္ဂလိပ်လိုပြောရင် run/executable
လုပ်လို့ရတဲ့) ပရိုဂရမ်ဖိုင်လား၊ ပရိုဂရမ်ဖိုင်ဆိုရင် အဲဒီပရိုဂရမ်ရဲ့
ဗားရှင်းနဲ့ ပတ်သက်တဲ့ အချက်အလက် စတာတွေကို file command ကိုသုံးပြီး
ရယူနိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}32}]:} file fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
fileA: ASCII text

    \end{Verbatim}

    fileA က ASCII (American Standard Code for Information Interchange) text
ဖိုင် အမျိုးအစားဖြစ်ကြောင်းကို သိရပါတယ်။\\
လက်ရှိကွန်ပြူတာမှာ ရှိတဲ့ ဖိုင်တချို့ကို သုံးပြီး file command ရဲ့
output တချို့ကို ဥပမာ အနေနဲ့ ပြပါမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}33}]:} file /bin/cat
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/bin/cat: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=2267d831560007f67fa4388d830192fd89861061, stripped

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} file /etc/hostname
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/etc/hostname: ASCII text

    \end{Verbatim}

    ဖိုလ်ဒါရဲ့ path ကိုပေးရင် file command က ဖိုလ်ဒါဖြစ်ကြောင်းကို directory
ဆိုပြီး အောက်ပါအတိုင်း ဖော်ပြပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} file /home/
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/: directory

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} file otest
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
otest: UTF-8 Unicode text, with very long lines

    \end{Verbatim}

    \subsection{6. head (output the first part of
files)}\label{head-output-the-first-part-of-files}

ဖိုင်တဖိုင်ထဲမှာရှိတဲ့ စာကြောင်းတွေကို ထိပ်ဆုံးအပိုင်းကနေ
ရိုက်ထုတ်ပြပေးဖို့ သုံးတဲ့ command ဖြစ်ပါတယ်။\\
ဥပမာ otest ဖိုင်ရဲ့ ထိပ်ဆုံး စာကြောင်း ၁၀ကြောင်းကို ရိုက်ပြခိုင်းချင်ရင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}37}]:} head otest
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
အနောက်တိုင်း/n ဒဿနိကဗေဒ/n မူ/conj သေးလီး/n ဆို/v သော/part ဂရိ/n ပညာရှိ/n ကြီး/part မှ/ppm စတင်/v ပေါက်ပွား/v လာ/part လေ/part သည်/ppm ။/punc
အများအားဖြင့်/adv သို့မဟုတ်/conj အားလုံး/pron မ/part\_neg ဟုတ်/v သော/part စစ်/n အစိုးရ/n ၏/ppm အဖွဲ့ဝင်/n အများစု/pron သည်/ppm ဖျက်သိမ်း/v လိုက်/part သည့်/part နဝတ/abb အဖွဲ့/n ထဲ/ppm မှ/ppm အဖွဲ့ဝင်/n များ/part ပင်/part ဖြစ်/v သည်/ppm ။/punc
အမျိုးသား/n ဒီမိုကရေစီ/n အဖွဲ့ချုပ်/n မှ/ppm အနိုင်/n ရရှိ/v ကြောင်း/part နိုင်ငံတော်/n ငြိမ်ပိ/abb က/ppm ကြေညာ/v သော်လည်း/conj အာဏာ/n လွှဲပြောင်းရေး/n နှင့်/ppm ပတ်သက်/v ၍/conj တိတိကျကျ/adv မ/part\_neg ကြေညာ/v သေး/part ပေ/part ။/punc
အယ်လဖာ/n ရောင်ခြည်/n ကို/ppm တစ်ခါတစ်ရံ/adv အယ်လဖာ/n မြူမှုန်/n ဟူ၍/part လည်း/part ခေါ်/v တတ်/part ကြ/part သည်/ppm ။/punc
အဝတ်အစား/n နဲ့/ppm ပတ်သက်/v ပြီး/conj အမြင်ရှိ/v တယ်/ppm နော်/part ။/punc
အိတ်/n တွေ/part ခဏ/n ထား/v လို့/part ရ/v တဲ့/part ရုံးခန်း/n က/ppm ဘယ်/adj နေရာ/n မှာ/ppm လဲ/part ။/punc
အောက်စဖို့ဒ်/n အင်္ဂလိပ်/n သတ်ပုံ/n ရေးထုံး/n တွင်/ppm '/punc အာရ်/sb '/punc သည်/ppm ဗျည်း/n သံရှည်/n ကို/ppm ညွှန်း/v ခြင်း/part ဖြစ်/v သည်/ppm ။/punc
အဲဒါ/pron ကို/ppm လမ်းပြ/n မြေပုံ/n ကို/ppm ပြ/v ပြီး/conj သင်ပေး/v ပါ/part ။/punc
အဲဒီ/pron ခလုတ်/n ကို/ppm နှိပ်/v လိုက်/part ရုံ/part ဘဲ/part ။/punc
ဣတိတသ္မာ/n ၊/punc ထို့ကြောင့်/conj နိက္ခမနီယော/n ၊/punc နိက္ခမနီယ/n မည်/ppm ၏/ppm ။/punc

    \end{Verbatim}

    ဒီ otest ဖိုင်က မြန်မာစာ POS Tagging သုတေသန experiment လုပ်နေစဉ်မှာ၊
ကျွန်တော်ရဲ့ တပည့်တယောက်ဖြစ်တဲ့ မဝါဝါက ပြင်ဆင်ထားတဲ့ test ဖိုင်တဖိုင်ပါ။

head command က ဘာ option မှမပေးရင် ရိုက်ခိုင်းတဲ့ ဖိုင်ရဲ့ ထိပ်ဆုံးကနေ
၁၀ ကြောင်းကို ရိုက်ပြပါတယ်။\\
တကယ်လို့ သတ်မှတ်ထားတဲ့ စာကြောင်းရေအရေအတွက်ကိုပဲ ဥပမာ ၁ ကြောင်း၊ ၃
ကြောင်း၊ အကြောင်း ၁၀၀ စသည်ဖြင့် ရိုက်ပြပေးစေချင် ရင် -n option ကို
သုံးပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}38}]:} head \PYZhy{}n \PY{l+m}{3} otest
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
အနောက်တိုင်း/n ဒဿနိကဗေဒ/n မူ/conj သေးလီး/n ဆို/v သော/part ဂရိ/n ပညာရှိ/n ကြီး/part မှ/ppm စတင်/v ပေါက်ပွား/v လာ/part လေ/part သည်/ppm ။/punc
အများအားဖြင့်/adv သို့မဟုတ်/conj အားလုံး/pron မ/part\_neg ဟုတ်/v သော/part စစ်/n အစိုးရ/n ၏/ppm အဖွဲ့ဝင်/n အများစု/pron သည်/ppm ဖျက်သိမ်း/v လိုက်/part သည့်/part နဝတ/abb အဖွဲ့/n ထဲ/ppm မှ/ppm အဖွဲ့ဝင်/n များ/part ပင်/part ဖြစ်/v သည်/ppm ။/punc
အမျိုးသား/n ဒီမိုကရေစီ/n အဖွဲ့ချုပ်/n မှ/ppm အနိုင်/n ရရှိ/v ကြောင်း/part နိုင်ငံတော်/n ငြိမ်ပိ/abb က/ppm ကြေညာ/v သော်လည်း/conj အာဏာ/n လွှဲပြောင်းရေး/n နှင့်/ppm ပတ်သက်/v ၍/conj တိတိကျကျ/adv မ/part\_neg ကြေညာ/v သေး/part ပေ/part ။/punc

    \end{Verbatim}

    -n လို့ မရိုက်ပဲ "-" တခုတည်းလို သုံးပြီး၊ "-" အနောက်ကနေ ရိုက်ပြစေချင်တဲ့
စာကြောင်းရေအရေအတွက်နံပါတ်ကို ပေးပြီးလဲ သုံးနိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}39}]:} head \PYZhy{}1 otest
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
အနောက်တိုင်း/n ဒဿနိကဗေဒ/n မူ/conj သေးလီး/n ဆို/v သော/part ဂရိ/n ပညာရှိ/n ကြီး/part မှ/ppm စတင်/v ပေါက်ပွား/v လာ/part လေ/part သည်/ppm ။/punc

    \end{Verbatim}

    \subsection{7. tail (output the last part of
files)}\label{tail-output-the-last-part-of-files}

tail command က အထက်မှာ ရှင်းပြခဲ့တဲ့ head command နဲ့ ပြောင်းပြန်ပါ။\\
ဖိုင်တဖိုင်ကို နောက်ဆုံး အပိုင်းကနေ အကြောင်းရေ အရေအတွက်နဲ့
ရိုက်ပြခိုင်းလို့ ရတဲ့ command ပါ။

အကြောင်းအရေအတွက်ကို ဘာမှ မကန့်သတ်ပဲ run ရင် default အနေနဲ့
ဖိုင်ရဲ့နောက်ဆုံး ၁၀ ကြောင်းကို ရိုက်ပြပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}40}]:} tail \PYZti{}/linux\PYZhy{}cmd/otest.tag
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
conj n v part ppm num n ppm n num n conj num n ppm v n part ppm n ppm n v n part v ppm v v part part conj v v n ppm num n ppm v part part ppm punc
n ppm n n n ppm tn n part n n n num n part v conj n n conj n n n ppm tn n part n n num part v ppm punc
num n ppm n v n v part n conj n n ppm part punc n n ppm n n ppm v part conj punc n ppm part v conj punc v n n part adv v part part n part v part ppm punc
num pron v conj n ppm ppm v ppm punc
num n n n ppm n ppm v part part n n ppm n n part ppm n n n part ppm n n n v n n n ppm v v part ppm punc
num ppm pron ppm n n n n n n ppm fw ppm v conj n ppm v part conj v part part part ppm punc
num n n part ppm n n ppm fw part v adj part part ppm punc
num n part punc
pron ppm ppm v n part adj n n part ppm adv v part ppm punc
punc n punc n punc n punc n part pron part adv v ppm ppm v part part conj n part ppm v part ppm punc

    \end{Verbatim}

    အကြောင်းအရေအတွက်ကို -n option နဲ့ ကန့်သတ်ပေးလို့ရပါတယ်။\\
ဥပမာ ဖိုင်ရဲ့ နောက်ဆုံးစာကြောင်း တစ်ကြောင်းကို ပဲ ရိုက်ပေးစေချင်ရင်
အောက်ပါအတိုင်း -n 1 ဆိုပြီး option ပေးပြီး run ခိုင်းလို့ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} tail \PYZhy{}n \PY{l+m}{1} \PYZti{}/linux\PYZhy{}cmd/otest.tag
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
punc n punc n punc n punc n part pron part adv v ppm ppm v part part conj n part ppm v part ppm punc

    \end{Verbatim}

    head command မှာတုန်းကပြခဲ့သလိုပါပဲ။ -n option မထည့်ပဲ
စာကြောင်းအရေအတွက်ကိုပဲ ပြောပြီး အောက်ပါအတိုင်း run လို့လည်း ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}42}]:} tail \PYZhy{}1 \PYZti{}/linux\PYZhy{}cmd/otest.tag
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
punc n punc n punc n punc n part pron part adv v ppm ppm v part part conj n part ppm v part ppm punc

    \end{Verbatim}

    \subsection{8. cp (copy files and
directories)}\label{cp-copy-files-and-directories}

ဖိုင်တွေ၊ ဖိုလ်ဒါတွေကို ကော်ပီကူးဖို့ အတွက် သုံးတဲ့ command ပါ။\\
fileA ကို လက်ရှိဖိုလ်ဒါအောက်မှာပဲ fileZ အဖြစ် ကော်ပီကူးမယ်ဆိုရင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}43}]:} cp fileA fileZ
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}44}]:} ls fileA fileZ \PYZhy{}la
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
-rw-rw-r-- 1 lar lar 67  8月 11 17:48 fileA
-rw-rw-r-- 1 lar lar 67  8月 11 18:04 fileZ

    \end{Verbatim}

    ဖိုင်နာမည်တွေကို ပေးရင်းနဲ့ ဘယ် ဖိုလ်ဒါ(path) ရဲ့အောက်က ဖိုင် ကို ဘယ်
ဖိုလ်ဒါအောက် ကို ကေပီကူးပေးပါ ဆိုပြီး ဖိုလ်ဒါတွေရဲ့ လမ်းကြောင်းတွေကို
အတိအကျ ညွှန်ကြားပြီးလဲ ခိုင်းနိုင်ပါတယ်။ ဥပမာ အနေနဲ့
\textasciitilde{}/paper/pacling2017/anm/ ဖိုလ်ဒါအောက်မှရှိတဲ့
anmpacling-updated.pdf ဖိုင်ကို လက်ရှိ ./ (ဖိုလ်ဒါအောက် ကို)
ကော်ပီကူးပေးပါ ဆိုပြီး အောက်ပါအတိုင်း command ပေးနိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}45}]:} cp \PYZti{}/bk\PYZhy{}dlbox/tool4all/127\PYZhy{}135.pdf ./folderA/
\end{Verbatim}

    မှတ်ချက်။ ။ Linux OS မှာ ./ ဆိုတာက လက်ရှိရောက်နေတဲ့ ဖိုလ်ဒါpath ကို
ညွှန်ပြီး၊ ../ ဆိုတာက လက်ရှိရှိနေတဲ့ ဖိုလ်ဒါpath ရဲ့ အထက် တဆင့်ကို
ညွှန်းပါတယ်။ လက်ရှိ ဖိုလ်ဒါကိုကူးတဲ့ အခါမှာ ./ ဆိုတာကို ပြောမနေတော့ပဲ
ကိုယ်ကော်ပီကူးပြီး သိမ်းချင်တဲ့ ဖိုင်နာမည်ကိုပဲ တန်းပြောလို့ဖြစ်ပါတယ်။

ဖိုလ်ဒါကို ကော်ပီကူးမယ် ဆိုရင် cp command ကို -r option နဲ့ တွဲသုံးရမယ်။

ဥပမာ folderA/ ကို ကော်ပီကူးမယ် ဆိုရင် folderA-Copy/ အဖြစ်နဲ့
ကော်ပီကူးမယ် ဆိုရင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}46}]:} cp \PYZhy{}r ./folderA ./folderA\PYZhy{}Copy
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}47}]:} ls \PYZhy{}p
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
all-vi-info.txt  echo      \textcolor{ansi-blue-intense}{\textbf{folderA-Copy}}/             ls.out     otest.word
\textcolor{ansi-blue-intense}{\textbf{data1}}/           fileA     \textcolor{ansi-blue-intense}{\textbf{folder-athit}}/             my-news    \textcolor{ansi-blue-intense}{\textbf{screen}}/
\textcolor{ansi-blue-intense}{\textbf{data2}}/           fileB     \textcolor{ansi-blue-intense}{\textbf{folder-new}}/               newfile    sorted-names
\textcolor{ansi-blue-intense}{\textbf{data3}}/           fileZ     item-list                 news       \textcolor{ansi-blue-intense}{\textbf{wildcard}}/
\textcolor{ansi-blue-intense}{\textbf{data4}}/           fmt.out   linux-commands.ipynb      otest
\textcolor{ansi-blue-intense}{\textbf{data5}}/           \textcolor{ansi-blue-intense}{\textbf{folderA}}/  linux-commands.ipynb.bak  otest.tag

    \end{Verbatim}

    ဒီနေရာမှာ ls command ရဲ့ -p option က ဖိုလ်ဒါတွေကို indicator "/" နဲ့
တွဲပြခိုင်းတာပါ။ ဖိုင်နဲ့ ဖိုလ်ဒါကို ကွဲကွဲပြားပြားမြင်ရအောင်လုပ်တဲ့
option ပါ။ အထူးသဖြင့်တော့ ကာလာနဲ့ မပြအောင် setting လုပ်ထားတဲ့ terminal
တွေမှာသုံးလေ့ရှိပါတယ်။

    \subsection{9. mv (move or rename file)}\label{mv-move-or-rename-file}

ဖိုင်တွေ ဖိုလ်ဒါတွေကို နာမည်ပြောင်းဖို့ အတွက် (သို့) နေရာတခုကနေ
တခြားနေရာတခုကို ပြောင်းရွှေ့ဖို့ ဆိုရင် mv command ကိုသုံးပါတယ်။\\
ဥပမာ fileZ ကို fileY အဖြစ် နာမည်ပြောင်း ချင်ရင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}48}]:} ls file*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
fileA  fileB  fileZ

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}49}]:} mv fileZ fileY
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}50}]:} ls file*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
fileA  fileB  fileY

    \end{Verbatim}

    နဂိုက ရှိနေတဲ့ fileZ က fileY အဖြစ်ပြောင်းသွားတာကို ls command နဲ့
confirm လုပ်ကြည့်ရင်တွေ့ရလိမ့်မယ်။\\
mv command နဲ့ တွဲသုံးတဲ့ -f option ကိုလဲ သိထားသင့်တယ်။\\
-f option ကိုပါတွဲသုံးရင် နာမည်ပြောင်းတာတို့ ရွှေ့တာတို့လုပ်တဲ့ အခါမှာ
တကယ်လို့ အရင်ရှိနေတဲ့ နာမည်တူ ဖိုင်၊ ဖိုလ်ဒါကို overwrite လုပ်ဖို့
လိုအပ်လာတဲ့ အခါမှာ ဘာမှ confirm လုပ်တာ၊ မေးတာ မလုပ်ပဲ
ပြောင်းချသွားပေးလိမ့်မယ်။ တနည်းအားဖြင့်ပြောရရင် အရင်ဖိုင်ရှိနေတာ
ငါသိပြီးသား၊ လုပ်သာလုပ်ဆိုပြီး by force နဲ့ mv လုပ်ခိုင်းတာ။\\
ဥပမာ အနေနဲ့၊ ပရိုဂရမ်ထဲကနေ mv လုပ်ခိုင်းတာမျိုးမှာ
အရင်ရှိပြီးသားဖိုင်တွေနဲ့ ပတ်သက်ပြီး တွေ့လာတိုင်း ဖြေနေစရာ မလိုအောင်လို့
-f option ကို သုံးတယ်။ မသုံးခင်မှာ သေသေချာချာ စဉ်းစားပါ။

\subsection{10. rm (remove files or
directories)}\label{rm-remove-files-or-directories}

ဖိုင်တွေ၊ ဖိုလ်ဒါတွေကို ဖျက်ဖို့အတွက် သုံးတဲ့ command ပါ။\\
ဥပမာ fileY ကို ဖျက်မယ်ဆိုရင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}51}]:} rm fileY
\end{Verbatim}

    ဖျက်ပြီး သွားပြီလား ဆိုတာကို ls command နဲ့ confirm လုပ်ကြည့်တဲ့ အခါမှာ၊
ဖျက်ပြီးသွားကြောင်း၊ fileY က မရှိတော့ကြောင်း တွေ့ရပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}52}]:} ls file*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
fileA  fileB

    \end{Verbatim}

    ဖိုလ်ဒါကို ဖျက်မယ်ဆိုရင် rm command ကို -r option နဲ့ တွဲသုံးတယ်။\\
အရင်ဆုံး လက်ရှိရောက်နေတဲ့ ဖိုလ်ဒါအောက်မှာ ဘာဖိုင်တွေ၊ ဘာဖိုလ်ဒါတွေ
ရှိသလဲ ls command နဲ့ ရိုက်ပြခိုင်းမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}53}]:} ls \PYZhy{}p
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
all-vi-info.txt  fileA          item-list                 otest
\textcolor{ansi-blue-intense}{\textbf{data1}}/           fileB          linux-commands.ipynb      otest.tag
\textcolor{ansi-blue-intense}{\textbf{data2}}/           fmt.out        linux-commands.ipynb.bak  otest.word
\textcolor{ansi-blue-intense}{\textbf{data3}}/           \textcolor{ansi-blue-intense}{\textbf{folderA}}/       ls.out                    \textcolor{ansi-blue-intense}{\textbf{screen}}/
\textcolor{ansi-blue-intense}{\textbf{data4}}/           \textcolor{ansi-blue-intense}{\textbf{folderA-Copy}}/  my-news                   sorted-names
\textcolor{ansi-blue-intense}{\textbf{data5}}/           \textcolor{ansi-blue-intense}{\textbf{folder-athit}}/  newfile                   \textcolor{ansi-blue-intense}{\textbf{wildcard}}/
echo             \textcolor{ansi-blue-intense}{\textbf{folder-new}}/    news

    \end{Verbatim}

    စောစောက ကော်ပီကူးထားခဲ့တဲ့ folderA-Copy ဆိုတာကို -r option မသုံးပဲ
ဖျက်ကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}54}]:} rm folderA\PYZhy{}Copy
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
rm: cannot remove 'folderA-Copy': Is a directory

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    directory (သို့) ဖိုလ်ဒါ ဖြစ်နေလို့ rm command က ဖျက်လို့ မရကြောင်း
error message ပေးပါလိမ့်မယ်။\\
-r option ကို သုံးပြီး ဖျက်ကြည့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}55}]:} rm \PYZhy{}r folderA\PYZhy{}Copy
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}56}]:} ls \PYZhy{}p
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
all-vi-info.txt  fileA          linux-commands.ipynb      otest.tag
\textcolor{ansi-blue-intense}{\textbf{data1}}/           fileB          linux-commands.ipynb.bak  otest.word
\textcolor{ansi-blue-intense}{\textbf{data2}}/           fmt.out        ls.out                    \textcolor{ansi-blue-intense}{\textbf{screen}}/
\textcolor{ansi-blue-intense}{\textbf{data3}}/           \textcolor{ansi-blue-intense}{\textbf{folderA}}/       my-news                   sorted-names
\textcolor{ansi-blue-intense}{\textbf{data4}}/           \textcolor{ansi-blue-intense}{\textbf{folder-athit}}/  newfile                   \textcolor{ansi-blue-intense}{\textbf{wildcard}}/
\textcolor{ansi-blue-intense}{\textbf{data5}}/           \textcolor{ansi-blue-intense}{\textbf{folder-new}}/    news
echo             item-list      otest

    \end{Verbatim}

    folderA-Copy/ ကပျက်သွား တာကို တွေ့ရမယ်။\\
\textbf{rm command က အရမ်း အန္တရာယ်ရှိတဲ့ command တခု ဖြစ်ပါတယ်။}\\
\textbf{နောက် Linux OS commandline မှာ မှားဖျက်လိုက်မိတဲ့ ဖိုင်ကို
ပြန်ရဖို့ဆိုတာမျိုး မမျှော်လင့်ပါနဲ့။}\\
\textbf{သတိထားပြီး သုံးပါ။}

\subsection{11. alias (create simple names or
abbreviations)}\label{alias-create-simple-names-or-abbreviations}

အသုံးများသော command တွေကို ကိုယ်လိုချင်တဲ့ option တွေနဲ့ setting
လုပ်ထားပြီး command နာမည်အသစ်အနေနဲ့ သိမ်းပေးနိုင်။

ဥပမာ ls -la (-l က long listing format, -a က all ဆိုတဲ့ option ဖွက်ထားတဲ့
ဖိုင်တွေလဲပြ) command ကို ll ဆိုတဲ့ နာမည်နဲ့ alias လုပ်ထား လို့ရတယ်။
အောက်ပါ အတိုင်း alias လုပ်ကြည့်ပြီး ll command ကို run ကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{n+nb}{alias} \PY{n+nv}{ll}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}ls \PYZhy{}la\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}58}]:} ll
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
total 1284
drwxrwxr-x 13 lar lar   4096  8月 11 18:05 \textcolor{ansi-blue-intense}{\textbf{.}}
drwxr-xr-x 42 lar lar   4096  8月 11 13:29 \textcolor{ansi-blue-intense}{\textbf{..}}
-rw-rw-r--  1 lar lar  16937  8月 11 11:14 all-vi-info.txt
drwxrwxr-x  2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data1}}
drwxrwxr-x  2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data2}}
drwxrwxr-x  2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data3}}
drwxrwxr-x  2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data4}}
drwxrwxr-x  2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{data5}}
-rw-rw-r--  1 lar lar      0  8月 11 11:14 echo
-rw-rw-r--  1 lar lar     67  8月 11 17:48 fileA
-rw-rw-r--  1 lar lar     61  8月 11 11:14 fileB
-rw-rw-r--  1 lar lar      0  8月 11 11:14 .fileC
-rw-rw-r--  1 lar lar   3117  8月 11 11:14 fmt.out
drwxrwxr-x  2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folderA}}
drwxrwxr-x  2 lar lar   4096  8月 11 18:04 \textcolor{ansi-blue-intense}{\textbf{folder-athit}}
drwxrwxr-x  2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{folder-new}}
drwxr-xr-x  2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{.ipynb\_checkpoints}}
-rw-rw-r--  1 lar lar     51  8月 11 18:04 item-list
-rw-rw-r--  1 lar lar 237013  8月 11 18:02 linux-commands.ipynb
-rw-rw-r--  1 lar lar 202186  8月 11 11:14 linux-commands.ipynb.bak
-rw-rw-r--  1 lar lar    177  8月 11 11:14 ls.out
-rw-rw-r--  1 lar lar   3117  8月 11 11:14 my-news
-rw-rw-r--  1 lar lar      0  2月  3  2015 newfile
-rw-rw-r--  1 lar lar   4246  8月 11 11:14 news
-rw-r--r--  1 lar lar 377269  8月 11 11:14 otest
-rw-r--r--  1 lar lar  73420  8月 11 11:14 otest.tag
-rw-r--r--  1 lar lar 303849  8月 11 11:14 otest.word
drwxrwxr-x  2 lar lar   4096  8月 11 18:01 \textcolor{ansi-blue-intense}{\textbf{screen}}
-rw-rw-r--  1 lar lar     68  8月 11 11:14 sorted-names
drwxrwxr-x  2 lar lar   4096  8月 11 11:14 \textcolor{ansi-blue-intense}{\textbf{wildcard}}

    \end{Verbatim}

    cd .., cd .., cd .. ကို သုံးခါရိုက်ပြီး လက်ရှိpath ကနေ
အထက်သုံးဆင့်တက်တဲ့ ကိစ္စက နေ့စဉ်လိုလို သုံးရလို့ အောက်ပါအတိုင်း alias
လုပ်ထားတော့ အဆင်ပြေတာပေါ့။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}59}]:} \PY{n+nb}{alias} ...\PY{o}{=}\PY{l+s+s1}{\PYZsq{}cd ../../\PYZsq{}}
\end{Verbatim}

    setting လုပ်ထားတဲ့ alias ကို သုံးပြဖို့အတွက်၊ လက်ရှိ ရောက်ရှိနေတဲ့path
ကနေ /usr/share/calendar/အောက်ကို အရင်ရွှေ့မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}60}]:} \PY{n+nb}{cd} /usr/share/calendar/
\end{Verbatim}

    မြင်သာအောင်၊ လက်ရှိရောက်နေတဲ့ path ကို pwd command နဲ့ print
ထုတ်ခိုင်းမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}61}]:} \PY{n+nb}{pwd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/usr/share/calendar

    \end{Verbatim}

    ... command ကိုသုံးပြီး အထက် ၃ဆင့်မှာရှိတဲ့ folderကို ရွှေ့မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}62}]:} ...
\end{Verbatim}

    pwd command ရိုက်ကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}63}]:} \PY{n+nb}{pwd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/usr

    \end{Verbatim}

    လက်ရှိ ဘယ်လို alias တွေရှိသလဲ ဆိုတာကို သိချင်ရင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}64}]:} \PY{n+nb}{alias}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
alias {\ldots}='cd ../../'
alias alert='notify-send --urgency=low -i "\$([ \$? = 0 ] \&\& echo terminal || echo error)" "\$(history|tail -n1|sed -e '\textbackslash{}''s/\^{}\textbackslash{}s*[0-9]\textbackslash{}+\textbackslash{}s*//;s/[;\&|]\textbackslash{}s*alert\$//'\textbackslash{}'')"'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l='ls -CF'
alias la='ls -A'
alias ll='ls -la'
alias ls='ls --color=auto'

    \end{Verbatim}

    \subsection{12. touch (change file
timestamps)}\label{touch-change-file-timestamps}

    touch command က ဖိုင် တဖိုင်ရဲ့ timestamps (ဖိုင်ကို စဆောက် တဲ့အချိန်၊
ရေးတဲ့ အချိန်၊ ဖတ်တဲ့ အချိန်) တွေကို ပြင်တဲ့အခါသုံးလေ့ရှိတယ်။

ဥပမာ fileA ရဲ့ နောက်ဆုံး ပြင်ဆင်ခဲ့တဲ့ အချိန်ကို ls command ကို -l
option ပေးပြီး ကြည့်နိုင်တယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}65}]:} \PY{n+nb}{cd} \PYZti{}/linux\PYZhy{}cmd/
         ls \PYZhy{}l fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
-rw-rw-r-- 1 lar lar 67  8月 11 17:48 fileA

    \end{Verbatim}

    touch fileA နဲ့ fileA ရဲ့ timestamps ကို လက်ရှိအချိန်နဲ့ ပြင်မယ်။\\
ပြီးရင် ls -l fileA နဲ့ fileA ရဲ့ timestamps ကို ပြန်စစ်ကြည့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}66}]:} touch fileA
         ls \PYZhy{}l fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
-rw-rw-r-- 1 lar lar 67  8月 11 18:05 fileA

    \end{Verbatim}

    "月" ဆိုတဲ့ စာလုံးက ဂျပန်စာမှာ လ ကိုပြောတာပါ။ ဥပမာ ၆လပိုင်းဆိုရင် "6月"
ရေးပါတယ်။\\
နဂိုရှိနေတဲ့ fileA ရဲ့ လ၊ ရက် နဲ့ အချိန်တွေ ပြောင်းလဲသွားတာကို
တွေ့ရပါလိမ့်မယ်။

Linux OS တွေမှာ POSIX standard သတ်မှတ်ချက်အရ၊ ဖိုင်တဖိုင်ရဲ့ ဒေတာတွေကို
နောက်ဆုံး ဖတ်တဲ့အချိန် (last data access timestamp)၊ နောက်ဆုံး
ဒေတာတွေကို ပြင်ဆင်ခဲ့တဲ့ အချိန် (last data modification timestamp) နဲ့
နောက်ဆုံး ဖိုင်ရဲ့ status တွေကို ပြင်ခဲ့တဲ့ အချိန် (last file status
change timestamp) ဆိုပြီး ၃မျိုးရှိပါတယ်။ အတိုကောက်အနေနဲ့ last data
access timestamp ကို atime၊ last data modification timestamp ကို mtime၊
last file status change timestamp ကို ctime ဆိုပြီးလဲခေါ်ကြပါတယ်။
ဖိုင်တဖိုင်ရဲ့ အဲဒီအချိန်တွေကို အသေးစိတ်သိချင်ရင် stat command ကို
သုံးပြီးကြည့်နိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}67}]:} stat fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
  File: 'fileA'
  Size: 67        	Blocks: 8          IO Block: 4096   regular file
Device: 802h/2050d	Inode: 677359      Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/     lar)   Gid: ( 1000/     lar)
Access: 2017-08-11 18:05:21.191648212 +0900
Modify: 2017-08-11 18:05:21.191648212 +0900
Change: 2017-08-11 18:05:21.191648212 +0900
 Birth: -

    \end{Verbatim}

    touch command ရဲ့ -t option ကိုသုံးပြီး ဖိုင်ရဲ့ timestampကို
ကိုယ်လိုချင်တဲ့ အချိန်အဖြစ် ပြောင်းခိုင်းလို့ရပါတယ်။ ဖိုင်အသစ်တခုကိုလည်း
ကိုယ်လိုချင်တဲ့ timestampနဲ့ ပေးပြီး ဆောက်ခိုင်းလို့ရပါတယ်။ ဥပမာ
ဖိုင်အသစ်တဖိုင်ကို -t 201502032030.10 option ပေးပြီး touch
လုပ်ကြည့်ရအောင်။ ဒီနေရာမှာ အချိန်ကိုပေးရတဲ့ format က
{[}{[}CC{]}YY{]}MMDDhhmm{[}.ss{]} ဆိုတဲ့ ပုံစံနဲ့ပါ။ ဒီနေရာမှာ CC ဆိုတာက
ခုနှစ်တခုရဲ့ ပထမဆုံးစာလုံး၂လုံးကို ဆိုလိုပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}68}]:} touch  \PYZhy{}t \PY{l+m}{201502032030}.10 newfile
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}69}]:} stat newfile
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
  File: 'newfile'
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 802h/2050d	Inode: 677350      Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/     lar)   Gid: ( 1000/     lar)
Access: 2015-02-03 20:30:10.000000000 +0900
Modify: 2015-02-03 20:30:10.000000000 +0900
Change: 2017-08-11 18:05:23.539648142 +0900
 Birth: -

    \end{Verbatim}

    ကျွန်တော် အများဆုံး သုံးဖြစ်တဲ့ ပုံစံကတော့ blank file တခုကို
အသစ်လုပ်ချင်ရင် "touch filename" ဆိုပြီး ဖိုင်အသစ်တခုကို ဆောက်တဲ့
ပုံစံပါ။

    \subsection{13. diff (compare files line by
line)}\label{diff-compare-files-line-by-line}

ဖိုင်နှစ်ခုကို တူမတူ စာကြောင်းတစ်ကြောင်းချင်းစီ တိုက်စစ်ချင်တဲ့ အခါမှာ
သုံးပါတယ်။

    အရင်ဆုံး fileA ထဲမှာ ဘာတွေရှိသလဲ ဆိုတာကို cat command နဲ့
ရိုက်ကြည့်မယ်။\\
-n option ပေးပြီးတော့ လိုင်းနံပါတ်ပါထိုးခိုင်းပါမယ်။
အောက်ပါအတိုင်းမြင်ရပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}70}]:} cat \PYZhy{}n fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
     1	Mingalar bar!
     2	I am fileA.
     3	I was born in April.
     4	My blood type is O.

    \end{Verbatim}

    ပြီးတော့ fileB ထဲမှာ ဘာတွေရှိသလဲ ဆိုတာကိုလည်း cat command နဲ့
ရိုက်ကြည့်မယ်။\\
fileB မှာက ငါးကြောင်းမြောက်မှာ ဘာစာလုံးမှမရှိတဲ့ စာကြောင်းတစ်ကြောင်း
ရှိနေကြောင်း တွေ့ရပါလိမ့်မယ်။\\
ဘာစာမှ မရိုက်ပဲ enter ကီးကို ခေါက်ထားတဲ့ အခါမျိုးမှာ ဒီလိုမျိုး
ရှိနေတတ်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}71}]:} cat \PYZhy{}n fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
     1	Hi!
     2	I am fileB.
     3	I was born in November.
     4	My blood type is O.
     5	

    \end{Verbatim}

    အထက်ပါ fileA နဲ့ fileB နှစ်ဖိုင်ကို diff command ကို သုံးပြီး
နှိုင်းယှဉ်ကြည့်ရင် အောက်ပါအတိုင်း မြင်ရပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}72}]:} diff fileA fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
1,3c1,3
< Mingalar bar!
< I am fileA.
< I was born in April.
---
> Hi!
> I am fileB.
> I was born in November.
4a5
> 

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    "\textless{}" နဲ့ ပြတာက fileA က စာကြောင်း၊ "\textgreater{}" နဲ့ ပြတာက
fileB က မတူတဲ့ စာကြောင်းတွေ ပါ။\\
diff command က command parameter အနေနဲ့ ပထမဆုံးပေးတဲ့ ဖိုင် fileA ကို
ဒုတိယ command parameter ဖြစ်တဲ့ fileB နဲ့တူဖို့အတွက် ဘယ်စာကြောင်းတွေကို
ပြင်ရမလဲ ဆိုတဲ့ ပုံစံမျိုးနဲ့ ပြပေးပါတယ်။\\
အသေးစိတ် ရှင်းပြရရင်၊ output လုပ်ပေးတဲ့ ပထမဆုံးစာကြောင်း "1,3c1,3" မှာ
ပထမ 1,3 ဆိုတာက fileA ရဲ့ စာကြောင်းနံပါတ် 1 ကနေ စာကြောင်းနံပါတ် 3 အထိ ကို
"c" (change) ပြင်ရမယ်။ ဒုတိယပြတဲ့ 1,3 က fileB ရဲ့ စာကြောင်းနံပါတ် 1 ကနေ
စာကြောင်းနံပါတ် 3 နဲ့တူဖို့အတွက်လို ဆိုလိုတာပါ။\\
"-\/-\/-" က fileA နဲ့ fileB ကို ခွဲခြားပေးထားတဲ့ လိုင်းပါ။\\
နောက်ဆုံး ပြတဲ့ 4a5 ဆိုတာက ပထမဆုံးဖိုင်က လေးကြောင်းမြောက်နေရာမှာ a (add)
စာကြောင်းသစ်အနေနဲ့ ထည့်ရမယ်၊ ဒုတိယဖိုင် fileB က စာကြောင်းနံပါတ် ၅
ကိုလို့ ဆိုလိုပါတယ်။ ဒီနေရာမှာ fileB ရဲ့စာကြောင်း နံပါတ်၅က
ဘာမှမရှိဘူးလို့မြင်နေရတဲ့ (Enter တခုပိုခေါက်ထားမိတဲ့) စာကြောင်းပါ။

မှတ်ချက်။ ။ a, b, c ဆိုပြီး ဘယ်လို editing လုပ်ရမယ်ဆိုတာကို
အတိုကောက်ပြပြီး အချက်အလက်အနေနဲ့ ဖော်ပြပါတယ်။\\
ဒီနေရာမှာ a for add၊ c for change၊ d for delete ဆိုပြီး မှတ်သားထားပါ။

diff command ကို -c option ကိုသုံးပြီး contextual mode အနေနဲ့
ပြခိုင်းလို့လဲ ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}73}]:} diff fileA fileB \PYZhy{}c
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
*** fileA	2017-08-11 18:05:21.191648212 +0900
--- fileB	2017-08-11 11:14:36.068526803 +0900
***************
*** 1,4 ****
! Mingalar bar!
! I am fileA.
! I was born in April.
  My blood type is O.
--- 1,5 ----
! Hi!
! I am fileB.
! I was born in November.
  My blood type is O.
+ 

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    အထက်မှာ မြင်ရတာက နှိုင်းယှဉ်ကြည့်နေတဲ့ ဖိုင်နာမည် ၂ခု၊ အဲဒီဖိုင်တွေကို
နောက်ဆုံး ပြင်ခဲ့တဲ့ ရက်စွဲ၊ နာရီ ကိုပြတာပါ။\\
+0900 ဆိုတာက GMT +9၊ ဂျပန် timezone ဖြစ်တဲ့ Greenwich Mean Time +9
ကိုပြောတာပါ။\\
! အမှတ်အသားက ဖိုင်နှစ်ဖိုင်ကို တူဖို့အတွက် ပြင်ဖို့လိုအပ်တဲ့
စာကြောင်းတွေကို ပြတာပါ။\\
စာကြောင်းရဲ့ ရှေ့မှာ ဘာမှမပြရင် တူလို့ပါ (အထက်ကဥပမာ အရဆိုရင် My blood
type is O. ဆိုတဲ့ စာကြောင်းပါ)။\\
+ အမှတ်အသားက နှိုင်းယှဉ်တဲ့ ဖိုင်နှစ်ဖိုင်အနက်က ဒုတိယဖိုင်မှာပဲ
ရှိတဲ့စာကြောင်းဖြစ်ပြီး၊ fileA မှာ ဝင်ဖြည့်ရမယ့် စာကြောင်းကို ပြတာပါ။

diff command ကို -u option ကိုသုံးပြီး unify mode အနေနဲ့လဲ ပြခိုင်းလို့
ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}74}]:} diff fileA fileB \PYZhy{}u
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
--- fileA	2017-08-11 18:05:21.191648212 +0900
+++ fileB	2017-08-11 11:14:36.068526803 +0900
@@ -1,4 +1,5 @@
-Mingalar bar!
-I am fileA.
-I was born in April.
+Hi!
+I am fileB.
+I was born in November.
 My blood type is O.
+

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    -u option က အကြမ်းမျဉ်းအားဖြင့်တော့ context mode နဲ့ ဆင်တူပါတယ်။\\
တူတဲ့ စာကြောင်းတွေကို နှစ်ခါမပြတာ နဲ့ ဖိုင်နှစ်ဖိုင် အနေနဲ့
သပ်သပ်စီခွဲမပြတာပဲ၊ ပေါင်းပြီး ပြတာပဲ ကွာပါတယ်။

diff command ကို -y option ကိုသုံးပြီး ဖိုင်နှစ်ဖိုင်ကို
စာကြောင်းတကြောင်းချင်းစီကို ဘေးချင်းယှဉ်ပြီး (သို့) ကော်လံ နှစ်ခု အနေနဲ့
ပြခိုင်းတာမျိုးလဲ လုပ်နိုင်ပါတယ်။\\
လူအနေက ပုံမှန်အားဖြင့် စာကြောင်းနှစ်ကြောင်းကို ဘေးချင်းစီပြီးကြည့်တာက
ပိုအဆင်ပြေမယ်လို့ ထင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}75}]:} diff fileA fileB \PYZhy{}y
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Mingalar bar!						      |	Hi!
I am fileA.						      |	I am fileB.
I was born in April.					      |	I was born in November.
My blood type is O.						My blood type is O.
							      >

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    ဒီနေရာမှာ သုံးထားတဲ့ သင်္ကေတတွေရဲ့ အဓိပ္ပါယ်တွေကတော့\\
"\textbar{}" က ဖိုင်နှစ်ဖိုင်မှာ မတူတဲ့ စာကြောင်းတွေကို ပြတာပါ။\\
"\textgreater{}" က ညာဖက်အခြမ်း (သို့) ဒုတိယဖိုင်ဖြစ်တဲ့ fileB ဘက်မှာပဲ
ရှိတဲ့ စာကြောင်းကို ပြတာပါ။\\
(ဒီနေရာမှာ မျက်လုံးနဲ့ မမြင်နိုင်တဲ့ Enter ခေါက်ထားလို့ပါ)\\
ဘာ သင်္ကေတမှ မပြရင် စာကြောင်းနှစ်ကြောင်းက တူနေလို့ပါ။\\
အထက်က ဥပမာမှာ မဆိုင်လို မပြထားပေမဲ့၊ နောက်ထပ် သင်္ကေတ တစ်ခု
ကျန်ပါသေးတယ်။ အဲဒါက "\textless{}" သင်္ကေတပါ။ "\textless{}" ကတော့
ဘယ်ဘက်အခြမ်းကဖိုင် (သို့) နှိုင်းယှဉ်ကြည့်နေတဲ့ အထဲက ပထမဖိုင်မှာပဲ
ရှိတဲ့ စာကြောင်းမျိုးအတွက် သုံးပါတယ်။

မှတ်ချက်။ ။ အထက်က ဥပမာ "diff fileA fileB -y" ကို sdiff command
ကိုသုံးပြီး "sdiff fileA fileB" ဆိုပြီးလည်း run နိုင်ပါတယ်။

diff command ကို နောက်ဆုံး ဥပမာအနေနဲ့ ဖိုင်တွေကို နှိုင်းယှဉ်ကြည်တာတင်
မကပဲ၊ ဖိုလ်ဒါ နှစ်ခုကိုလည်း နှိုင်းယှဉ်လို့ရကြောင်း ပြပါမယ်။

အရင်ဆုံး လက်ရှိ ဖိုလ်ဒါအောက်မှာက ဘာတွေရှိသလဲ ဆိုတာကို ls နဲ့ ကြည့်မယ်။\\
ပြီးရင် ဖိုလ်ဒါအသစ်တခုဆောက်ပြီး၊ ဖိုင်တချို့ကို ကူးထည့်ပါမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}76}]:} ls \PYZhy{}F
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
all-vi-info.txt  fileA          linux-commands.ipynb      otest.tag
\textcolor{ansi-blue-intense}{\textbf{data1}}/           fileB          linux-commands.ipynb.bak  otest.word
\textcolor{ansi-blue-intense}{\textbf{data2}}/           fmt.out        ls.out                    \textcolor{ansi-blue-intense}{\textbf{screen}}/
\textcolor{ansi-blue-intense}{\textbf{data3}}/           \textcolor{ansi-blue-intense}{\textbf{folderA}}/       my-news                   sorted-names
\textcolor{ansi-blue-intense}{\textbf{data4}}/           \textcolor{ansi-blue-intense}{\textbf{folder-athit}}/  newfile                   \textcolor{ansi-blue-intense}{\textbf{wildcard}}/
\textcolor{ansi-blue-intense}{\textbf{data5}}/           \textcolor{ansi-blue-intense}{\textbf{folder-new}}/    news
echo             item-list      otest

    \end{Verbatim}

    လောလောဆယ် လက်ရှိ path အောက်မှာ folderA/ ပဲရှိတယ်။\\
mkdir command နဲ့ folderB/ ကိုဆောက်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}77}]:} mkdir folderB
\end{Verbatim}

    ဆောက်ထားတဲ့ folderB/ အောက်ကို ဖိုင်တချို့ ကော်ပီကူးထည့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}78}]:} cp fileA ./folderB/
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}79}]:} cp otest ./folderB/
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}80}]:} cp ./folderA/127\PYZhy{}135.pdf ./folderB/
\end{Verbatim}

    အထက်မှာ ပြခဲ့တဲ့အတိုင်း လက်ရှိ path အောက်မှာရှိနေတဲ့ fileA ဆိုတဲ့
ဖိုင်နဲ့ otest ဆိုတဲ့ ဖိုင် ကို folderB/ အောက်ကို
ကော်ပီကူးထည့်ခဲ့ပါတယ်။\\
အဲဒီနောက်မှာ လက်ရှိ path ရဲ့အောက်က folderA/ ဖိုလ်ဒါအောက်မှာရှိတဲ့
127-135.pdf ဆိုတဲ့ ဖိုင်ကိုလည်း folderB/ အောက်ကို
ကော်ပီကူးထည့်ခဲ့ပါတယ်။\\
အဲဒါကြောင့် folderB/ အောက်မှာ ဖိုင် ၃ဖိုင် ရှိနေပါပြီ။\\
ls command နဲ့ folderB/ နဲ့ folderA/ အောက်မှာရှိတဲ့ ဖိုင်တွေကို
ကြိုကြည့်ထားရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} ls ./folderB/
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}82}]:} ls ./folderA/
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
127-135.pdf

    \end{Verbatim}

    diff command ကိုသုံးပြီး folderA/ နဲ့ folderB/
ကိုနှိုင်းယှဉ်ကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}83}]:} diff folderA/ folderB/
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Only in folderB/: fileA
Only in folderB/: otest

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    ဖိုလ်ဒါ နှစ်ခုကို နှိုင်းယှဉ်ကြည့်ရတာက၊ ဖိုင်နှစ်ခုကို
နှိုင်းယှဉ်ကြည့်ရတာထက်စာရင် output ကပိုပြီး user friendly ဖြစ်ပါတယ်။\\
folderA/ ထဲမှာပဲ ရှိတဲ့ ဖိုင်တွေ၊ ဖိုလ်ဒါတွေကို Only in folderA/ ဆိုပြီး
ပြပါတယ်။\\
ထိုနည်းလည်းကောင်းပဲ folderB/ ထဲမှာပဲ ရှိတဲ့ ဖိုင်တွေ၊ ဖိုလ်ဒါတွေကိုလည်း
Only in folderB/ ဆိုပြီး ပြပေးပါတယ်။

    \subsection{14. less (opposite of more)}\label{less-opposite-of-more}

cat command နဲ့ ဖိုင်တွေကို ဖတ်ကြည့်လို့ရပေမဲ့၊ ဖိုင်ထဲမှာရှိတဲ့
စာကြောင်းအရေအတွက်က မော်နီတာစကရင် တခုစာထက်မက များနေတဲ့ အခါမျိုးမှာ less
command ကို သုံးပါ။ text file တွေထဲမှာရှိတဲ့ စာကြောင်းတွေကို စာမျက်နှာ
တစ်မျက်နှာချင်း အပေါ်တက်၊ အောက်ဆင်း (Page-Up, Page-Down) လုပ်ပြီး
ကြည့်လို့ရအောင် လုပ်ပေးတဲ့ command ပါ။

သုံးပုံသုံးနည်းက အရမ်းလွယ်ပါတယ်။ less command ရဲ့နောက်မှာ
ကိုယ်ကြည့်ချင်တဲ့ ဖိုင်နာမည်ကို ပေးလိုက်ယုံပါပဲ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}84}]:} ls
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
all-vi-info.txt  fileA         item-list                 otest
\textcolor{ansi-blue-intense}{\textbf{data1}}            fileB         linux-commands.ipynb      otest.tag
\textcolor{ansi-blue-intense}{\textbf{data2}}            fmt.out       linux-commands.ipynb.bak  otest.word
\textcolor{ansi-blue-intense}{\textbf{data3}}            \textcolor{ansi-blue-intense}{\textbf{folderA}}       ls.out                    \textcolor{ansi-blue-intense}{\textbf{screen}}
\textcolor{ansi-blue-intense}{\textbf{data4}}            \textcolor{ansi-blue-intense}{\textbf{folder-athit}}  my-news                   sorted-names
\textcolor{ansi-blue-intense}{\textbf{data5}}            \textcolor{ansi-blue-intense}{\textbf{folderB}}       newfile                   \textcolor{ansi-blue-intense}{\textbf{wildcard}}
echo             \textcolor{ansi-blue-intense}{\textbf{folder-new}}    news

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} less ./fileA
\end{Verbatim}

    မော်နီတာမှာမြင်ရမဲ့ text editor လိုမျိုး output ကို ပုံအနေနဲ့
ထည့်ပြထားပါတယ်။

    

    ဒီနေရာမှာက ဥပမာအနေနဲ့ စာကြောင်းရေ လေးကြောင်းသာရှိတဲ့ fileA ကို less နဲ့
run ပြထားပေမဲ့၊ လက်တွေ့ စမ်းကြည့်တဲ့ အခါ စာကြောင်းရေ အများကြီးရှိတဲ့
ဖိုင်နဲ့ စမ်းသပ်ကြည့်ပါ။ စာကြောင်းရေ အများကြီးရှိတဲ့ ဖိုင်နဲ့ ဆိုရင်
စကရင်ရဲ့ အောက်ဆုံး ဘယ်ဘက်ထောင့်မှာ ":" က ပေါ်နေပြီး၊ command
အမျိုးမျိုးသုံးပြီး ဖိုင်ကို စာမျက်နှာတစ်ခုချင်း ရှေ့တိုး၊ နောက်ဆုတ်
လုပ်တာ၊ ရှာချင်တဲ့ စာလုံးကို "/" (သို့) "?" ရိုက်ပြီး Regular Expression
pattern တွေနဲ့ ရှာတာဖွေတာ စသည်ဖြင့် အလုပ်အများကြီးလုပ်ပေးလို့ less
command က linux terminal မှာ text file တွေကို view လုပ်ကြည့်တဲ့ နေရာမမှာ
မသိမဖြစ်နဲ့ သုံးသင့်တဲ့ command တစ်ခုဖြစ်ပါတယ်။ less command ကို run
နေစဉ်မှာ ဘယ်လို command တွေကိုသုံးပြီး ရှေ့တိုး၊ နောက်ဆုတ်၊ ရှာဖွေ စတဲ့
အလုပ်တွေကို လုပ်လို့ရသလဲ ဆိုတာကို သိချင်ရင်၊ "h" ကို နှိပ်ပြီး Help
Screen ကို ခေါ်ကြည့်နိုင်ပါတယ်။

less command နဲ့ ဖိုင်ကိုကြည်နေရာကနေ ထွက်ချင်ရင် "q" (သို့) "Q"
ကီးကိုနှိပ်ပြီး ထွက်နိုင်ပါတယ်။

    အသုံးများတဲ့ option တွေကတော့ အောက်ပါအတိုင်း ဖြစ်ပါတယ်။

less -N filename\\
-N က ဖိုင်ထဲက စာကြောင်း တစ်ကြောင်းချင်းစီကို လိုင်းနံပါတ် တပ်ပေးပြီး
ပြစေချင်တဲ့ အခါ အသုံးပြု

less -N +100 filename\\
+ နဲ့ ကိုယ်စပြစေချင်တဲ့ စာကြောင်းနံပါတ်ကို ပေးလို့ရတယ်။\\
အထက်က ဥပမာက စာကြောင်းနံပါတ် 100 ကနေ စပြပေးပါလို့ command ပေးတာ။

less +F experiment1.log

+F က log file လိုမျိုး အပြောင်းအလဲက စဉ်ဆက်မပြတ်ရှိနေတဲ့ ဖိုင်တွေရဲ့
နောက်ဆုံးစာမျက်နှာ (updated page) တွေကို စောင့်ကြည့်ချင်တဲ့ အခါမျိုးမှာ
သုံးပါတယ်။

ဥပမာ ကျွန်တော်တို့က experiment1 ဆိုပြီး စမ်းသပ်မှုတစ်ခုလုပ်နေပြီး၊
အဲဒီကနေ ထွက်လာတဲ့ ရလဒ်တွေ၊ error တွေကို experiment1.log ဖိုင်မှာ
ဝင်ပြီးရေးပေးနေတယ်ဆိုပါစို့။ အဲဒီ စမ်းသပ်မှုကနေ ဘယ်လို log တွေဝင်ရေးသလဲ
ဆိုတာကို less +F ကို သုံးပြီး ကြည့်တာမျိုးလုပ်ပါတယ်။ experiment1
စမ်းသပ်မှုမှာပါဝင်တဲ့ ပရိုဂရမ်က experiment1.log ဖိုင်မှာ တခုခုဝင်ရေးတာ၊
ဖျက်တာကို လုပ်တာနဲ့ တပြိုင်နက်၊ အဲဒီအပြောင်းအလဲတွေကို ကြည့်နေတဲ့ less
editor ရဲ့ စကရင်မှာ active ဖြစ်လို့ပါ။

ဒါအပြင်၊ လက်ရှိ F mode ကနေ Ctrl + C နဲ့ ခဏထွက်ပြီး ပုံမှန် less နဲ့
ကြည့်နေတဲ့ mode ဆီကို ပြောင်းပြီး ကိုယ်ရှာကြည့်ချင်တဲ့ စာလုံးကို ရှာ၊
စာကြောင်းဆီကို သွား စတာတွေလုပ်လို့ ရပါတယ်။ ပြီးရင် F ကို နှိပ်ပြီး၊ F
mode ဆီကိုပြန်သွားပြီး log ဖိုင်ရဲ့ နောက်ဆုံးအပြောင်းလဲ ကို
ဆက်စောင့်ကြည့်နိုင်ပါတယ်။

မှတ်ချက်။ ။ ခေါင်းစဉ်မှာ opposite of more ဆိုပြီး ရေးထားတာက၊ less က more
ဆိုတဲ့ command နဲ့ ဆန့်ကျင်ဘက်ပါ။ more command ထက် အလုပ်အများကြီး
လုပ်ပေးနိုင်ပါတယ်လို့ ဆိုလိုပါတယ်။ man less ဆိုပြီး ရိုက်ကြည့်ရင်
ရှင်းပြထားတာကို ဖတ်လို့ရပါတယ်။

    \subsection{15. type (display a command
type)}\label{type-display-a-command-type}

type command က command တစ်ခုချင်းစီရဲ့ အမျိုးအစားကို သိချင်တဲ့
အခါမှာသုံးပါတယ်။ command တစ်ခုခုရဲ့ နာမည်ကို type ကိုသုံးပြီး အဲဒီ
command က alias လား၊ shell ရဲ့ function လား၊ shell ရဲ့ builtin လား၊ disk
ထဲမှာသိမ်းထားတဲ့ file လား၊ shell ရဲ့ reserved word လား ဆိုတာကို
ရှာဖွေနိုင်ပါတယ်။

ဥပမာ type ls ဆိုပြီး ရိုက်ကြည့်ရင် အောက်ပါအတိုင်း ပြပေးပါလိမ့်မယ်။

ls is aliased to `ls -\/-color=auto'

ls command က "ls -\/-color=auto" ဆိုတဲ့ command ကို alias
လုပ်ထားတာဖြစ်ကြောင်းကို သိနိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n+nb}{type} \PY{n+nb}{cd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
cd is a shell builtin

    \end{Verbatim}

    cd command က shell ရဲ့ builtin command ဖြစ်ကြောင်းကို ပြပေးပါတယ်။

-t option ပေးပြီး command တစ်ခုရဲ့ အမျိုးအစားကို စာလုံးတစ်လုံးနဲ့
တိုတိုပြခိုင်းလို့ ရပါတယ်။ alias လုပ်ထားတာဆိုရင် "alias"၊ shell ရဲ့
reserved word ဆိုရင် "keyword" ဆိုပြီး၊ shell ရဲ့ function ဆိုရင်
"function" ဆိုပြီး၊ shell ရဲ့ builtin command ဆိုရင် "builtin"၊ disk မှာ
သိမ်းထားတဲ့ ဖိုင်တစ်ဖိုင် ဆိုရင် "file" ဆိုပြီး အသီးသီးပြပေးပါလိမ့်မယ်။

အောက်ဖော်ပြပါ type command ဥပမာ တစ်ချို့ကို terminal မှာ
ရိုက်စမ်းကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n+nb}{type} \PYZhy{}t \PY{k}{if}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
keyword

    \end{Verbatim}

    if က bash shell ရဲ့ keyword ဖြစ်ကြောင်းကို ပြပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{n+nb}{type} \PYZhy{}t rm
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
file

    \end{Verbatim}

    "rm command" က file ဖြစ်ကြောင်း ပြသပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{n+nb}{type} \PYZhy{}t \PY{n+nb}{pwd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
builtin

    \end{Verbatim}

    builtin ဆိုပြီး ပြသပေးပါလိမ့်မယ်။

    command prompt မှာလဲ function တစ်ခုကို ဆောက်လို့ရပါတယ်။ ဥပမာ အနေနဲ့ mcd
ဆိုတဲ့function တစ်ခုကို ဆောက်ပြပါမယ်။ mcd က mkdir နဲ့
ဖိုလ်ဒါအသစ်တစ်ခုကို ဆောက်ပြီးရင်၊ အဲဒီ ဆောက်လိုက်တဲ့ ဖိုလ်ဒါအသစ်ထဲကို
တခါတည်းဝင်ပေးမဲ့ function ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} mcd \PY{o}{(}\PY{o}{)} \PY{o}{\PYZob{}} mkdir \PYZhy{}p \PY{n+nv}{\PYZdl{}1}\PY{p}{;} \PY{n+nb}{cd} \PY{n+nv}{\PYZdl{}1}\PY{p}{;} \PY{o}{\PYZcb{}}
\end{Verbatim}

    ဒီနေရာမှာ \$1 ဆိုတာက mcd function ကိုခေါ်သုံးတဲ့ အခါ နောက်က ပေးမဲ့
ဖိုလဒ်ဒါနာမည် (သို့) command line parameter ကို ဆိုလိုပါတယ်။\\
ဆောက်ပြီးသွားရင် အောက်ပါအတိုင်း mcd function ကို folder-new ဆိုတဲ
parameter နဲ့ run ခိုင်းပြီး၊ လက်ရှိရောက်နေတဲ့ path ကို pwd command နဲ့
ပြခိုင်းပါမယ်။\\
ဒီနေရာမှာ ";" က command သုံးလေးခု ဆက်တိုက်ကို ရေးတဲ့ အခါမှာ၊ command
တစ်ခုပြီးဆုံးကြောင်းအတွက် သုံးတဲ့ symbol ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} mcd folder\PYZhy{}new\PY{p}{;} pwd\PY{p}{;}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/linux-cmd/folder-new/folder-new

    \end{Verbatim}

    /home/lar/linux-cmd/folder-new ဆိုပြီး ရိုက်ပြပေးတာက pwd ရဲ့　output
ဖြစ်တဲ့ လက်ရှိရောက်နေတဲ့ path ပါ။\\
mcd အမိန့်က တကယ် အလုပ်လုပ်ပြီးသွားသလား ဆိုတာကို သေချာအောင်
ရိုက်ခိုင်းထားတာပါ။

    mcd ကို type -t option နဲ့ ရိုက်ကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n+nb}{type} \PYZhy{}t mcd
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
function

    \end{Verbatim}

    အထက်ပါအတိုင်း mcd က function ဖြစ်ကြောင်းကို type command က
ပြပေးနိုင်ပါတယ်။

    command က path တစ်ခုအောက်မှာထက်ပိုရှိလား သိချင်ရင် -a option နဲ့
ကြည့်နိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n+nb}{type} \PYZhy{}a python
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
python is /home/lar/anaconda3/bin/python
python is /home/lar/anaconda3/bin/python
python is /home/lar/anaconda3/bin/python
python is /usr/bin/python

    \end{Verbatim}

    "-P" option နဲ့ ပေးလိုက်တဲ့ command ရဲ့ path ကို ရှာခိုင်းလို့ရပါတယ်။\\
ဥပမာ "touch" command ရဲ့ပရိုဂရမ်ဖိုင်က ဘယ်မှာရှိသလဲဆိုတာကို သိချင်ရင်
အောက်ပါအတိုင်း "type -P touch" ဆိုပြီး command ပေးပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n+nb}{type} \PYZhy{}P touch
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/usr/bin/touch

    \end{Verbatim}

    "cd" command ရဲ့ path ကို "-P" option နဲ့ရှာခိုင်းရင်တော့ ဘာမှရိုက်ပြမှာ
မဟုတ်ပါဘူး။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n+nb}{type} \PYZhy{}P \PY{n+nb}{cd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    ဘာကြောင့်လဲ ဆိုတော့ "cd" command က shell ရဲ့ builtin command
ဖြစ်နေလို့ပါ။ အထက်မှာသင်ပေးခဲ့သလို "touch cd" နဲ့ ရိုက်ကြည့်ရင် "cd is a
shell builtin" ဖြစ်ကြောင်းရိုက်ပြပေးပါလိမ့်မယ်။ ဒီတခါတော့ "-t" option
ကို သုံးပြီး စာလုံးတစ်လုံးထဲနဲ့ပဲ ရိုက်ပြခိုင်းပြီး confirm လုပ်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n+nb}{type} \PYZhy{}t \PY{n+nb}{cd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
builtin

    \end{Verbatim}

    command prompt မှာ အကြိမ်ပေါင်းများစွာ ရိုက်သုံးရတဲ့ "ls" ရဲ့ path
ကိုလည်း ရှာကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n+nb}{type} \PYZhy{}P ls
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/bin/ls

    \end{Verbatim}

    \subsection{16. which (locate a command)}\label{which-locate-a-command}

which နဲ့ command တစ်ခုရဲ့ executable လုပ်မဲ့ path ကို
ရှာကြည့်လို့ရပါတယ်။ command တစ်ခုက version တစ်ခုထက်မက ပိုရှိတဲ့
အခြေအနေမျိုးမှာဆိုရင်လည်း ဘယ် version (သို့) ဘယ် path အောက်က command ကို
ခေါ် run မှာလဲဆိုတာကို သိချင်တဲ့ အခါမှာ အသုံးဝင်ပါတယ်။

ဥပမာ firefox ကို ဘယ် path ကနေ ခေါ် run မှာလဲ ဆိုတာကို which နဲ့
ကြည့်ရအောင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} which firefox
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/usr/bin/firefox

    \end{Verbatim}

    တစ်ခုသိထားရမှာက which က shell ရဲ့ builtin command တွေနဲ့ alias တွေကို
ပြပေးမှာ မဟုတ်ဘူးဆိုတာကိုပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} which \PY{n+nb}{cd}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    အထက်မှာ ဥပမာပြထားခဲ့သလို shell ရဲ့ builtin command တစ်ခုဖြစ်တဲ့ cd ကို
which နဲ့ ကြည့်ရင် ဘာမှပြပေးမှာ မဟုတ်ပါ။

    \subsection{17. -\/-help or -h (display usage
information)}\label{help-or--h-display-usage-information}

-\/-help (သို့) -h က command တစ်ခုကို ဘယ်လို run ရမလဲဆိုတာ၊ ဘာ option
တွေရှိသလဲ ဆိုတာကို သိချင်တဲ့ အခါမှာ သုံးပါတယ်။ ဘယ်လို command
မျိုးမှာမဆို -\/-help option ကပါဝင်ပြီး၊ command line interface (CLI)
မှာတော့ သိကို သိထားရပါမယ်။ သုံးပုံသုံးနည်း ဥပမာတွေကတော့
အောက်ပါအတိုင်းပါပဲ။

mkdir command ရဲ့ help ကိုကြည့်ချင်တဲ့ အခါ

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} mkdir \PYZhy{}\PYZhy{}help
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Usage: mkdir [OPTION]{\ldots} DIRECTORY{\ldots}
Create the DIRECTORY(ies), if they do not already exist.

Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit

GNU coreutils online help: <http://www.gnu.org/software/coreutils/>
Full documentation at: <http://www.gnu.org/software/coreutils/mkdir>
or available locally via: info '(coreutils) mkdir invocation'

    \end{Verbatim}

    diff command ရဲ့ help ကို ကြည့်ချင်တဲ့ အခါမှာ

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} diff \PYZhy{}\PYZhy{}help
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Usage: diff [OPTION]{\ldots} FILES
Compare FILES line by line.

Mandatory arguments to long options are mandatory for short options too.
      --normal                  output a normal diff (the default)
  -q, --brief                   report only when files differ
  -s, --report-identical-files  report when two files are the same
  -c, -C NUM, --context[=NUM]   output NUM (default 3) lines of copied context
  -u, -U NUM, --unified[=NUM]   output NUM (default 3) lines of unified context
  -e, --ed                      output an ed script
  -n, --rcs                     output an RCS format diff
  -y, --side-by-side            output in two columns
  -W, --width=NUM               output at most NUM (default 130) print columns
      --left-column             output only the left column of common lines
      --suppress-common-lines   do not output common lines

  -p, --show-c-function         show which C function each change is in
  -F, --show-function-line=RE   show the most recent line matching RE
      --label LABEL             use LABEL instead of file name
                                  (can be repeated)

  -t, --expand-tabs             expand tabs to spaces in output
  -T, --initial-tab             make tabs line up by prepending a tab
      --tabsize=NUM             tab stops every NUM (default 8) print columns
      --suppress-blank-empty    suppress space or tab before empty output lines
  -l, --paginate                pass output through 'pr' to paginate it

  -r, --recursive                 recursively compare any subdirectories found
      --no-dereference            don't follow symbolic links
  -N, --new-file                  treat absent files as empty
      --unidirectional-new-file   treat absent first files as empty
      --ignore-file-name-case     ignore case when comparing file names
      --no-ignore-file-name-case  consider case when comparing file names
  -x, --exclude=PAT               exclude files that match PAT
  -X, --exclude-from=FILE         exclude files that match any pattern in FILE
  -S, --starting-file=FILE        start with FILE when comparing directories
      --from-file=FILE1           compare FILE1 to all operands;
                                    FILE1 can be a directory
      --to-file=FILE2             compare all operands to FILE2;
                                    FILE2 can be a directory

  -i, --ignore-case               ignore case differences in file contents
  -E, --ignore-tab-expansion      ignore changes due to tab expansion
  -Z, --ignore-trailing-space     ignore white space at line end
  -b, --ignore-space-change       ignore changes in the amount of white space
  -w, --ignore-all-space          ignore all white space
  -B, --ignore-blank-lines        ignore changes where lines are all blank
  -I, --ignore-matching-lines=RE  ignore changes where all lines match RE

  -a, --text                      treat all files as text
      --strip-trailing-cr         strip trailing carriage return on input

  -D, --ifdef=NAME                output merged file with '\#ifdef NAME' diffs
      --GTYPE-group-format=GFMT   format GTYPE input groups with GFMT
      --line-format=LFMT          format all input lines with LFMT
      --LTYPE-line-format=LFMT    format LTYPE input lines with LFMT
    These format options provide fine-grained control over the output
      of diff, generalizing -D/--ifdef.
    LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'.
    GFMT (only) may contain:
      \%<  lines from FILE1
      \%>  lines from FILE2
      \%=  lines common to FILE1 and FILE2
      \%[-][WIDTH][.[PREC]]\{doxX\}LETTER  printf-style spec for LETTER
        LETTERs are as follows for new group, lower case for old group:
          F  first line number
          L  last line number
          N  number of lines = L-F+1
          E  F-1
          M  L+1
      \%(A=B?T:E)  if A equals B then T else E
    LFMT (only) may contain:
      \%L  contents of line
      \%l  contents of line, excluding any trailing newline
      \%[-][WIDTH][.[PREC]]\{doxX\}n  printf-style spec for input line number
    Both GFMT and LFMT may contain:
      \%\%  \%
      \%c'C'  the single character C
      \%c'\textbackslash{}OOO'  the character with octal code OOO
      C    the character C (other characters represent themselves)

  -d, --minimal            try hard to find a smaller set of changes
      --horizon-lines=NUM  keep NUM lines of the common prefix and suffix
      --speed-large-files  assume large files and many scattered small changes

      --help               display this help and exit
  -v, --version            output version information and exit

FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE{\ldots}' or 'FILE{\ldots} DIR'.
If --from-file or --to-file is given, there are no restrictions on FILE(s).
If a FILE is '-', read standard input.
Exit status is 0 if inputs are the same, 1 if different, 2 if trouble.

Report bugs to: bug-diffutils@gnu.org
GNU diffutils home page: <http://www.gnu.org/software/diffutils/>
General help using GNU software: <http://www.gnu.org/gethelp/>

    \end{Verbatim}

    \subsection{18. man (system's manual
pager)}\label{man-systems-manual-pager}

man က executable ပရိုဂရမ်တွေ ရဲ့ သုံးပုံသုံးနည်း အသေးစိတ်ကို
ရှာဖွေကြည့်ချင်တဲ့ အခါမှာ သုံးပါတယ်။ command တွေရဲ့ reference manual
ပါပဲ။

-\/-help နဲ့ ကြည့်တာထက် ပိုပြီးပြည့်စုံပါတယ်။ သုံးပုံသုံးနည်းက man
program-name ဆိုတဲ့ပုံစံပါ။\\
ဥပမာ ls command ရဲ့ man page ကို ဖတ်ချင်တယ်ဆိုရင်

man ls

Linux system အများစုမှာ man စာမျက်နှာတွေကို less နဲ့ ပြပေးပါတယ်။
အဲဒါကြောင့် less command မှာ ကြည့်ရင်းနဲ့ သုံးတဲ့ command တွေ (ဥပမာ f
နဲ့ စာမျက်နှာတစ်မျက်နှာစာ ရှေ့တိုးတာ၊ b နဲ့ စာမျက်နှာ တစ်မျက်နှာစာ
နောက်ဆုတ်တာ၊ ! နဲ့ less ထဲကနေ မထွက်ပဲ command တွေကို run တာမျိုး)
အားလုံးကို အသုံးပြုနိုင်ပါတယ်။

help ကြည့်ချင်တဲ့ command ရဲ့ နာမည်ကို သေသေချာချာ မသိတဲ့ အခါ၊ နောက်ပြီး
ရိုက်ထည့်လိုက်တဲ့ စာလုံးပါတဲ့ (သို့) ဆက်စပ်မှုရှိတဲ့ man စာမျက်နှာတွေကို
ရှာကြည့်ချင်တဲ့ အခါမှာ -k option ကိုသုံးပါတယ်။ ဥပမာ python
ဆိုတဲ့စာလုံးပါတဲ့ man စာမျက်နှာတွေအားလုံးကို အောက်ပါအတိုင်း
ရှာကြည့်နိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} man \PYZhy{}k python
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
2to3 (1)             - Python2 to Python3 converter
2to3-2.7 (1)         - Python2 to Python3 converter
2to3-3.5 (1)         - Python2 to Python3 converter
dh\_python2 (1)       - calculates Python dependencies, adds maintainer script{\ldots}
dh\_python3 (1)       - calculates Python dependencies, adds maintainer script{\ldots}
jwt3 (1)             - Python implementation of JSON Web Token
pdb (1)              - the Python debugger
pdb2.7 (1)           - the Python debugger
pdb3 (1)             - the Python debugger
pdb3.5 (1)           - the Python debugger
py3compile (1)       - byte compile Python 3 source files
py3versions (1)      - print python3 version information
pybuild (1)          - invokes various build systems for requested Python ver{\ldots}
pycompile (1)        - byte compile Python source files
pydoc (1)            - the Python documentation tool
pydoc2.7 (1)         - the Python documentation tool
pydoc3 (1)           - the Python documentation tool
pydoc3.5 (1)         - the Python documentation tool
pygettext (1)        - Python equivalent of xgettext(1)
pygettext2.7 (1)     - Python equivalent of xgettext(1)
pygettext3 (1)       - Python equivalent of xgettext(1)
pygettext3.5 (1)     - Python equivalent of xgettext(1)
python (1)           - an interpreted, interactive, object-oriented programmi{\ldots}
python-config (1)    - output build options for python C/C++ extensions or em{\ldots}
python2 (1)          - an interpreted, interactive, object-oriented programmi{\ldots}
python2-config (1)   - output build options for python C/C++ extensions or em{\ldots}
python2.7 (1)        - an interpreted, interactive, object-oriented programmi{\ldots}
python2.7-config (1) - output build options for python C/C++ extensions or em{\ldots}
python3 (1)          - an interpreted, interactive, object-oriented programmi{\ldots}
python3.5 (1)        - an interpreted, interactive, object-oriented programmi{\ldots}
python3.5m (1)       - an interpreted, interactive, object-oriented programmi{\ldots}
python3m (1)         - an interpreted, interactive, object-oriented programmi{\ldots}
pyversions (1)       - print python version information
x86\_64-linux-gnu-python-config (1) - output build options for python C/C++ ex{\ldots}
x86\_64-linux-gnu-python2.7-config (1) - output build options for python C/C++{\ldots}

    \end{Verbatim}

    man help စာမျက်နှာတွေက command အမျိုးအစားပေါ်မူတည်ပြီး၊ သက်ဆိုင်ရာ
section တွေ ခွဲပြီးရှင်းပြထားတာတွေရှိပါတယ်။\\
section တွေကို အောက်ပါအတိုင်း နံပါတ်တွေခွဲထားပါတယ်။

1 Executable programs or shell commands\\
2 System calls (functions provided by the kernel)\\
3 Library calls (functions within program libraries)\\
4 Special files (usually found in /dev)\\
5 File formats and conventions eg /etc/passwd\\
6 Games\\
7 Miscellaneous (including macro packages and conventions), e.g. man(7),
groff(7)\\
8 System administration commands (usually only for root)\\
9 Kernel routines {[}Non standard{]}

command တစ်ခု ရဲ့ man help စာမျက်နှာတွေ အများကြီးထဲကမှ၊
ကိုယ်ကြည့်ချင်တဲ့ section ကို နံပါတ်နဲ့ option ပေးပြီး
ကြည့်လို့ရပါတယ်။\\
ဥပမာ /etc/passwd ရဲ့ ဖိုင်က ဘယ်လို format လဲဆိုတာကို သိချင်ရင်
အောက်ပါအတိုင်း ရိုက်ကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} man \PY{l+m}{5} passwd
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
PASSWD(5)                File Formats and Conversions                PASSWD(5)

NAME
       passwd - the password file

DESCRIPTION
       /etc/passwd contains one line for each user account, with seven fields
       delimited by colons (“:”). These fields are:

       ·   login name

       ·   optional encrypted password

       ·   numerical user ID

       ·   numerical group ID

       ·   user name or comment field

       ·   user home directory

       ·   optional user command interpreter

       The encrypted password field may be blank, in which case no password is
       required to authenticate as the specified login name. However, some
       applications which read the /etc/passwd file may decide not to permit
       any access at all if the password field is blank. If the password field
       is a lower-case “x”, then the encrypted password is actually stored in
       the shadow(5) file instead; there must be a corresponding line in the
       /etc/shadow file, or else the user account is invalid. If the password
       field is any other string, then it will be treated as an encrypted
       password, as specified by crypt(3).

       The comment field is used by various system utilities, such as
       finger(1).

       The home directory field provides the name of the initial working
       directory. The login program uses this information to set the value of
       the \$HOME environmental variable.

       The command interpreter field provides the name of the user's command
       language interpreter, or the name of the initial program to execute.
       The login program uses this information to set the value of the \$SHELL
       environmental variable. If this field is empty, it defaults to the
       value /bin/sh.

FILES
       /etc/passwd
           User account information.

       /etc/shadow
           optional encrypted password file

       /etc/passwd-
           Backup file for /etc/passwd.

           Note that this file is used by the tools of the shadow toolsuite,
           but not by all user and password management tools.

SEE ALSO
       crypt(3), getent(1), getpwnam(3), login(1), passwd(1), pwck(8),
       pwconv(8), pwunconv(8), shadow(5), su(1), sulogin(8).

shadow-utils 4.2                  05/16/2017                         PASSWD(5)

    \end{Verbatim}

    \subsection{19. whatis (display one-line manual page
descriptions)}\label{whatis-display-one-line-manual-page-descriptions}

command တစ်ခုက ဘာလုပ်ဖို့အတွက်သုံးတာလဲ ဆိုတာကို စာကြောင်းတို
တစ်ကြောင်းနဲ့ ရှင်းပြထားတာကို ကြည့်ဖို့အတွက်ဆိုရင် whatis ကို သုံးပါတယ်။
တခါတလေ မှာ command တစ်ခုရဲ့ help စာမျက်နှာတွေကို အသေးစိတ် မဖတ်ချင်ဘူး။
ဘာလုပ်တဲ့ command ဆိုတာကိုပဲ confirm လုပ်ချင်တဲ့ အခါမျိုးမှာ
အသုံးများပါတယ်။

ဥပမာ ping ဆိုတဲ့ command က ဘာလုပ်တာလဲ ဆိုတာကို သိချင်တဲ့ အခါ

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} whatis ping
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
ping (8)             - send ICMP ECHO\_REQUEST to network hosts

    \end{Verbatim}

    နောက်ထပ် ဥပမာ တစ်ခုအနေနဲ့ ssh command က ဘာလုပ်ဖို့အတွက်သုံးတာလဲ ဆိုတာကို
သိချင်တဲ့ အခါ

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} whatis ssh
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
ssh (1)              - OpenSSH SSH client (remote login program)

    \end{Verbatim}

    ကြည့်တဲ့ command အပေါ်မူတည်ပြီး section တစ်ခုထက်မက ပိုရှိရင်၊ ရှိတဲ့
section အားလုံးကို ပြပေးပါလိမ့်မယ်။\\
ဥပမာ passwd ကို whatis နဲ့ကြည့်မယ်ဆိုရင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} whatis passwd
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
passwd (1)           - change user password
passwd (1ssl)        - compute password hashes
passwd (5)           - the password file

    \end{Verbatim}

    \subsection{20. info (read Info
documents)}\label{info-read-info-documents}

info က man လိုမျိုး help (သို့) manual စာမျက်နှာကိုပြပေးတဲ့ နောက်ထပ်
command တစ်ခုပါ။

ဘာကြောင့် man နဲ့ info ဆိုပြီးနှစ်မျိုးရှိနေရတာလဲ၊ man နဲ့ info က
ဘာကွာသလဲဆိုတာကို အတိုရှင်းပြပါမယ်။ man က Unix လက်ထက်ကတည်းက သုံးခဲ့တဲ့
traditional ပုံစံပါ။ လက်ရှိ ဒီနေ့ခေတ်အထိ command line မှာ help
ကြည့်ဖို့အတွက်က အရမ်းကို အသုံးဝင်ပါသေးတယ်။ သို့သော် အထက်မှာ သုံးပြခဲ့တဲ့
အတိုင်း man မှာက section တွေခွဲပြီး ဖိုင်တွေကိုလည်း
သပ်သပ်စီခွဲသိမ်းထားပါတယ်။ ဥပမာ passwd ရဲ့ man page section 1 နဲ့
ဆိုင်တဲ့ဖိုင်ကို /usr/share/man/man1/passwd.1.gz မှာ section 5 နဲ့
ဆိုင်တဲ့ဖိုင်ကို /usr/share/man/man5/passwd.5.gz မှာ သိမ်းထားပါတယ်။
အဲဒါကြောင့် အားလုံးကို ပေါင်းပြီး ပရင့်ထုတ်တာမျိုးလုပ်ချင်တယ် ဆိုရင်
သိပ်ပြီးတော့ အဆင်မပြေခဲ့ပါ။

၁၉၉၀ လောက်မှာ GNU (ဂနု လို့အသံထွက်တယ်) ပရောဂျက်အဖွဲ့က man တွေကို
အစားထိုးဖို့ info ဆိုတာကို စတင် လုပ်ဆောင်ခဲ့ရာက info help documents
တွေပေါ်ပေါက်လာတာပါ။ info က markup language ကို သုံးထားပါတယ်။ အဲဒါကြောင့်
hyperlink တွေပါရှိပြီး၊ အကြောင်းအရာ တစ်ခုကနေ နောက်အကြောင်းအရာ တစ်ခုစီကို
ခုန်ကူးပြီး ကြည့်လို့ရပါတယ်။

အမှန်တကယ်က Linux မှာ help ကြည့်ဖို့အတွက်က man နဲ့ info
နှစ်မျိုးထဲမဟုတ်ပါဘူး။ တခြား ပရောဂျက်ကွဲတွေဖြစ်တဲ့ GNOME, KDE
တို့မှာလည်း HTML ကို အခြေခံထားတဲ့ help documentation တွေရှိကြပါသေးတယ်။
အဲဒါကြောင့် ကိုယ်သုံးတဲ့ Linux system ပေါ်မူတည်ပြီး help (သို့) manual
တွေရဲ့ ပုံစံက ကွဲပြားနိုင်ပါတယ်။

info ကိုသုံးပြီး command တချို့ရဲ့ help screen ကြည့်ပုံကို နမူနာအနေနဲ့
သုံးပြပါမယ်။\\
ဥပမာ vi text editor ကို info နဲ့ ကြည့်မယ်ဆိုရင်

info vi

vi ရဲ့ options တွေကို သိချင်တယ်ဆိုရင်

info -\/-show-options vi

info ကို ဘာ option မှ မပေးပဲ အောက်ပါအတိုင်းရိုက်ရင်၊ info ကို သုံးထားတဲ့
application အားလုံးကို မာတိကာပုံစံနဲ့ တွေ့ရပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} info
\end{Verbatim}

    ဘယ်လို ပုံစံနဲ့ မြင်ရသလဲဆိုတာကို idea ရအောင် screen ရဲ့တစိတ်တပိုင်းကိုပဲ
အောက်ပါအတိုင်း ဖော်ပြပါမယ်။

*base32: (coreutils)base32 invocation. Base32 encode/decode data.\\
*base64: (coreutils)base64 invocation. Base64 encode/decode data.\\
*basename: (coreutils)basename invocation. Strip directory and suffix.\\
*bibtex: (web2c)bibtex invocation. Maintaining bibliographies.\\
*cat: (coreutils)cat invocation. Concatenate and write files.\\
*chcon: (coreutils)chcon invocation. Change SELinux CTX of files.\\
*chgrp: (coreutils)chgrp invocation. Change file groups.\\
*chmod: (coreutils)chmod invocation. Change access permissions.\\
*chown: (coreutils)chown invocation. Change file owners and groups.\\
*chroot: (coreutils)chroot invocation. Specify the root directory.\\
*cksum: (coreutils)cksum invocation. Print POSIX CRC checksum.\\
*cmp: (diffutils)Invoking cmp. Compare 2 files byte by byte.\\
*comm: (coreutils)comm invocation. Compare sorted files by line.\\
*cp: (coreutils)cp invocation. Copy files.\\
*csplit: (coreutils)csplit invocation. Split by context.\\
*cut: (coreutils)cut invocation. Print selected parts of lines.\\
*date: (coreutils)date invocation. Print/set system date and time.\\
*dd: (coreutils)dd invocation. Copy and convert a file.\\
*df: (coreutils)df invocation. Report file system disk usage.\\
*diff: (diffutils)Invoking diff. Compare 2 files line by line.\\
*diff3: (diffutils)Invoking diff3. Compare 3 files line by line.\\
*dir: (coreutils)dir invocation. List directories briefly.\\
*dircolors: (coreutils)dircolors invocation. Color setup for ls.\\
*dirname: (coreutils)dirname invocation. Strip last file name
component.\\
*du: (coreutils)du invocation. Report on disk usage.\\
*dvicopy: (web2c)dvicopy invocation. Virtual font expansion\\
*dvitomp: (web2c)dvitomp invocation. DVI to MPX (MetaPost pictures).\\
*dvitype: (web2c)dvitype invocation. DVI to human-readable text.\\
*echo: (coreutils)echo invocation. Print a line of text.\\
*env: (coreutils)env invocation. Modify the environment.\\
*expand: (coreutils)expand invocation. Convert tabs to spaces.\\
*expr: (coreutils)expr invocation. Evaluate expressions.\\
*factor: (coreutils)factor invocation. Print prime factors

    \subsection{21. Escape Sequences}\label{escape-sequences}

Escape sequence (backslash escape character လို့လည်းခေါ်) က
ပရိုဂရမ်မင်းဘာသာစကားတွေဖြစ်တဲ့ C, Java, Perl တို့မှာသုံးသလိုပါပဲ။
Escaping လုပ်ချင်တဲ့ စာလုံးကို "" (backslash) ခံပြီးရိုက်ပါတယ်။ bash က
"" နောက်က စာလုံးကို interpret လုပ်တဲ့အခါမှာ သတ်မှတ်ထားတဲ့ escape
sequence တွေအတိုင်း အလုပ်လုပ်ပေးပါတယ်။

Bash shell မှာသုံးတဲ့ escape sequences တွေက အများကြီးရှိပါတယ်။ အဲဒီအထဲက
အသုံးများတဲ့ escape sequence တချို့နဲ့ သူတို့ရဲ့ အလုပ်လုပ်ပုံကတော့
အောက်ပါဇယားအတိုင်း ဖြစ်ပါတယ်။

\begin{longtable}[c]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.21\columnwidth}\raggedright\strut
Escape sequence
\strut\end{minipage} &
\begin{minipage}[b]{0.73\columnwidth}\raggedright\strut
အလုပ်လုပ်ပုံ
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\a          
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
သတိပေးချင်တဲ့ အခါ၊ စပီကာကနေ bell အသံပေးချင်တဲ့အခါ သုံးတယ်။ ASCII bell
character လို့လည်းခေါ်တယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\b 
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
Backspace ကီးကို ရိုက်ချင်တဲ့အခါ သုံးတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\c | သူ့နောက်က စာလုံးတွေကို ရိုက်မပေးတော့ဘူး။ နောက်ပြီး
စာကြောင်းအသစ်တစ်ကြောင်းအနေနဲ့လည်း ခွဲမပေးပါဘူး
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\f 
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
form feed (စာမျက်နှာ အသစ်ခွဲ) အလုပ်ကို လုပ်ပေးတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\n 
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
လက်ရှိ ရောက်ရှိနေတဲ့နေရာကနေ စာကြောင်းအသစ်ရဲ့ ဘယ်ဘက် အကျဆုံးနေရာကို
ရွှေ့ပေးလိမ့်မယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\r 
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
Carriage return သင်္ကေတပါ။ လက်ရှိစာကြောင်းရဲ့ ဘယ်ဘက်ထိပ်ဆုံး နေရာကို
ရွှေ့ချင်တဲ့အခါ အသုံးပြုတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\t 
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
Horizontal Tab ကီးကို ရိုက်ဖို့အတွက် သုံးတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\v | Vertical Tab ကီးကို ရိုက်ဖို့အတွက် သုံးတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textbackslash{}‌{[} \textbar{} စကရင်မှာ ရိုက်ပြဖို့မဟုတ်ပဲ၊ တစ်ခြား
အလုပ်လုပ်ဖို့ သတ်မှတ်ထားသောစာလုံး (non-printing character)တွေရဲ့ ကွင်းစ
\textbar{} \textbar{} \textbackslash{}‌{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
စကရင်မှာ ရိုက်ပြဖို့မဟုတ်ပဲ၊ တစ်ခြား အလုပ်လုပ်ဖို့ သတ်မှတ်ထားသောစာလုံး
(non-printing character) တွေရဲ့ ကွင်းပိတ်
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textbackslash{}'
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
single quote ကို ရိုက်ဖို့အတွက်သုံးတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textbackslash{}"
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
double quote ကို ရိုက်ဖို့အတွက်သုံးတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textbackslash{}nnn
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
eight-bit စာလုံးတွေကို　octal value နဲ့ ရိုက်ဖို့အတွက်သုံးတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textbackslash{}xHH
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
eight-bit စာလုံးတွေကို hexadecimal value နဲ့ ရိုက်ဖို့အတွက်သုံးတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\uHHHH 
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
Unicode (ISO/IEC 10646) စာလုံးတွေကို hexadecimal value နဲ့
ရိုက်ဖို့သုံးပါတယ်။ (hexadecimal ဂဏန်း 4 လုံးအထိ)
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\UHHHHHHHH 
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
Unicode (ISO/IEC 10646) စာလုံးတွေကို hexadecimal value နဲ့
ရိုက်ဖို့သုံးပါတယ်။ (hexadecimal ဂဏန်း ၈ လုံးအထိ)
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\cx 
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
control ကီးနဲ့ တခြားကီးတစ်ခုခုကို တွဲရိုက်ဖို့ (control-x) အတွက်
သုံးပါတယ်။
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

bash command တွေနဲ့ escape sequence သုံးပုံတချို့ကို ဥပမာပေးပါမယ်။

က၊ ခ၊ ဂ ရဲ့ Unicode code နံပါတ်တွေက u1000, u1001 နဲ့ u1002 အသီးသီး
ဖြစ်ကြပါတယ်။\\
echo command နဲ့ က ခ ဂ ကို ရိုက်ပြချင်တဲ့အခါ၊ အောက်ပါအတိုင်း escape
sequence \u ကိုသုံးပြီး ရိုက်ခိုင်းလို့ ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}\PYZbs{}u1000 \PYZbs{}u1001 \PYZbs{}u1002\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
က ခ ဂ

    \end{Verbatim}

    jupyter notebook ရဲ့ bash kernel က တစ်ခါတလေမှာ မြန်မာစာလုံးတွေကို
သေသေချာချာမပြပေးနိုင်လို့ အောက်ပါ screen capture လုပ်ထားတဲ့ ပုံကို
ပါထည့်ပေးထားပါတယ်။

    

    ဒီနေရာ မှာ သိထားရမှာက echo command ရဲ့ -e option
ကိုပါတွဲသုံးရတယ်ဆိုရတာကိုပါ။\\
-e option မပါရင် စာလုံးတွေကို ဒီအတိုင်းပဲ ပြန်ရိုက်ပေး (literally print)
လုပ်ပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n+nb}{echo} \PY{l+s+s2}{\PYZdq{}\PYZbs{}u1000 \PYZbs{}u1001 \PYZbs{}u1002\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textbackslash{}u1000 \textbackslash{}u1001 \textbackslash{}u1002

    \end{Verbatim}

    ကွန်ပြူတာရဲ့ စပီကာကနေ သတိပေးတဲ့အနေနဲ့ bell အသံထုတ်ပေးချင်တဲ့အခါ၊ အထက်ပါ
ဇယားမှာ ရှင်းပြခဲ့တဲ့ အတိုင်း "\a" escape sequence ကိုသုံးပြီး
လုပ်ခိုင်းလို့ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}\PYZbs{}a \PYZbs{}a \PYZbs{}a\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
  

    \end{Verbatim}

    ဒီနေရာမှာ တယ်လီဖုန်းပုံ (သို့) လေးထောင့်ကွက်အနေနဲ့ ရိုက်ပြတာက၊ jupyter
notebook ကိုသုံးထားလို့၊ output ကိုမြင်သာအောင် ပုံအနေနဲ့ jupyter
notebook ကထုတ်ပေးတာ သာဖြစ်ပါတယ်။ တကယ်တမ်း linux ရဲ့ bash shell မှာ run
ရင် မြင်ရမှာ မဟုတ်ပါဘူး။

အသုံးများတဲ့ escape sequence တွေက သိထားသင့်ပါတယ်။ တကယ်တမ်းက escape
sequence တွေကို စကရင်မှာ ရိုက်ထုတ်တဲ့ ကိစ္စတင် မကပဲ၊ ဖိုင်ထဲကစာသားတွေ၊
user ကရိုက်ထည့်လိုက်လို့ ဝင်လာတဲ့ စာသားတွေမှာ ရှာဖွေတဲ့ ကိစ္စ၊
ဝင်ပြင်တဲ့ ကိစ္စတွေမှာလည်း သုံးနိုင်ပါတယ်။

အောက်ပါ ဥပမာက နဂို fileA မှာရှိတဲ့ space နေရာတွေမှာ \t ကိုသုံးပြီး
အစားထိုးတာပါ။\\
fileA မှာဘာစာကြောင်းတွေရှိသလဲ ဆိုတာကို cat နဲ့ ရိုက်ထုတ်ကြည့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} cat fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Mingalar bar!
I am fileA.
I was born in April.
My blood type is O.

    \end{Verbatim}

    space (\s) ကို tab (\t) နဲ့ အစားထိုးတာကို sed command နဲ့ လုပ်ကြည့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} cat ./fileA \PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}s/\PYZbs{}s/\PYZbs{}t/g\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Mingalar	bar!
I	am	fileA.
I	was	born	in	April.
My	blood	type	is	O.

    \end{Verbatim}

    ဒီနေရာမှာ s/\s/\t/g က Regular Expression ပါ။\\
ပထမဆုံး "s" က စာလုံးတွေ၊ စာကြောင်းတွေကို အစားထိုးချင်တဲ့အခါ သုံးတဲ့
"substitute လုပ်ပေးပါ" ဆိုတဲ့ အဓိပ္ပါယ်ပါ။\\
"\s" က space ကို ဆိုလိုပါတယ်။ "\t" က tab ကိုဆိုလိုပါတယ်။ နောက်ဆုံးက "g"
ကတော့ global အနေနဲ့ အလုပ်လုပ်ပေးပါလို့ ဆိုလိုပါတယ်။ "g" ကို နောက်ဆုံးမှာ
မထည့်ရင် စာကြောင်းတစ်ကြောင်းမှာ ပထမဆုံးတွေ့တဲ့ space ကိုပဲ tab နဲ့
အစားထိုးပေးပါလိမ့်မယ်။

အောက်ပါ ဥပမာက "g" မပါပဲ run တဲ့ အခါတွေ့ရမဲ့ output ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} cat ./fileA \PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}s/\PYZbs{}s/\PYZbs{}t/\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Mingalar	bar!
I	am fileA.
I	was born in April.
My	blood type is O.

    \end{Verbatim}

    sed command ရဲ့ သုံးပုံသုံးနည်းနဲ့ Regular Expression
ရဲ့သုံးပုံသုံးနည်းကို နောက်ပိုင်းမှာ ထပ်ရှင်းပြပါမယ်။

    \subsection{22. echo (display a line of
text)}\label{echo-display-a-line-of-text}

echo က စာကြောင်းကို မော်နီတာ စကရင်မှာ ရိုက်ပေးတဲ့ command ပါ။\\
Operating System (OS) တိုင်းလိုလိုမှာ အခြေခံကျတဲ့　command တစ်ခုအနေနဲ့
ပါဝင်ပြီး၊　ပရိုဂရမ်မင်း　ဘာသာစကားတွေမှာပါတဲ့　print, printf, cout,
writeln, puts တို့နဲ့　တူပါတယ်။　　

echo command ရဲ့ syntax ကတော့ အောက်ပါအတိုင်းဖြစ်ပါတယ်။\\
echo {[}option(s){]} {[}string(s){]}

အသုံးပြုပုံ　ဥပမာတချို့ကတော့　အောက်ပါအတိုင်း　ဖြစ်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n+nb}{echo} Hello Aliean!
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Hello Aliean!

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n+nv}{X}\PY{o}{=}\PY{l+m}{88}\PY{p}{;} \PY{n+nv}{Y}\PY{o}{=}\PY{l+m}{91}\PY{p}{;}
        \PY{n+nb}{echo} X is \PY{n+nv}{\PYZdl{}X} and Y is \PY{n+nv}{\PYZdl{}Y}.
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
X is 88 and Y is 91.

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}Who\PYZbs{}nare\PYZbs{}nyou\PYZbs{}n?\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Who
are
you
?

    \end{Verbatim}

    Escape sequences တွေကိုပါ စာရိုက်ခိုင်းတဲ့အခါမှာသုံးချင်ရင် အထက်မှာ
ပြထားတဲ့ အတိုင်း -e option ကို သုံးရပါတယ်။\\
နောက်ထပ် ဥပမာ တစ်ခုထပ်ပေးရင်၊ \t က TAB ကီးကို ကိုယ်စားပြုပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}Who\PYZbs{}tare\PYZbs{}tyou\PYZbs{}t?\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Who	are	you	?

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}I am a \PYZbs{}\PYZbs{} (backslash).\PYZbs{}nNice to see you!\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
I am a \textbackslash{} (backslash).
Nice to see you!

    \end{Verbatim}

    တကယ်လို့ ကျွန်တော်တို့ echo နဲ့ရိုက်ခိုင်းမဲ့ စာကြောင်းက ရှည်နေလို့
မော်နီတာစကရင်မှာ ကြည့်ရတာအဆင်ပြေအောင် နောက်လိုင်းတကြောင်းဆင်းပြီးတော့
ရိုက်ပြပေးစေချင်ရင် "" (backslash) ရိုက်ပြီး enter ကီးနှိပ်ရင်
နောက်တကြောင်းကို ဆင်းပေးပါလိမ့်မယ်။

ဒီနေရာမှာ သတိထားရမှာက "" နောက်မှာ space ကီး စတဲ့ တခြားစာလုံးတွေကို
မရိုက်မိစေပဲ၊ "" ကိုရိုက်ပြီးတာနဲ့ enter ကီးကို ခေါက်ပေးဖို့လိုအပ်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{n+nb}{echo} \PY{l+s+s2}{\PYZdq{}This is, this is, this is, this is, this is, this is \PYZbs{}}
         \PY{l+s+s2}{on two lines\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
This is, this is, this is, this is, this is, this is on two lines

    \end{Verbatim}

    shell (သို့) command prompt မှာ "`" (backtick) ကို သုံးပြီး command
တစ်ခုကို run ခိုင်းပြီးတော့ ရလာတဲ့ ရလဒ် (output) ကို ယူသုံးလို့ရပါတယ်။
ကိုယ်က run စေချင်တဲ့ command နဲ့ သူနဲ့ ဆိုင်တဲ့ option, parameter
စတာတွေကို backtick နှစ်ခုကြားမှာ ထည့်ပြီး run ခိုင်းတဲ့ ပုံစံပါ။

shell က main command ကို execute မလုပ်ခင်မှာ backtick
နှစ်ခုအတွင်းမှာရှိတဲ့ command ကို အရင်ဆုံး evaluate လုပ်တယ်။ ပြီးတော့မှ
ရလာတဲ့ ရလဒ်ကို main command ရဲ့ အစိတ်အပိုင်းတခုအဖြစ် ရိုက်ထုတ်ပြီး၊ main
command ကို run ပါတယ်။

အောက်ပါ ဥပမာက backtick နှစ်ခုကြားမှာ ရှိတဲ့ "date" command ကို အရင် run
ပြီးမှ ရလာတဲ့ ရက်စွဲကို echo က ရိုက်ထုတ်ပြတာကို လုပ်ပြတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n+nb}{echo} the date is \PY{l+s+sb}{`}date\PY{l+s+sb}{`}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
the date is 2017年 8月 26日 土曜日 10:52:09 JST

    \end{Verbatim}

    backtick ကို မသုံးပဲ \$(command) ဆိုတဲ့ ပုံစံလည်းရှိပါတယ်။\\
အောက်ပါ command ကို run ကြည့်ရင် backtick ကို သုံးခဲ့သလိုပဲ အတူတူ
အလုပ်လုပ်ပေးတာကို တွေ့ရပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{n+nb}{echo} the date is \PY{k}{\PYZdl{}(}date\PY{k}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
the date is 2017年 8月 26日 土曜日 10:52:05 JST

    \end{Verbatim}

    echo command ကို video text terminal တွေရဲ့ format, color, cursor
movement စတာတွေအတွက် သတ်မှတ်ထားတဲ့ ANSI (American National Standard
Institute) escape code တွေနဲ့ စာကြောင်းထဲမှာ တွဲသုံးပြီးတော့ ရိုက်ပေးမဲ့
စာလုံးတွေရဲ့ အရောင်၊ နောက်ခံအရောင်တွေကိုလည်း ပြောင်းလို့ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}38}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}\PYZbs{}u001b[32;1m Now GREEN text! \PYZbs{}u001b[0m Right? \PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-green-intense}{\textbf{ Now GREEN text! }} Right? 

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}\PYZbs{}u001b[44;1m Nyein \PYZbs{}u001b[41;1m Aye \PYZbs{}u001b[47;1m Thu \PYZbs{}u001b[42;1m is \PYZbs{}u001b[46;1m a \PYZbs{}u001b[43;2m girl.\PYZbs{}u001b[0m \PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\setlength{\fboxsep}{0pt}\colorbox{ansi-blue}{\textbf{ Nyein }\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-red}{\textbf{ Aye }\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-white}{\textbf{ Thu }\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-green}{\textbf{ is }\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-cyan}{\textbf{ a }\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{\textbf{ girl.}\strut} 

    \end{Verbatim}

    အထက်မှာ သုံးပြခဲ့တဲ့ echo command တွေမှာ ပါတဲ့ \u001b ဆိုတာက Escape
အတွက် သတ်မှတ်ထားတဲ့ Unicode Code နံပါတ်ဖြစ်ပါတယ်။\\
Unicode နံပါတ်တွေကို အမျိုးမျိုး သုံးပြီး echo နဲ့ terminal မှာ
ရိုက်ပြလို့ရပါတယ်။

မြန်မာဗျည်း ကကြီးကို echo command နဲ့ unicode escape sequence \u1000 ကို
သုံးပြီး terminal မှာ ရိုက်ကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}Unicode number U+1000 is \PYZbs{}\PYZdq{}\PYZbs{}U1000\PYZbs{}\PYZdq{} (a Myanmar consonant Ka Gyi).\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Unicode number U+1000 is "က" (a Myanmar consonant Ka Gyi).

    \end{Verbatim}

    Jupyter notebook ရဲ့ bash command output အနေနဲ့ မပြပေးနိုင်လို့
ပုံအနေနဲ့ ထည့်ပေးထားတာပါ။ terminal မှာ run ကြည့်ရင်အောက်ပါအတိုင်း
မြင်ရပါလိမ့်မယ်။

    

    Bayes' theorem ကို linux terminal မှာ အောက်ပါအတိုင်း echo command နဲ့
Unicode နံပါတ်တချို့ကို သုံးပြီး ရိုက်ကြည့်ပါ။\\
echo -e "\u2119(A\u007CB)=(\u2119(B\u007CA)\u2119(A))\u2215\u2119(B)"\\
ဒီနေရာမှာ \u2119 က Probability mesure "P" ရဲ့ unicode ပါ။\\
\u007C က conditional probability "\textbar{}" သင်္ကေတရဲ့ unicode
နံပါတ်ပါ။\\
အောက်ပါအတိုင်းမြင်ရပါလိမ့်မယ်။

    

    ဒီနေရာကနေစပြီး linux command တွေကို သုံးတဲ့ နေရာမှာတင်မက၊ programmering
လုပ်တဲ့အခါ၊ networking အလုပ်တွေ လုပ်တဲ့ အခါ၊ နေရာတိုင်းမှာ
ပုံစံအမျိုးမျိုးနဲ့သုံးကြတဲ့ wild card, brace expansion, redirection,
regular expression (RE) တွေကို concept ရအောင်၊ အကြမ်းမျဉ်းရှင်းပြပါမယ်။

    \subsection{23. Wild Card (*?) and Brace Expansion {[}...{]},
\{...\}}\label{wild-card-and-brace-expansion-...-...}

Linux/Unix မှာ ဖိုင်တွေအမြောက်အမြားနဲ့ အလုပ်လုပ်နိုင်ဖို့အတွက် wild card
နဲ့ brace expansion ဆိုတာကို သုံးပါတယ်။

\subsubsection{Wild Card}\label{wild-card}

\begin{itemize}
\item
  Question Mark Wild card ("?") က စာလုံး တစ်လုံးကို ကိုယ်စားပြုပါတယ်။
  ဖိုင်စနစ်က အသိအမှတ်ပြုထားတဲ့ ကြိုက်တဲ့ စာလုံးဖြစ်လို့ရပါတယ်။
\item
  Star wild card ("*") က စာလုံး အရေအတွက် သုည ကနေ အရေအတွက်
  အကန့်အသတ်မရှိတဲ့အထိ ကိုယ်စားပြုပါတယ်။ ကြိုက်တဲ့ စာလုံးဖြစ်လို့
  ရပါတယ်။\\
  တနည်းအားဖြင့် "*" က တခြား wild card တွေအားလုံးကိုပါ ကိုယ်စားပြုတယ်လို့
  ပြောလို့ရပါတယ်။
\end{itemize}

\subsubsection{Brace Expansion}\label{brace-expansion}

\begin{itemize}
\item
  Brace expansion {[}...{]} က လေးထောင့်ကွင်း အဖွင့် "{[}" သင်္ကေတ နဲ့
  အပိတ်ဖြစ်တဲ့ "{]}" သင်္ကေတ နှစ်ခုအကြားမှာ ရှာဖွေချင်တဲ့
  စာလုံးအတွဲလိုက်၊ ဘယ်စာလုံးကနေ ဘယ်စာလုံးအထိ ဆိုတာမျိုး ကို သတ်မှတ်ပြီး
  ရှာခိုင်းလို့ရပါတယ်။ ဘယ်စာလုံးကနေ ဘယ်စာလုံးရဲ့ အတွင်းမှာ ဆိုတာကိုတော့
  "-" dash စာလုံးနဲ့ ပိုင်းခြားပေးရပါတယ်။ ဥပမာ {[}a-z{]} ဆိုတာက a ကနေ z
  အတွင်းမှာရှိတဲ့ အင်္ဂလိပ်စာလုံး တစ်လုံးလို့ ဆိုလိုတာပါ။
  စာလုံးတွဲတွေကို တခုထက်မက လေးထောင့်ကွင်းအတွင်းမှာ ထည့်ပြီး
  ညွှန်းလို့ရပါတယ်။ ဥပမာ {[}A-Da-d0-5{]} ဆိုတာက {[}ABCDabcd012345{]} နဲ့
  သွားညီပါလိမ့်မယ်။ ဒါအပြင် လေးထောင့်ကွင်း အဖွင့် "{[}" နဲ့ အပိတ်ဖြစ်တဲ့
  "{]}" အကြားမှာ ဒီစာလုံး (သို့) ဒီစာလုံး ကို ရှာဖွေပေးပါဆိုတဲ့
  ပုံစံမျိုးလဲ သုံးနိုင်ပါတယ်။ ဥပမာ {[}137{]} ဆိုတဲ့ brace expansion က
  အင်္ဂလိပ်နံပါတ် 1 (သို့) 3 (သို့) 7 တစ်ခုခု လို့ ညွှန်းတာဖြစ်ပါတယ်။
\item
  Brace expansion \{...\} က တွန့်ကွင်း အဖွင့် "\{" သင်္ကေတနဲ့
  အပိတ်သင်္ကေတ "\}" နှစ်ခုအကြားမှာ ပေးလိုက်တဲ့ သတ်မှတ်ချက်ကို
  အခြေခံပြီး၊ စာလုံးတွေကို command line (သို့) shell script ရဲ့အတွင်းမှာ
  ထုတ်လုပ်ပေးနိုင်၊ အင်္ဂလိပ်လိုဆိုရင် generate လုပ်ပေးနိုင်ပါတယ်။
  တကယ်တမ်း အသုံးပြုတဲ့အခါမှာ brace expansion ရဲ့ ရှေ့မှာရှိတဲ့ စာလုံး
  (prefix) နဲ့ brace expansion ရဲ့ နောက်မှာရှိတဲ့ စာလုံး (suffix) တွေနဲ့
  ပေါင်းစပ်ပြီး ရိုက်ထုတ်ပေးလို့ အရမ်းအသုံးဝင်ပါတယ်။ ဘယ်စာလုံးကနေ
  ဘယ်စာလုံးအထိ ဆိုတာကို ".." နဲ့ ရေးပါတယ်။ ဥပမာ \{0..5\} လို့ရေးရင် 0 1
  2 3 4 5 ဆိုပြီး generate လုပ်ပေးပါလိမ့်မယ်။ တကယ်လို့ A\{0..3\}B
  လို့ရေးရင် A0B, A1B, A2B နဲ့ A3B ကို generate လုပ်ပေးပါလိမ့်မယ်။
  ဘယ်စာလုံးကနေ ဘယ်စာလုံးအထိ ဆိုတာမျိုး မဟုတ်ပဲ၊ စာလုံး တစ်လုံးချင်းစီ
  သပ်သပ် ဆိုရင်တော့ ကော်မာ "," နဲ့ ခြားပြီး ပေးပါတယ်။ ဥပမာ \{dog,
  flower, wine\} လို့ရေးပါတယ်။
\end{itemize}

တစ်ခု သိထားရမှာက လေးထောင့်ကွင်း၊ တွန့်ကွင်းတွေရဲ့ အတွင်းမှာ "?" နဲ့ "*"
wild card တွေကို ထည့်သုံးလို့　မရပါ။ bash shell က interpret
လုပ်ပေးနိုင်မှာ မဟုတ်ပါဘူး။

အထက်ပါရှင်းပြခဲ့တဲ့ wild card တွေကို အောက်ပါအတိုင်း terminal မှာ
စမ်းရိုက်ကြည့်ပါ။

\begin{verbatim}
final:
 Wild card စာလုံးတွေက shell တွေအပေါ်မှာ မူတည်ပြီး သတ်မှတ်ချက်တွေက မတူညီကြပါဘူး။ ဥပမာ bash shell မှာ သုံးတဲ့ wild card စာလုံးတွေအားလုံးက zsh shell မှာ အလုပ်လုပ်မှာ မဟုတ်ပါဘူး။ 
 
 Wild card နဲ့ ပတ်သက်ပြီး အထက်ပါရှင်းပြခဲ့တာကို သဘောပေါက်တယ်ရင် တကယ့်လက်တွေမှာလည်း အသုံးချနိုင်ပါလိမ့်မယ်။ သုံးလည်း သုံးစေချင်ပါတယ်။  
 နောက်ဆုံးအနေနဲ့ bash shell မှာသုံးတဲ့ wild card နဲ့ ပတ်သက်ပြီး အခြေခံကို အင်္ဂလိပ်လို အတိုရှင်းပြပါဆိုရင် အောက်ပါအတိုင်း ဖြစ်ပါလိမ့်မယ်။
 
 *  <code>&ast;</code> (matches anything)
 * ? (matches any single character) 
 * [xyz] (matches any of x, y, or z)
 * [a-d] (matches any character in the range a through d) 
\end{verbatim}

    လက်ရှိ ရောက်နေတဲ့ path မှာရှိတဲ့ ဖိုင်တွေကို list လုပ်ကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} ls
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
all-vi-info.txt  fileA         item-list                 otest
\textcolor{ansi-blue-intense}{\textbf{data1}}            fileB         linux-commands.ipynb      otest.tag
\textcolor{ansi-blue-intense}{\textbf{data2}}            fmt.out       linux-commands.ipynb.bak  otest.word
\textcolor{ansi-blue-intense}{\textbf{data3}}            \textcolor{ansi-blue-intense}{\textbf{folderA}}       ls.out                    \textcolor{ansi-blue-intense}{\textbf{screen}}
\textcolor{ansi-blue-intense}{\textbf{data4}}            \textcolor{ansi-blue-intense}{\textbf{folder-athit}}  my-news                   sorted-names
\textcolor{ansi-blue-intense}{\textbf{data5}}            \textcolor{ansi-blue-intense}{\textbf{folderB}}       newfile                   \textcolor{ansi-blue-intense}{\textbf{wildcard}}
echo             \textcolor{ansi-blue-intense}{\textbf{folder-new}}    news

    \end{Verbatim}

    Wild card "?" ကို စသုံးကြည့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} ls file?
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
fileA  fileB

    \end{Verbatim}

    နောက်ပုံစံတစ်မျိုး သုံးကြည့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} ls ????
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
echo  news

    \end{Verbatim}

    ? လေးခုပေးခဲ့တာဖြစ်လို့ စာလုံးလေးလုံးရှိတဲ့ ဖိုင်နာမည် news ကို
ရိုက်ထုတ်ပြပါတယ်။

    Wild card "*" ကို သုံးကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} ls file*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
fileA  fileB

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} ls f*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
fileA  fileB  fmt.out

folderA:
127-135.pdf

folder-athit:

folderB:
127-135.pdf  fileA  otest

folder-new:
\textcolor{ansi-blue-intense}{\textbf{folder-new}}

    \end{Verbatim}

    f"*" ဖြစ်တဲ့ အတွက်ကြောင့်၊ fနဲ့စတဲ့ဖိုင်၊ ဖိုလ်ဒါတွေကို
ရိုက်ထုတ်ပေးပါလိမ့်မယ်။ ဖိုလ်ဒါဆိုရင်တော့ အဲဒီဖိုလ်ဒါအတွင်းမှာရှိတဲ့
ဖိုင်တွေကိုပါ ရိုက်ထုတ်ပြပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n+nb}{cd} wildcard
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} ls *m*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
acknowledgements.txt  m  maik-khe.food.txt  matrix  mba.note.txt  superman

    \end{Verbatim}

    အထက်ပါ အမိန့် "*m*" က လက်ရှိဖိုလ်ဒါအောက်ရှေ့ကစချင်တာနဲ့ စ၊ "m"
စာလုံးပါပြီး နောက်မှာလည်း ဆုံးချင်တာနဲ့ ဆုံးတဲ့ ဖိုင်ကို ပြပေးပါလို့
ဆိုလိုပါတယ်။ ဒီနေရာမှာ သိထားရမှာက wild card * က ရှေ့မှာ ရှင်းပြခဲ့သလို
စာလုံးအရေအတွက် သုညကနေ အရေအတွက် အကန့်အသတ်မရှိတဲ့အထိ ကိုယ်စားပြု တာမို့၊ m
ရဲ့ ရှေ့မှာ ဘာစာလုံးမှမရှိတာ၊ m ရဲ့ နောက်မှာ ဘာစာလုံးမှမရှိတာလဲ
ပါဝင်ပါတယ်။ အဲဒါကြောင့် ဖိုင်နာမည် m လိုဖိုင်မျိုးကိုပါ ရိုက်ထုတ်ပြတာပါ။

Wild card "*" ကို echo command နဲ့ သုံးကြည့်ရအောင်။\\
echo * command နဲ့ လက်ရှိရှိနေတဲ့ ဖိုလ်ဒါအောက်က ဖိုင်တွေ၊
ဖိုလ်ဒါတွေအားလုံးကို ရိုက်ခိုင်းလို့ရပါတယ်။ ls command လိုပဲ
အလုပ်လုပ်ပေးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{n+nb}{echo} *
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
abstract.txt acknowledgements.txt city conclusion.txt graph1 Graph1 graph2 Graph2 graph3 Graph3 graph4 Graph4 graph5 hello.txt m maik-khe.food.txt matrix mba.note.txt superman

    \end{Verbatim}

    echo g* နဲ့ gနဲ့စတဲ့ ဖိုင်၊ ဖိုလ်ဒါတွေကို ရှာကြည့်လို့ရပါတယ်။ လက်ရှိ
ဖိုလ်ဒါpath မှာက gနဲ့စတဲ့ ဖိုလ်ဒါတွေပဲ ရှိလို့၊ ဖိုလ်ဒါတွေကိုပဲ
ရိုက်ထုတ်ပြပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{n+nb}{echo} g*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
graph1 graph2 graph3 graph4 graph5

    \end{Verbatim}

    echo ရဲ့ အဓိကအလုပ်က input လုပ်တဲ့ စာကြောင်းတွေ ကို ရိုက်ထုတ်ပြတာမို့လို့
ls command လို ဖိုင်တွေ၊ ဖိုလ်ဒါတွေရဲ့ အသေးစိတ်အချက်အလက်တွေကို
ပေးမှာမဟုတ်ပါဘူး။

Wild card ? နဲ့ * နှစ်ခုကို ပေါင်းပြီး သုံးတဲ့ ဥပမာတချို့ကတော့
အောက်ပါအတိုင်းပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}32}]:} ls ../o*.???
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
../otest.tag

    \end{Verbatim}

    အထက်ပါ "ls o*.???" က အင်္ဂလိပ်စာလုံး o (small o) နဲ့ စပြီး၊ ဖိုင်တွေရဲ့
အမျိုးအစားတွေကို ခွဲတဲ့နေရာမှာ သုံးလေ့ရှိကြတဲ့ "." (dot) လဲပါပြီး၊ အဲဒီ
. (dot) ရဲ့ နောက်မှာတော့ စာလုံးသုံးလုံးနဲ့ ဆုံးတဲ့ ဖိုင်၊ ဖိုလ်ဒါတွေ ကို
လက်ရှိဖိုလ်ဒါအောက်မှာ ရှာပေးပါလို့ ခိုင်းတဲ့ အမိန့်ပါ။

လက်ရှိဖိုလ်ဒါအောက်မှာရှိတဲ့ ဖိုင်တွေ၊ ဖိုလ်ဒါတွေရဲ့
နာမည်တွေအားလုံးအထဲမှာမှ ပေးလိုက် တဲ့ သတ်မှတ်ချက်ဖြစ်တဲ့ "o*.???"နဲ့
ကိုက်ညီတဲ့ "otest.tag" ဖိုင်ကို ရိုက်ထုတ်ပြတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}37}]:} ls \PYZhy{}lh /home/*/.bash\PYZus{}history
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
-rw------- 1 guest guest  21  8月 11 20:20 /home/guest/.bash\_history
-rw------- 1 lar   lar   28K  8月 11 19:58 /home/lar/.bash\_history

    \end{Verbatim}

    အထက်ပါ /home/*/ က home ဖိုလ်ဒါအောက်မှာ ရှိတဲ့ username နဲ့သိမ်းထားတဲ့
ဖိုလ်ဒါအားလုံးကို ညွှန်းတာပါ။ /.bash\_history က ပုံမှန်အားဖြင်မမြင်ရတဲ့
ဖွက်ထားတဲ့ဖိုင် (hidden file) ဖြစ်တဲ့ bash\_history (ရိုက်ခဲ့သမျှ bash
command တွေကိုသိမ်းထားတဲ့ ဖိုင်) ကို ပြောတာပါ။

Brace expansion တွေကို စမ်းသုံးကြည့်ကြရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}39}]:} ls graph\PY{o}{[}\PY{l+m}{1}\PYZhy{}5\PY{o}{]}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
graph1  graph2  graph3  graph4  graph5

    \end{Verbatim}

    အထက်ပါ command က ဖိုင်နာမည် graph1 ကနေ graph5 အထိကို ls နဲ့
ပြခိုင်းကြည့်တာပါ။\\
လက်ရှိဖိုလ်ဒါအောက်မှာ ရှိရင် ပြပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}40}]:} ls m\PY{o}{[}ab\PY{o}{]}*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
maik-khe.food.txt  matrix  mba.note.txt

    \end{Verbatim}

    အထက်ပါ command မှာ ပါတဲ့ "m{[}ab{]}*" က "m" နဲ့ စပြီး သူ့ရဲ့နောက်က "a"
စာလုံး (သို့) "b" စာလုံးက ကပ်လိုက်ပြီး၊ အဲဒီနောက်မှာတော့ ဘာပဲဖြစ်ဖြစ်
ဆိုတဲ့ အဓိပ္ပါယ်ရပါတယ်။ အဲဒါကြောင့် လက်ရှိဖိုလ်ဒါအောက်မှာ၊ အဲဒီ brase
expansion နဲ့ ကိုက်ညီတဲ့ maik-khe.food.txt ဖိုင်၊ matrix ဖိုင်နဲ့
mba.note.txt ဖိုင်တွေကို ရိုက်ပြပေးတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{n+nb}{echo} \PY{o}{\PYZob{}}Kachin,Kayah,Kayin,Chin,Mon,Rakhine,Shan\PY{o}{\PYZcb{}}\PY{l+s+se}{\PYZbs{} }State,
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Kachin State, Kayah State, Kayin State, Chin State, Mon State, Rakhine State, Shan State,

    \end{Verbatim}

    တစ်ခု သိထားရမှာက \{\} အတွင်းမှာ ရှိတဲ့ "," တွေရဲ့ နောက်မှာ
ပုံမှန်အင်္ဂလိပ်စာရိုက်သလိုမျိုး space ကီးကို ရိုက်ထည့်ရင်
အလုပ်မလုပ်ပေးဘူးဆိုတာကိုပါ။\\
State စာလုံးရဲ့　ရှေ့မှာရှိတဲ့　"~"က space ကိုရိုက်ပေးစေချင်လို့ escape
လုပ်ထားတာပါ။

    ".." နဲ့ ဘယ်စာလုံးကနေ ဘယ်စာလုံးအထိ၊ ဘယ်ဂဏန်းကနေ ဘယ်ဂဏန်းအထိ ဆိုပြီး
တိုးတဲ့အခါမှာ၊ ဘယ်နှစ်လုံးစီတိုးပေးပါဆိုတာကိုလည်း သတ်မှတ်ပေးလို့ရပါတယ်။
အောက်ပါ ဥပမာကို ကြည့်ကြရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}42}]:} \PY{n+nb}{echo} \PY{o}{\PYZob{}}\PYZhy{}10..10..2\PY{o}{\PYZcb{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
-10 -8 -6 -4 -2 0 2 4 6 8 10

    \end{Verbatim}

    အထက်ပါ ဥပမာကို နားလည်မယ်လို့ ထင်ပါတယ်။\\
-10 ကနေ +10 အကြား၊ +2 လုပ်ပါ လို့ခိုင်းထားတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}43}]:} \PY{n+nb}{echo} \PY{o}{\PYZob{}}z..a\PY{o}{\PYZcb{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
z y x w v u t s r q p o n m l k j i h g f e d c b a

    \end{Verbatim}

    အထက်ပါ brase expansion \{z..a\} က အင်္ဂလိပ်စာလုံး z ကနေ a အထိကို
ပြောင်းပြန်အစီအစဉ်အတိုင်းရိုက်ခိုင်းတာပါ။

    နောက်တစ်ချက် သိထားသင့်တာက brace expansion တွေက nested
လုပ်လို့ရတယ်ဆိုတာကိုပါ။\\
Nested လုပ်တယ်ဆိုတာက brace expansion တစ်ခုရဲ့ အတွင်းမှာ နောက်ထပ် တစ်ခြား
brace expansion တစ်ခုကိုထည့်ရေးတာကို ပြောတာပါ။\\
အောက်ပါ ဥပမာကို ကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}44}]:} \PY{n+nb}{echo} \PY{o}{\PYZob{}}a\PY{o}{\PYZob{}}\PY{l+m}{1}..3\PY{o}{\PYZcb{}},b\PY{o}{\PYZob{}}\PY{l+m}{1}..3\PY{o}{\PYZcb{}},c\PY{o}{\PYZob{}}\PY{l+m}{1}..3\PY{o}{\PYZcb{}}\PY{o}{\PYZcb{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
a1 a2 a3 b1 b2 b3 c1 c2 c3

    \end{Verbatim}

    အထက်ပါ ဥပမာမှာ အပြင်ဘက်အကျဆုံး brace expansion \{\} ရဲ့ အတွင်းမှာ
\{1..3\} ဆိုတဲ့ brace expansion ကို သုံးခါ ထည့်သုံးပြထားတာပါ။\\
output ကိုကြည့်ချင်းအားဖြင့် ဘယ်လိုအလုပ်လုပ်သွားတယ်ဆိုတာကို
နားလည်ပါလိမ့်မယ်။\\
ဒီနေရာမှာလည်း ထပ်သတိပေးချင်တာက၊ "," ရဲ့နောက်မှာ space မရိုက်မိဖို့ပါ။

    bash shell မှာ အလုပ်လုပ်တဲ့အခါ "ဒီစာလုံးတွေမဟုတ်တဲ့"၊
တစ်ခါတစ်လေမှာကျတော့ "ဒီစာလုံးကနေ ဒီစာလုံးကြား မဟုတ်တဲ့" ဆိုတဲ့
သတ်မှတ်ချက်မျိုးကို သတ်မှတ်ချင်တဲ့အခါ၊ brace expansion
လေးထောင့်ကွင်းအဖွင့် သင်္ကေတ "{[}" ရိက်ပြီးတာနဲ့ ! (exclamation mark)
(သို့) \^{} (caret) ကိုရိုက်ပြီး အဲဒီနောက်မှာ စာလုံးတွေကို ရိုက်ပြီး
သုံးလေ့ရှိပါတယ်။

ဥပမာ rm {[}!0-9{]}* ဆိုရင် နံပါတ်နဲ့ မစတဲ့ ဖိုင်တွေအားလုံးကို
ဖျက်ပေးပါလို့ ခိုင်းတာပါ။\\
(ဒီ command ကို သတိထားပြီးသုံးပါ။ လက်ရှိရောက်နေတဲ့ path အောက်မှာရှိတဲ့၊
နံပါတ်နဲ့ မစတဲ့ ဖိုင်တွေအားလုံးကို ဖျက်သွားပါလိမ့်မယ်။)

! ကို စမ်းသုံးပြပါမယ်။\\
လက်ရှိ ရောက်နေတာက /home/ye/tool4all/linux-cmd/wildcard/
ဖိုလ်ဒါအောက်မှာပါ။\\
အဲဒီ ဖိုလ်ဒါအောက်မှာ ဖိုင်တချို့ကို ကျွန်တော်ကြိုပြင်ထားပါတယ်။
အဲဒီဖိုင်တွေအားလုံးအထဲကနေ G (သို့) g နဲ့ စတဲ့ ဖိုင်တွေအားလုံးကို list
လုပ်ကြည့်ပါမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}45}]:} ls \PY{o}{[}Gg\PY{o}{]}*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
graph1  Graph1  graph2  Graph2  graph3  Graph3  graph4  Graph4  graph5

    \end{Verbatim}

    အထက်ပါ output အတိုင်း အင်္ဂလိပ်စာလုံး G အကြီး၊ g အသေးနဲ့ စတဲ့ဖိုင်တွေကို
မြင်ရပါလိမ့်မယ်။\\
ဒီတစ်ခါတော့ ပြောင်းပြန် G (သို့) g နဲ့မစတဲ့ ဖိုင်တွေကိုပဲ ပြပေးပါဆိုပြီး
{[}!Gg{]}　wild card ကို သုံးပြီးလုပ်ခိုင်းပါမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}46}]:} ls \PY{o}{[}!Gg\PY{o}{]}*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
abstract.txt          conclusion.txt  maik-khe.food.txt  superman
acknowledgements.txt  hello.txt       matrix
city                  m               mba.note.txt

    \end{Verbatim}

    ! (exclamation mark) အစား \^{} (ငaret) ကိုလည်း သုံးလို့ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}47}]:} ls \PY{o}{[}\PYZca{}Gg\PY{o}{]}*
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
abstract.txt          conclusion.txt  maik-khe.food.txt  superman
acknowledgements.txt  hello.txt       matrix
city                  m               mba.note.txt

    \end{Verbatim}

    အခုလောက်ဆိုရင် wilid card　နဲ့　ပတ်သက်ပြီး　concept ကတော့
ရသွားလောက်ပါပြီ။

    \subsection{24. Piping and Redirection}\label{piping-and-redirection}

ပုံမှန် အားဖြင့် ကျွန်တော်တို့က command တွေကို ကီးဘုတ်ကနေရိုက်ထည့်ပြီး၊
ရလဒ် (output) ကို မော်နီတာမှာ ပြပါတယ်။\\
Linux/Unix မှာ input/output ကို အောက်ပါအတိုင်း STDIN (0), STDOUT (1),
STDERR (2) ဆိုပြီး သတ်မှတ်ထားပါတယ်။

ဒီနေရာမှာ STDIN ရဲ့　default setting (ကျွန်တော်တို့က ဘာမှမညွှန်ကြားရင်)
က ကီးဘုတ်ပါ။ ကီးဘုတ်က ဝင်လာတဲ့ command (သို့) input ကို ဖတ်တယ်။\\
STDOUT ရဲ့ default setting က မော်နီတာပါ။ ပရိုဂရမ်ရဲ့ ရလဒ်（output）ကို
မော်နီတာမှာ ပြပေးတယ်။\\
STDERR ရဲ့ default setting က မော်နီတာပါ။ ပရိုဂရမ် run နေတုန်းမှာ error
(အမှာအယွင်းတစ်ခုခု ဖြစ်ခဲ့ရင်) ရှိရင် မော်နီတာမှာ ပြပေးမယ်။

ကျွန်တော်တို့က လိုအပ်တဲ့ အခါမှာ STDIN, STDOUT, STDERR တွေကို
ပြောင်းပေးလို့ရပါတယ်။ အဲဒီအလုပ်ကို အင်္ဂလိပ်လို redirection လုပ်တယ်လို့
ခေါ်ပါတယ်။\\
လက်တွေ့မှာ အဓိကအသုံးများတာက STDOUT, STDERR ရဲ့ output တွေကို ဖိုင်တွေမှာ
ရေးခိုင်းတာမျိုးပါ။\\
ဥပမာ ls command ကထွက်လာတဲ့ output ကို ls.out ဆိုတဲ့
ဖိုင်မှာသိမ်းချင်တယ်ဆိုရင် အောက်ပါအတိုင်း "\textgreater{}" (greather
than) သင်္ကေတ နဲ့ ညွှန်းပါတယ်။ redirection လုပ်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}48}]:} ls \PYZgt{} ls.out
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}49}]:} cat ls.out
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
abstract.txt
acknowledgements.txt
city
conclusion.txt
graph1
Graph1
graph2
Graph2
graph3
Graph3
graph4
Graph4
graph5
hello.txt
ls.out
m
maik-khe.food.txt
matrix
mba.note.txt
superman

    \end{Verbatim}

    ls.out ဖိုင်က မရှိသေးရင် ဖိုင်အသစ် ရေးပေးပါတယ်။\\
တခုသတိထားရမှာက ls.out ဖိုင်က ရှိပြီးသားဆိုရင်၊ အရင်ရှိပြီးသားဖိုင် ကို
ထပ်ရေးတာ (overwrite) ဖြစ်လို့၊ အရင် ls.out မှာရှိပြီးသား
အချက်အလက်တွေအားလုံး ပျက်သွားမယ် ဆိုတာကိုပါ။

သိထားရမှာက ပရိုဂရမ်ရဲ့ output ကို ဖိုင်မှာ ရေးပေးပါလို့ ညွှန်းပေမဲ့၊
ပုံမှန်အားဖြင့် STDERR ရဲ့ error message ကိုတော့ မော်နီတာဆီကို
ပို့ပေးပါတယ်။\\
အဲဒါက ဘာ့ကြောင့်လဲ ဆိုရင် error message ကို ကွန်ပြူတာသုံးနေတဲ့ user က
မမြင်ရရင် အဆင်မပြေနိုင်ဘူးလေ။\\
STDERR ရဲ့ error message ကိုပဲ ဖိုင်မှာ သိမ်းချင်ရင်၊ "2\textgreater{}"
ကိုသုံးပြီး redirection လုပ်လို့ရပါတယ်။

Redirection သင်္ကေတတွေအားလုံးကိုတော့ အောက်ပါအတိုင်း ဇယားနဲ့ ပြသထားပါတယ်။

\begin{longtable}[c]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.21\columnwidth}\raggedright\strut
Redirection သင်္ကေတ
\strut\end{minipage} &
\begin{minipage}[b]{0.73\columnwidth}\raggedright\strut
အလုပ်လုပ်ပုံ
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textless{}
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
STDIN ကို ကီးဘုတ်ကနေမဟုတ်ပဲ၊ ဖိုင်ကနေ ပေးဖို့အတွက် အသုံးပြုပါတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textgreater{}
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
STDOUT ကို ဖိုင်မှာရေးပေးဖို့အတွက် အသုံးပြုပါတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textgreater{}\textgreater{}
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
STDOUT ကို ရှိနေပြီးသား ဖိုင်ရဲ့ နောက်ဆုံးကနေဝင်ရေးပေးဖို့
အသုံးပြုပါတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textgreater{}\&
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
STDERR ကနေပေးတဲ့ error message ကိုလည်း ဖိုင်မှာရေးပေးစေချင်ရင်
အသုံးပြုပါတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
\textgreater{}\textgreater{}\&
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
\textgreater{}\& redirection ရဲ့ \textgreater{}\textgreater{} ပါ။
ရှိပြီးသားဖိုင်ရဲ့ နောက်ဆုံးမှာ ဝင်ရေးပေးဖို့ အသုံးပြုပါတယ်။
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.21\columnwidth}\raggedright\strut
2\textgreater{}
\strut\end{minipage} &
\begin{minipage}[t]{0.73\columnwidth}\raggedright\strut
ပရိုဂရမ်ရဲ့ output မပါပဲ၊ STDERR ရဲ့ error message ကိုပဲ
ဖိုင်မှာရေးပေးစေချင်တဲ့ အခါ အသုံးပြုပါတယ်။
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    Redirection အသုံးပြုပုံကို ဥပမာ တချို့နဲ့ ရှင်းပြပါမယ်။\\
ls \$ ဆိုပြီး run ကြည့်ပါ။\\
\$ ဆိုတဲ့ ဖိုင်၊ ဖိုလ်ဒါကို ရှာမတွေ့ဘူးဆိုပြီးတော့ error message ကို
မော်နီတာမှာ ရိုက်ပြပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}51}]:} ls \PYZdl{}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
ls: cannot access '\$': No such file or directory

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} sort \PYZgt{} sorted\PYZhy{}names \PY{l+s}{\PYZlt{}\PYZlt{}EOF}
        \PY{l+s}{\PYZgt{} Kyaw Kyaw Moe}
        \PY{l+s}{\PYZgt{} Zaw Zaw}
        \PY{l+s}{\PYZgt{} Mg Mg}
        \PY{l+s}{\PYZgt{} Hla Hla}
        \PY{l+s}{\PYZgt{} Mya Mya}
        \PY{l+s}{\PYZgt{} Blue Ma}
        \PY{l+s}{\PYZgt{} Toe Toe}
        \PY{l+s}{\PYZgt{} Aye Mya}
        \PY{l+s}{\PYZgt{} EOF}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} cat sorted\PYZhy{}names
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Aye Mya
Blue Ma
Hla Hla
Kyaw Kyaw Moe
Mg Mg
Mya Mya
Toe Toe
Zaw Zaw

    \end{Verbatim}

    Piping ဆိုတာကတော့ ပရိုဂရမ်တခုရဲ့ output ကို နောက် ပရိုဂရမ်တခုကို
လက်ဆင့်ကမ်းတာကို ဆိုလိုတာပါ။\\
"\textbar{}" (pipe character) ကို သုံးပါတယ်။ ရေတွေကို ရေပိုက်တခုနဲ့
တစ်နေရာကနေ၊ အခြားတစ်နေရာကို ပို့ပေးတဲ့ ပုံစံမျိုး အလုပ်လုပ်ပါတယ်။

ဥပမာ /dev ဖိုလ်ဒါအောက်မှာ ရှိတဲ့ device နဲ့ပတ်သက်တဲ့ ဖိုင်တွေကို ls
command ကိုသုံး -l option နဲ့ တစ်ကြောင်းချင်းစီရိုက်ခိုင်းပြီး ထွက်လာတဲ့
output စာကြောင်းတွေကို "\textbar{}" နဲ့ wc command ဆီကို လက်ဆင့်ကမ်းပြီး
စာကြောင်းဘယ်လောက်ရှိသလဲ ရေတွက်ခိုင်းတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} ls \PYZhy{}1 /dev \PY{p}{|} wc
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
    213     213    1354

    \end{Verbatim}

    အထက်ပါ wc command ကထွက်လာတဲ့ output ကနေ /dev ဖိုလ်ဒါအောက်မှာ device နဲ့
ပတ်သက်တဲ့ဖိုင် စုစုပေါင်း ၂၁၃ ဖိုင် ရှိတယ်ဆိုတာကို သိနိုင်ပါတယ်။\\
(ဒီနံပါတ်အရေအတွက် က ကွန်ပြူတာတစ်လုံးနဲ့ တစ်လုံး တူမှာ မဟုတ်ပါဘူး)

ဒီလို piping မလုပ်ပဲ၊ ls command ကနေထွက်လာတဲ့ ရလဒ်ကို ဖိုင်တစ်ဖိုင်မှာ
သိမ်း၊ ပြီးတော့မှာ အဲဒီဖိုင်ကို wc command ကို သုံးပြီး
ဘယ်နှစ်ဖိုင်ရှိသလဲဆိုတာကို ရေတွက်လို့လည်းရပါတယ်။ ဒါပေမဲ့ ဖိုင်အနေနဲ့
သိမ်းထားဖို့ မလိုအပ်ရင် memory ပေါ်မှာပဲ piping လုပ်ပြီး run
ရင်ပိုပြီးတော့ မြန်ဆန်ပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}Yangon \PYZbs{}nMandalay \PYZbs{}nNaypyidaw \PYZbs{}nMawlamyine \PYZbs{}nBago \PYZbs{}nPathein \PYZbs{}nPyay \PYZbs{}nMonywa \PYZbs{}nMeiktila \PYZbs{}nSittwe \PYZbs{}nMyeik \PYZbs{}nTaunggyi\PYZdq{}} \PY{p}{|} sort \PYZgt{} city
\end{Verbatim}

    အထက်ပါ command က echo နဲ့ မြန်မာနိုင်ငံရဲ့ မြို့နာမည်တွေကို
ရိုက်ထုတ်ခိုင်းပြီး ထွက်လာတဲ့ output ကို sort command ကိုလက်ဆင့်ကမ်းပြီး
အက္ခရာစဉ်လိုက် စီခိုင်းပါတယ်။\\
sort command က စီပေးလိုက်တဲ့ output ကို redirection သင်္ကေတ တစ်ခုဖြစ်တဲ့
\textgreater{} (greather than) ကိုသုံးပြီး city ဆိုတဲ့ ဖိုင်မှာ
သိမ်းခိုင်းပါတယ်။\\
city ဖိုင်ထဲမှာ ဘယ်လို ရှိနေတယ်ဆိုတာကို အောက်ပါအတိုင်း cat command နဲ့
ရိုက်ကြည့်ပါမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} cat city
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Bago 
Mandalay 
Mawlamyine 
Meiktila 
Monywa 
Myeik 
Naypyidaw 
Pathein 
Pyay 
Sittwe 
Taunggyi
Yangon 

    \end{Verbatim}

    နောက်ထပ် ဥပမာတစ်ခုအနေနဲ့ ရှေ့မှာလေ့လာခဲ့တဲ့ "head" နဲ့ "tail" command
နှစ်ခုကို pipe နဲ့ပေါင်းသုံးတာကို ပြပါမယ်။ ကျွန်တော်တို့
မြန်မာစာကြောင်းတွေရဲ့ POS tag တွေချည်းပဲသိမ်းထားတဲ့ otest.tag ဖိုင်မှ
စာကြောင်း ၂၀၁ ကနေ ၂၀၅ အထိ ရိုက်ထုတ်ခိုင်းမယ်ဆိုရင် အောက်ပါအတိုင်း
command ပေးလို့ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} head \PYZhy{}n \PY{l+m}{205} ./otest.tag \PY{p}{|} tail \PYZhy{}n \PY{l+m}{5}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
n adj n part v part part punc
n n ppm pron ppm n v ppm punc
v part part pron ppm v part punc
n n n n ppm n v n n ppm adj v n part v conj n adv v ppm punc
conj n n ppm n conj v part v conj v ppm punc

    \end{Verbatim}

    piping က command နှစ်ခုအကြားမှာပဲ လုပ်တာ မဟုတ်ပါဘူး။ command တွေ
အများကြီးကို တစ်ခါတည်း piping လုပ်ပြီး သုံးလို့ရပါတယ်။ အောက်ပါ ဥပမာက

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} cat ./otest.tag \PY{p}{|} tr \PY{l+s+s1}{\PYZsq{} \PYZsq{}} \PY{l+s+s1}{\PYZsq{}\PYZbs{}n\PYZsq{}} \PY{p}{|} sort \PY{p}{|} uniq \PYZhy{}c \PY{p}{|} awk \PY{l+s+s1}{\PYZsq{}\PYZob{} print \PYZdl{}2 \PYZdq{} \PYZdq{} \PYZdl{}1\PYZcb{}\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
abb 46
adj 608
adv 243
conj 1013
fw 236
int 5
n 5907
num 380
part 4189
part\_neg 138
ppm 3431
pron 253
punc 1429
sb 25
tn 211
v 2838

    \end{Verbatim}

    \subsection{26. Regular Expression (RE or
regex)}\label{regular-expression-re-or-regex}

Regular Expression (RE) က အလွယ်ဆုံးရှင်းပြရရင် စာလုံးတွေ၊ စာကြောင်းတွေ၊
ဖိုင်တွေ၊ ဘာသာစကားတွေနဲ့ ပတ်သက်ပြီး ရှာဖွေတဲ့နေရာ၊ ဝင်ပြင်တဲ့နေရာတွေမှာ
အင်မတန်ကို အရေးပါတဲ့ သတ်မှတ်ချက်တစ်ခု၊ ဘာသာစကားတစ်ခုပါ။

အင်္ဂလိပ်လို ပြောရင်တော့ text processing (သို့) pattern recognition
လို့ခေါ်ပါတယ်။ အဲဒီ text processing, pattern recognition အလုပ်တွေမှာ RE
က အဓိကကျတဲ့ အခန်းကဏ္ဍကပါဝင်ပါတယ်။ ကွန်ပြူတာ application တွေမှာလဲ
နေရာပေါင်းစုံမှာကို အသုံးပြုပါတယ်။ ဥပမာ အနေနဲ့ word processor တွေကနေ
database application, search engine စသည်ဖြင့်၊ စသည်ဖြင့်။ ဒါ့အပြင် RE က
programming languages (eg. Java and JavaScript, Visual Basic and
VBScript, C, C++, C\#, Perl, Python, Ruby, PHP, elisp, sed, awk etc.)
တွေရဲ့ အစိတ်အပိုင်း တစ်ပိုင်းအဖြစ်ပါဝင်ပြီး ကောင်းကောင်း အသုံးချတတ်ရင်၊
တကယ့်ကို powerful tool တစ်ခုပါ။

RE ကို တကယ်သိဖို့၊ ကိုယ်လိုချင်တဲ့ စာကြောင်းတွေ၊
စကားလုံးအစိတ်အပိုင်းတွေကို ဆွဲထုတ်ယူနိုင်ဖို့ အထိက အချိန်ယူလေ့လာရပါတယ်။
လက်တွေ့သုံးရင်းနဲ့ လေ့လာရတယ်ဆိုရင် ပိုမှန်ပါတယ်။ ကျွန်တော် ဒီနေရာမှာလည်း
RE ဆိုတာက ဘာလဲဆိုတာသိအောင်၊ မိတ်ဆက်အနေနဲ့ အသုံပြုပုံ အချို့ကို
ရှင်းပြရင်း၊ concept ရဖို့ကို ရည်ရွယ်ပါတယ်။ ကျွန်တော်ကိုယ်တိုင်လည်း RE က
မသိသေးတာတွေအများကြီးပါ။ တကယ် RE ကိုစိတ်ဝင်စားလို့ သီအိုရီပိုင်းကို
ပိုသိချင်ရင် စာအုပ်တွေဖတ်၊ လက်တွေ့ကြုံရတဲ့ text processing ပြဿနာတွေကို
အမျိုးမျိုး စမ်းသပ်သုံးကြည့်မှသာ ကျွမ်းကျင်လာပါလိမ့်မယ်။

    \subsubsection{Characters}\label{characters}

\begin{longtable}[c]{@{}llll@{}}
\toprule
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
သင်္ကေတ
\strut\end{minipage} &
\begin{minipage}[b]{0.15\columnwidth}\raggedright\strut
အလုပ်လုပ်ပုံ
\strut\end{minipage} &
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
ဥပမာ RE
\strut\end{minipage} &
\begin{minipage}[b]{0.10\columnwidth}\raggedright\strut
ဥပမာ RE နဲ့ ကိုက်သောရလဒ်
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\textbackslash{}d
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
၀ ကနေ ၉ အတွင်းက ဂဏန်းတစ်လုံး
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
TV\_Channel\_\textbackslash{}d\textbackslash{}d
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
Watching {TV\_Channel\_17}.
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\textbackslash{}D
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
ဂဏန်းတစ်လုံး မဟုတ်
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\textbackslash{}D
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
{Give me version} 0{.}9{!}
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\textbackslash{}w
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
စာလုံးတစ်လုံး (သို့) ဂဏန်းတစ်လုံး (သို့) underscore "\_" \textbar{}
\textbackslash{}w\textbackslash{}w\textbackslash{}w \textbar{} {Thi}s is
{versio}n 0.9! \textbar{} \textbar{} \textbackslash{}W \textbar{}
\textbackslash{}w မဟုတ်သော စာလုံးတစ်လုံး \textbar{}
\textbackslash{}W\textbackslash{}W\textbackslash{}W\textbackslash{}W
\textbar{} Do you know +-\emph{\%? \textbar{} \textbar{}
\textbackslash{}s \textbar{} whitespace စာလုံး (space, tab, newline,
carriage return, vertical tab) \textbar{} Mg\textbackslash{}sMg
\textbar{} {Mg Mg} and Ma Ma! \textbar{} \textbar{} \textbackslash{}S
\textbar{} whitespace မဟုတ်တဲ့ စာလုံးတစ်လုံး \textbar{}
\textbackslash{}S\textbackslash{}S\textbackslash{}S\textbackslash{}S
\textbar{} I {love} {Aiki}do! \textbar{} \textbar{} . \textbar{}
ဘာစာလုံးမဆို (သို့သော် စာကြောင်းဖြတ်တာနဲ့ မပတ်သတ်သော စာလုံး) \textbar{}
L.. \textbar{} Working at AI {Lab}. \textbar{} \textbar{}
\textbackslash{} \textbar{} အထူးစာလုံး (ဥပမာ RE
ကယူသုံးထားသောစာလုံးများ)တွေကို Escape လုပ်တဲ့အခါသုံးသော သင်္ကေတ
\textbar{}
\textbackslash{}.\textbackslash{}}\textbackslash{}?\textbackslash{}\^{}\textbackslash{}\(\\{\\( | .*?^\)\{(
\textbar{}
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    \subsubsection{Quantifiers}\label{quantifiers}

\begin{longtable}[c]{@{}llcll@{}}
\toprule
အရေအတွက် သတ်မှတ်ချက် သင်္ကေတ & အလုပ်လုပ်ပုံ & ဥပမာRE & ဥပမာ RE နဲ့
ကိုက်သောရလဒ်\tabularnewline
\midrule
\endhead
+ & တစ်ခု (သို့) တစ်ခုထက်ပို & x+ & xx (or) xxxxx (or)
xxxxxxxxxx\tabularnewline
* & သုည (သို့) တစ်ခုထက်ပို & x\emph{y}z* & xyz (or) xxyzzzzz (or)
xxxyyyzzz\tabularnewline
? & သုည (သို့) တစ်ခု & x? & x (or) xx\tabularnewline
\{3\} & သုံးခါတိတိ & \w{3} & abc (or) xyz (or) aaa\tabularnewline
\{2,5\} & နှစ်ခါ ကနေ ၅ခါအတွင်း & \d{2,5} & 111 (or) 1223 (or)
123456\tabularnewline
\{2,\} & နှစ်ခါ နှင့် အထက် & \w{2,} & pro (or) program (or)
programming\tabularnewline
\bottomrule
\end{longtable}

    \subsubsection{Whitespace}\label{whitespace}

\begin{longtable}[c]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.17\columnwidth}\raggedright\strut
သင်္ကေတ
\strut\end{minipage} &
\begin{minipage}[b]{0.16\columnwidth}\raggedright\strut
သတ်မှတ်ချက်
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\t 
\strut\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
Tab စာလုံးကို ကိုယ်စားပြုတဲ့ စာလုံးတစ်လုံး
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\r 
\strut\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
Carriage return ကို ကိုယ်စားပြုတဲ့ စာလုံးတစ်လုံး
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\n 
\strut\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
Line feed ကို ကိုယ်စားပြု ( Linux OS မှာစာကြောင်း
အောက်တစ်ကြောင်းဆင်းဖို့အတွက်သုံး) တဲ့စာလုံး တစ်လုံး
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\r\n 
\strut\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
Windows OS မှာသုံးတဲ့ Line feed စာလုံး
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\h 
\strut\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
horizontal whitespace စာလုံးတစ်လုံး (e.g. Tab, space )
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\b 
\strut\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
backspace စာလုံး တစ်လုံး
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\v | vertical whitespace စာလုံး တစ်လုံး ( ဥပမာ line feed, carriage
return, vertical tab, form feed etc.)
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\N 
\strut\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
line break မဟုတ်တဲ့ စာလုံး တစ်လုံး
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\H 
\strut\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
horizontal whitespace မဟုတ်တဲ့ စာလုံး တစ်လုံး
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\V 
\strut\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}\raggedright\strut
vertical whitespace မဟုတ်တဲ့ စာလုံး တစ်လုံး
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    \subsubsection{Character Classes}\label{character-classes}

\begin{longtable}[c]{@{}llll@{}}
\toprule
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
သင်္ကေတ
\strut\end{minipage} &
\begin{minipage}[b]{0.15\columnwidth}\raggedright\strut
အလုပ်လုပ်ပုံ
\strut\end{minipage} &
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
ဥပမာ RE
\strut\end{minipage} &
\begin{minipage}[b]{0.10\columnwidth}\raggedright\strut
ဥပမာ RE နဲ့ ကိုက်သောရလဒ်
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}...{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
လေးထောင့်ကွင်းနှစ်ခုအတွင်းက စာလုံးတစ်လုံး
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}ABC{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
A (or) B (or) C
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}x-y{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
x ကနေ y ကြားထဲမှာ ရှိသော စာလုံးတစ်လုံး
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}A-E{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
A (or) B (or) C (or) D (or) E
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}\^{}{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
လေးထောင့်ကွင်း နှစ်ခုအတွင်းမှာ ရှိနေတဲ့ စာလုံးတွေထဲက မဟုတ်တဲ့ စာလုံး
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}\^{}xyz{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
a (or) b (or) k
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}\^{}x-y{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
x ကနေ y ကြားထဲမှာ ရှိမနေသော စာလုံး တစ်လုံး
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}\^{}0-7{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
8 (or) 9
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}\xnn{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
hexadecimal နံပါတ် nn နဲ့ညီမျှတဲ့ စာလုံး တစ်လုံး
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}\x41\x42\x43{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
A (or) B (or) C
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}\uFFFF{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
Unicode နံပါတ် FFFF နဲ့ ညီမျှတဲ့ စာလုံး တစ်လုံး
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}\u1000{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
က
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    \subsubsection{Anchors and Boundaries}\label{anchors-and-boundaries}

\begin{longtable}[c]{@{}llll@{}}
\toprule
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
သင်္ကေတ
\strut\end{minipage} &
\begin{minipage}[b]{0.15\columnwidth}\raggedright\strut
အလုပ်လုပ်ပုံ
\strut\end{minipage} &
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
ဥပမာ RE
\strut\end{minipage} &
\begin{minipage}[b]{0.10\columnwidth}\raggedright\strut
ဥပမာ RE နဲ့ ကိုက်သောရလဒ်
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\^{}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
စာကြောင်း တစ်ကြောင်းရဲ့ အစ (ဒီနေရာမှာ စာကြောင်းတစ်ကြောင်းဆိုတာက
multiline mode ပါ ပါဝင်တယ်)
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\^{}This
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
{This} and that.
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\$
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
စာကြောင်း တစ်ကြောင်းရဲ့ အဆုံး (ဒီနေရာမှာ စာကြောင်း တစ်ကြောင်းဆိုတာက
multiline mode ပါ ပါဝင်တယ်)
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
တယ်\$
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
စာကြိုးစား{တယ်}
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\b
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
စာလုံးတစ်လုံးရဲ့ အဆုံး (RE အင်ဂျင်အများစုက ASCII စာလုံးတွေကို
အခြေခံထားတာဖြစ်လို့ မြန်မာစာအတွက် က အဆင်မပြေတာတွေရှိပါတယ်။) နောက်တစ်ချက်
က ဒီ \b က character class အနေနဲ့ သုံးတဲ့ အခါမှာတော့ backspace ဖြစ်ပါတယ်။
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\ba\w*\b
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
Who {am} I?
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\B 
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
စာလုံးတစ်လုံးရဲ့ အဆုံးမဟုတ်
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
\Bo\B 
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
quick br{o}wn f{o}x jump over the lazy d{o}g
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    \subsubsection{POSIX Classes}\label{posix-classes}

\begin{longtable}[c]{@{}llll@{}}
\toprule
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
သင်္ကေတ
\strut\end{minipage} &
\begin{minipage}[b]{0.15\columnwidth}\raggedright\strut
အလုပ်လုပ်ပုံ
\strut\end{minipage} &
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
ဥပမာ RE
\strut\end{minipage} &
\begin{minipage}[b]{0.10\columnwidth}\raggedright\strut
ဥပမာ RE နဲ့ ကိုက်သောရလဒ်
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}:alpha:{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
ASCII စာလုံး A-Z နှင့် a-z
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}{[}:alpha:{]}{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
{Happy Departure}!
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}:alnum:{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
ASCII ဂဏန်းနံပါတ်၊ A-Z နှင့် a-z
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}{[}:alnum:{]}{]}\{6\}
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
Happy {Birthd}ay to you!
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}:punct:{]}
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
ASCII ပုဒ်ဖြတ်သင်္ကေတ (punctuation) စာလုံး
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{[}{[}:punct:{]}{]}+
\strut\end{minipage} &
\begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
Hi{!} Nay Kaung Lar{?}
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    POSIX classes တွေက လည်း အများကြီးရှိပါတယ်။ ဒီနေရာမှာ တစ်ခု သိထားသင့်တာက
POSIX classes တွေနဲ့ တချို့ escape sequence တွေက အတူတူပဲ ဆိုတာကိုပါ။
အောက်ပါဇယားမှာ ပြထားတဲ့ ဥပမာ တချို့ကို မှီငြမ်းပါ။

    \begin{longtable}[c]{@{}ll@{}}
\toprule
Escape sequence သင်္ကေတ & POSIX classes\tabularnewline
\midrule
\endhead
\d  & {[}{[}:digit:{]}{]}\tabularnewline
\l  & {[}{[}:lower:{]}{]}\tabularnewline
\s  & {[}{[}:space:{]}{]}\tabularnewline
\u | {[}{[}:upper:{]}{]}\tabularnewline
\w  & {[}{[}:word:{]}{]}\tabularnewline
\D  & {[}\^{}{[}:digit:{]}{]}\tabularnewline
\L  & {[}\^{}{[}:lower:{]}{]}\tabularnewline
\S  & {[}\^{}{[}:space:{]}{]}\tabularnewline
\U  & {[}\^{}{[}:upper:{]}{]}\tabularnewline
\W  & {[}\^{}{[}:word:{]}{]}\tabularnewline
\bottomrule
\end{longtable}

    \subsubsection{Unicode Regular
Expression}\label{unicode-regular-expression}

ယူနီကုဒ်နဲ့ ပတ်သက်တဲ့ RE ကိုလည်း နည်းနည်း မိတ်ဆက်ပါမယ်။ တိုတိုပြောရရင်
အင်္ဂလိပ်စာအတွက် RE token အားလုံးက အလုပ်လုပ်ပါတယ်။ တချို့ RE တွေက
မြန်မာစာ အပါအဝင် ဘာသာစကားအားလုံးအတွက် အမြဲတမ်းအဆင်ပြေတာမဟုတ်ပါဘူး။
အဲဒီလိုအခါမျိုးမှာ Unicode RE ရဲ့ အကူအညီကို လှမ်းယူတာ မျိုးလည်း
လုပ်ရတတ်ပါတယ်။ ယူနီကုဒ် RE ဆိုတာက ယူနီကုဒ်အဖွဲ့အစည်းက သတ်မှတ်ထားတဲ့
သတ်မှတ်ချက်တွေကို၊ RE အနေနဲ့လည်း အလုပ်လုပ်လို့ရအောင် သင်္ကေတတွေ
သတ်မှတ်ထားတာလို့ လွယ်လွယ်ကူကူမှတ်လို့ ရပါတယ်။ Unicode RE ကလည်း တကယ့်ကို
အများကြီးပါ။ အားလုံးကို မှတ်ထားစရာ မလိုပါဘူး။ သဘောတရားရအောင်သာ Unicode
RE တချို့က အောက်ပါဇယားအတိုင်းပါ။

    \textbar{} Unicode RE သင်္ကေတ \textbar{} သတ်မှတ်ချက် \textbar{}
\textbar{}:-\/-\/-\/-\/-\/-\/-\/-\textbar{}:-\/-\/-\/-\/-\/-\/-\/-\textbar{}
\textbar{} \X \textbar{} ယူနီကုဒ် အတွက် RE "." ပါ\textbar{} \textbar{}
\x{FFFF} \textbar{} ယူနီကုဒ်စာလုံးတွေကို ကုဒ်နံပါတ်နဲ့ ရိုက်နိုင်ပါတယ်။
ဥပမာ \x{1F637} ဆိုရင် 😷 (FACE WITH MEDICAL MASK) ကို ရိုက်ပေးပါလိမ့်မယ်။
\textbar{} \textbar{} \x{1000}{10}\textbar{} မြန်မာစာ စာလုံး "က" ကို
၁၀ခါ \textbar{} \textbar{} \p{L} (သို့) \p{Letter}\textbar{} Unicode
စာလုံး တစ်လုံး \textbar{} \textbar{} \p{Ll} (သို့) \p{Lowercase_Letter}
\textbar{} အင်္ဂလိပ်ကဲ့သို့ စာလုံးအကြီး၊အသေး ရှိတဲ့ ဘာသာစကားတွေရဲ့
စာလုံးအသေး တစ်လုံး\textbar{} \textbar{} \p{Lu} (သို့)
\p{Uppercase_Letter} \textbar{} အင်္ဂလိပ်ကဲ့သို့ စာလုံးအကြီး၊အသေး ရှိတဲ့
ဘာသာစကားတွေရဲ့ စာလုံးအကြီး တစ်လုံး\textbar{} \textbar{} \p{S} (သို့)
\p{Symbol} \textbar{} သင်္ချာ သင်္ကေတ၊ ငွေကြေး သင်္ကေတ၊
အလွယ်တကူပုံတွေကို ဆွဲတဲ့နေရာမှာ သုံးတဲ့ စသည့်သင်္ကေတများထဲက
တစ်ခု\textbar{} \textbar{}\p{Sm} (သို့) \p{Math_Symbol}\textbar{}
သင်္ချာ သင်္ကေတ တစ်ခု \textbar{} \textbar{} \p{N} (သို့)
\p{Number}\textbar{} ဘာသာစကားမျိုးစုံရဲ့ ဂဏန်းနံပါတ်များထဲက
ဂဏန်းတစ်ခု\textbar{} \textbar{} \p{Nl} (သို့) \p{Letter_Number}
\textbar{} စာလုံးကဲ့သို့သော နံပါတ်များ။ ဥပမာ ရောမနံပါတ်များ ဖြစ်ကြတဲ့ I,
V, IX စသည်ဖြင့် \textbar{} \textbar{}\p{Myanmar}\textbar{}
ယူနီကုဒ်အဖွဲ့အစည်းက သတ်မှတ်ထားပြီးဖြစ်တဲ့ မြန်မာယူနီကုဒ်မှာပါဝင်တဲ့
စာလုံးများထဲက စာလုံးတစ်လုံး \textbar{} \textbar{}\p{InMyanmar}\textbar{}
ယူနီကုဒ်အဖွဲ့အစည်းက သတ်မှတ်ထားပြီးဖြစ်တဲ့ မြန်မာယူနီကုဒ်နံပါတ် U1000 ကနေ
U109F အကြားဝင်တဲ့ စာလုံးများ\textbar{}\textbar{}

    \subsubsection{Inline Modifier}\label{inline-modifier}

\begin{longtable}[c]{@{}llll@{}}
\toprule
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
သင်္ကေတ
\strut\end{minipage} &
\begin{minipage}[b]{0.15\columnwidth}\raggedright\strut
အလုပ်လုပ်ပုံ
\strut\end{minipage} &
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
ဥပမာ RE
\strut\end{minipage} &
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
ဥပမာ RE နဲ့ ကိုက်သောရလဒ်
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?i)
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
အင်္ဂလိပ်စာ စာလုံးအကြီး၊ အသေးကို မခွဲခြားပဲ၊ အတူတူပဲဆိုတဲ့ သတ်မှတ်ချက်
(case insensitive)
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?i)phone
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
i{Phone} is a mobile {phone}. Yes, it is a SMART {PHONE}!
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?c)
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
အင်္ဂလိပ်စာ စာလုံးအကြီး၊ အသေးကို သပ်သပ်စီခွဲထားတဲ့ သတ်မှတ်ချက် (case
sensitive)
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?c)phone
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
iPhone is a mobile {phone}. Yes, it is a SMART PHONE!
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?x)
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
RE တွေကို ဖတ်ရလွယ်ကူဖို့အတွက်၊ RE ရဲ့ token တစ်ခုနဲ့ တစ်ခု အကြားမှာ
ရှိတဲ့ space တွေကို လစ်လျူရှုဖို့အတွက် (free-spacing mode လို့ခေါ်)
သုံးတဲ့ inline modifier ပါ။comment mode, whitespace mode လို့လည်း
သိကြပါတယ်။
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?x)a b c
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{abc} and a b c and ABC and {abcabc}
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?t)
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
free-spacing mode ကို ပိတ်ချင်တဲ့အခါမှာ အသုံးပြုပါတယ်။Tcl programming
language မှာပဲသုံးနိုင်။
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?t)a b c
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
abc and {a b c} and ABC and abcabc
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?s)
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
single line mode ကို active ဖြစ်ဖို့အတွက် အသုံးပြုပါတယ်။ single line
mode မှာတော့ RE "." က line break စာလုံးတွေအပါအဝင်၊ စာလုံးအားလုံး ကို
ကိုယ်စားပြုပါလိမ့်မယ်။"dot all mode" ဆိုပြီး ခေါ်ကြပါတယ်။
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?s)(\^{}.\emph{\d+\$) \textbar{} {Line no.1}\n{Line no.2}\n{Line no.3}
\textbar{} \textbar{}(?m)\textbar{} multi-line mode ကို active
ဖြစ်ဖို့အတွက် အသုံးပြုပါတယ်။ \textbar{} (?m)(\^{}.}\d+\$)
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{Line no.1}\nLine no.2\nLine no.3
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    \subsubsection{Lookahead and Lookbehind}\label{lookahead-and-lookbehind}

\begin{longtable}[c]{@{}llll@{}}
\toprule
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
Lookaround သင်္ကေတ
\strut\end{minipage} &
\begin{minipage}[b]{0.15\columnwidth}\raggedright\strut
အလုပ်လုပ်ပုံ
\strut\end{minipage} &
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
ဥပမာ RE
\strut\end{minipage} &
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
ဥပမာ RE နဲ့ ကိုက်သောရလဒ်
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?=regex)
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
Positive lookahead လို့ခေါ်ပါတယ်။ရှာဖွေမဲ့ စာလုံးရဲ့ အရှေ့မှာ (ညာဘက်)
regex pattern ရှိနေတဲ့ အခြေအနေ
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
.\{3\}(?=\d{5})
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
{abc}12345
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?!regex)
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
Negative lookahead လို့ခေါ်ပါတယ်။ရှာဖွေမဲ့ စာလုံးရဲ့ အရှေ့မှာ (ညာဘက်)
regex pattern မရှိတဲ့ အခြေအနေ
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
Hard(?!Rock)
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
HardRock {Hard}Music
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?\textless{}=regex)
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
Positive lookbehind လို့ခေါ်ပါတယ်။ ရှာဖွေမဲ့ စာလုံးရဲ့ အနောက်မှာ
(ဘယ်ဘက်) regex pattern ရှိနေတဲ့ အခြေအနေ
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?\textless{}=\d)D
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
5{D} fiveD oneD 1{D}
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?\textless{}!regex)
\strut\end{minipage} &
\begin{minipage}[t]{0.15\columnwidth}\raggedright\strut
Negative lookbehind လို့ခေါ်ပါတယ်။ ရှာဖွေမဲ့ စာလုံးရဲ့ အနောက်မှာ
(ဘယ်ဘက်) regex pattern မရှိတဲ့ အခြေအနေ
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
(?\textless{}!\d)D
\strut\end{minipage} &
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
5D five{D} one{D} 1D
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    Lookahead, Lookbehind ကို command prompt မှာ grep (ကိုယ်လိုချင်တဲ့ RE
နဲ့ ရှာဖွေပေးနိုင်တဲ့ ပရိုဂရမ်) commandနဲ့ အောက်ပါအတိုင်း စမ်းrun
ကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}TuuWarWarTuu\PYZdq{}} \PY{p}{|} grep \PYZhy{}P \PY{l+s+s1}{\PYZsq{}War(?=War)\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Tuu\textcolor{ansi-red-intense}{\textbf{War}}WarTuu

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}TuuWarWarTuu\PYZdq{}} \PY{p}{|} grep \PYZhy{}P \PY{l+s+s1}{\PYZsq{}War(?!War)\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
TuuWar\textcolor{ansi-red-intense}{\textbf{War}}Tuu

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}TuuWarWarTuu\PYZdq{}} \PY{p}{|} grep \PYZhy{}P \PY{l+s+s1}{\PYZsq{}(?\PYZlt{}=Tuu)War\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Tuu\textcolor{ansi-red-intense}{\textbf{War}}WarTuu

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}TuuWarWarTuu\PYZdq{}} \PY{p}{|} grep \PYZhy{}P \PY{l+s+s1}{\PYZsq{}(?\PYZlt{}!Tuu)War\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
TuuWar\textcolor{ansi-red-intense}{\textbf{War}}Tuu

    \end{Verbatim}

    \subsubsection{Greedy and Lazy}\label{greedy-and-lazy}

RE မှာ greedy search နဲ့ lazy search ဆိုပြီး နှစ်မျိုးရှိတယ်။ Greedy
search က ပေးလိုက်တဲ့ regex pattern (သို့) condition ကို ပေးလိုက်တဲ့
စာကြောင်း အပေါ်မှာ တစ်ခေါက်တွေ့တာနဲ့ ရပ်မသွားပဲ ထပ်ခါထပ်ခါ ဆက်ရှာပြီး၊
နောက်ဆုံး အကြိမ် ပြေလည်သည်အထိ ရှာတဲ့ပုံစံပါ။ Lazy search က regex pattern
ကို တစ်ခေါက်တွေ့တာနဲ့ ထပ်မရှာတော့ပဲ ရပ်သွားပါလိမ့်မယ်။ ပုံမှန်အားဖြင့်
RE က greedy search ပါ။ RE engine ကို Lazy search အနေနဲ့
အလုပ်လုပ်ပေးစေချင်ရင်တော့ condition (သို့) regex pattern ရဲ့ နောက်မှာ
"?" ကိုထည့်ပါ။

Greedy ကနေ Lazy အဖြစ်ပြောင်းတဲ့ ပုံစံတချို့ကို လေ့လာဖို့အတွက်
အောက်ပါဇယားကို မှီငြမ်းပါ။

\begin{longtable}[c]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.13\columnwidth}\raggedright\strut
Greedy
\strut\end{minipage} &
\begin{minipage}[b]{0.13\columnwidth}\raggedright\strut
Lazy
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.13\columnwidth}\raggedright\strut
*
\strut\end{minipage} &
\begin{minipage}[t]{0.13\columnwidth}\raggedright\strut
*? \textbar{} သုည (သို့) တစ်ခုထက်ပို \textbar{} \textbar{} + \textbar{}
+? \textbar{} တစ်ခု (သို့) တစ်ခုထက်ပို \textbar{} \textbar{} ?
\textbar{} ?? \textbar{} သုည (သို့) တစ်ခု \textbar{} \textbar{} \{n\}
\textbar{} \{n\}? \textbar{} n အကြိမ်တိတိ \textbar{} \textbar{} \{n,\}
\textbar{} \{n,\}? \textbar{} အနည်းဆုံး n အကြိမ်နဲ့ညီမျှ \textbar{}
\textbar{} \{n,m\} \textbar{} \{n,m\}? \textbar{} n အကြိမ် ကနေ m
အကြိမ်အထိ \textbar{}
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}\PYZlt{}em\PYZgt{}Hello World\PYZlt{}/em\PYZgt{}\PYZdq{}} \PY{p}{|} grep \PYZhy{}P \PY{l+s+s1}{\PYZsq{}\PYZlt{}.+\PYZgt{}\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-red-intense}{\textbf{<em>Hello World</em>}}

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}\PYZlt{}em\PYZgt{}Hello World\PYZlt{}/em\PYZgt{}\PYZdq{}} \PY{p}{|} grep \PYZhy{}P \PY{l+s+s1}{\PYZsq{}\PYZlt{}.+?\PYZgt{}\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-red-intense}{\textbf{<em>}}Hello World\textcolor{ansi-red-intense}{\textbf{</em>}}

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}puppy\PYZdq{}} \PY{p}{|} grep \PYZhy{}P \PY{l+s+s1}{\PYZsq{}p.+p\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-red-intense}{\textbf{pupp}}y

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}puppy\PYZdq{}} \PY{p}{|} grep \PYZhy{}P \PY{l+s+s1}{\PYZsq{}p.+?p\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-red-intense}{\textbf{pup}}py

    \end{Verbatim}

    ယခုလောက်ဆိုရင် RE ရဲ့ concept နှင့်တကွ အသုံးပြုပုံပြုနည်း
သဘောတရားကိုတော့ ရလောက်ပြီလို့ယူဆပါတယ်။ မြင်တတ်တဲ့ သူဆိုလျှင် wild card
နဲ့ နှိုင်းယှဉ်ကြည့်ပြီး၊ wild card ရဲ့ "?" က RE ရဲ့ "." နဲ့ သွားတူတာ။
ထိုနည်းလည်းကောင်း wild card ရဲ့ "*" က RE ရဲ့ ".*" နဲ့ တူပုံကိုလည်း
သိနေလောက်ပါပြီ။

RE ကို linuxပရိုဂရမ် အမျိုးမျိုးမှာ လိုအပ်ချက်နဲ့အညီ
ပြင်ဆင်ပြီးသုံးကြလို့ သူ့ရဲ့ syntax (တွဲသုံးတဲ့ ပုံစံ)က
အမျိုးမျိုးရှိပါတယ်။ ဥပမာ တချို့မှာ အောက်ပါအတိုင်း ဖြစ်ပါသည်။

*awk regular expression syntax, egrep regular expression syntax, ed
regular expression syntax, emacs regular expression syntax, gnu-awk
regular expression syntax, grep regular expression syntax

လက်တွေ့မှာ ရာနဲ့ထောင်နဲ့ချီရှိတဲ့ ဖိုင်တွေနဲ့ အလုပ်လုပ်ရတော့မယ်ဆိုရင်
wild card တွေ၊ regular expression တွေကို သုံးပြီး အလုပ်လုပ်မှ
သက်သာပါလိမ့်မယ်။ သို့သော် တကယ့်လက်တွေ text processing ရဲ့ ပြဿနာတွေကို RE
ကို သုံးပြီး ဖြေရှင်းနိုင်ဖို့ကတော့ လက်တွေ့စမ်းသုံးမှသာ
ကျွမ်းကျင်လာပါလိမ့်မယ်။ ပထမ အစပိုင်းမှာတော့ ကိုယ်လိုချင်တဲ့ text pattern
ကို တော်တော်နဲ့ ဆွဲယူလို့မရလို့ စိတ်ပင်ပန်းရတာတွေလည်း ရှိမှာ
မလွဲမသွေပါပဲ။ စမ်းသုံးကြည့်ရင်း၊ စမ်းသုံးကြည့်ရင်း နဲ့ RE နဲ့ အလုပ်
လုပ်လို့ရလာပြီဆိုရင်တော့၊ RE ရဲ့ ပါဝါကိုလည်း သိရှိပြီး၊ ခက်ခဲတဲ့
ပြဿနာတွေကိုလည်း ဖြေရှင်းလာနိုင်ပါလိမ့်မယ်။

ဒီအထိ linux command တွေရော wild card နဲ့ RE တွေကို ရိုက်စမ်းကြည့်ရင်း၊
သဘောပေါက်အောင် သေသေချာချာ ကြိုးစားပြီးလေ့လာခဲ့တဲ့သူ ဆိုရင်တော့
တော်တော်လေး ခရီးပေါက်နေပါပြီ။ အောက်ပါ RE နဲ့ ပတ်သက်ပြီး လူသိများတဲ့
ကာတွန်းကို နောက်ဆုံးအနေနဲ့ message ပေးရင်း၊ RE ရဲ့ သင်ကြားမှုကို
ရပ်လိုက်တော့မယ်။

    

    Above RE Comic is from: \href{https://xkcd.com/208/}{xkcd, A webcomic of
romance, sarcasm, math, and language.}

    \subsection{27. find (search for files in a directory
hierarchy)}\label{find-search-for-files-in-a-directory-hierarchy}

ဖိုင်ကို ဖိုလ်ဒါအောက် အဆင့်ဆင့် ရှာဖွေတဲ့ နေရာမှာ အသုံးပြုပါတယ်။

ဘာ parameter မှမပေးပဲ find command တစ်ခုတည်းကိုပဲ ရိုက်ရင်
လက်ရှိရောက်နေတဲ့ ဖိုလ်ဒါအောက်မှာ ရှိတဲ့ ဖိုင်၊ ဖိုလ်ဒါ၊
ဖိုလ်ဒါတွေအောက်မှာ ရှိတဲ့ ဖိုင်တွေ အားလုံးကို ရှာဖွေပြီး
ရိုက်ထုတ်ပြပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} find
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
.
./folder-new
./folder-new/folder-new
./city
./screen
./screen/KaKhaGa-output.png
./screen/echo-kagyi.png
./screen/redirections.png
./screen/bayesian-formula.png
./screen/regular\_expressions.png
./screen/less-cmd-output.png
./linux-commands.ipynb
./.fileC
./folder-athit
./data1
./all-vi-info.txt
./folderB
./folderB/127-135.pdf
./folderB/fileA
./folderB/otest
./data4
./fmt.out
./echo
./.ipynb\_checkpoints
./.ipynb\_checkpoints/linux-commands-checkpoint.ipynb
./my-news
./folderA
./folderA/127-135.pdf
./ls.out
./news
./fileA
./data3
./otest.word
./otest
./item-list
./data5
./data2
./fileB
./linux-commands.ipynb.bak
./wildcard
./wildcard/graph2
./wildcard/Graph4
./wildcard/superman
./wildcard/hello.txt
./wildcard/abstract.txt
./wildcard/graph4
./wildcard/city
./wildcard/Graph3
./wildcard/maik-khe.food.txt
./wildcard/Graph1
./wildcard/mba.note.txt
./wildcard/matrix
./wildcard/ls.out
./wildcard/graph1
./wildcard/acknowledgements.txt
./wildcard/m
./wildcard/graph3
./wildcard/.my-private-info.txt
./wildcard/graph5
./wildcard/conclusion.txt
./wildcard/Graph2
./otest.tag
./sorted-names
./newfile

    \end{Verbatim}

    ဖိုလ်ဒါနာမည် (သို့) ရှာဖွေချင်တဲ့ path လမ်းကြောင်းကို ပေးရင်တော့၊
အဲဒီပေးလိုက်တဲ့ path အောက်မှာရှိတဲ့ ဖိုင်၊ ဖိုလ်ဒါတွေရဲ့ နာမည်အားလုံးကို
ရိုက်ထုတ်ပြပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} find ./folderA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
./folderA
./folderA/127-135.pdf

    \end{Verbatim}

    ဖိုင်ကို နာမည်နဲ့တကွ ရှာဖွေချင်ရင်တော့ -name option ကိုသုံးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} find \PYZhy{}name \PY{l+m}{127}\PYZhy{}135.pdf
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
./folderB/127-135.pdf
./folderA/127-135.pdf

    \end{Verbatim}

    ဖိုလ်ဒါတွေရဲ့ အတွင်းပိုင်းကို ဘယ်နှစ်ဆင့်အထိပဲ ဝင်ရှာပေးပါဆိုတာကိုလည်း
-maxdepth ဆိုတဲ့ option နဲ့ ကန့်သတ်ပေးနိုင်ပါတယ်။

-maxdepth 3 option ကို တပ်ပြီး ဖိုလ်ဒါတွေထဲဝင်ရှာတဲ့ အခါမှာ အောက်ဘက်
သုံးဆင့် အထိပဲ ဝင်ရှာပေးပါဆိုပြီး ကန့်သတ်ပေးတဲ့ ပုံစံက အောက်ပါအတိုင်းပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} find \PYZti{} \PYZhy{}maxdepth \PY{l+m}{3} \PYZhy{}name \PY{l+s+s2}{\PYZdq{}127\PYZhy{}135.pdf\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
find: ‘/home/lar/.dbus’: Permission denied
find: ‘/home/lar/.cache/dconf’: Permission denied
/home/lar/bk-dlbox/tool4all/127-135.pdf
/home/lar/linux-cmd/folderB/127-135.pdf
/home/lar/linux-cmd/folderA/127-135.pdf

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    အထက်မှာ မြင်ရတဲ့ permission denied ဆိုတဲ့ message က
ဖော်ပြပါဖိုလ်ဒါအောက်ကို ဝင်ခွင့်မရှိလို့ ပေးတဲ့ error message ဖြစ်ပါတယ်။

-not option ကိုပေးပြီး ဒီဖိုင်ကိုတော့ မရှာပါနဲ့ ဆိုပြီးလည်း
ကန့်သတ်လို့လည်း ရပါတယ်။

အောက်ပါ find command ဥပမာက \textasciitilde{}/linux-cmd/
ဖိုလ်ဒါအောက်မှာဝင်ရှာပေးပါ။\\
ဒါပေမဲ့ d နဲ့စတဲ့ ဖိုင်နာမည်တွေကိုတော့ မရှာပါနဲ့လို့ ပြောပြီး
ခိုင်းတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} find \PYZti{}/linux\PYZhy{}cmd/ \PYZhy{}not \PYZhy{}name \PY{l+s+s2}{\PYZdq{}d*\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/linux-cmd/
/home/lar/linux-cmd/folder-new
/home/lar/linux-cmd/folder-new/folder-new
/home/lar/linux-cmd/city
/home/lar/linux-cmd/screen
/home/lar/linux-cmd/screen/KaKhaGa-output.png
/home/lar/linux-cmd/screen/echo-kagyi.png
/home/lar/linux-cmd/screen/redirections.png
/home/lar/linux-cmd/screen/bayesian-formula.png
/home/lar/linux-cmd/screen/regular\_expressions.png
/home/lar/linux-cmd/screen/less-cmd-output.png
/home/lar/linux-cmd/linux-commands.ipynb
/home/lar/linux-cmd/.fileC
/home/lar/linux-cmd/folder-athit
/home/lar/linux-cmd/all-vi-info.txt
/home/lar/linux-cmd/folderB
/home/lar/linux-cmd/folderB/127-135.pdf
/home/lar/linux-cmd/folderB/fileA
/home/lar/linux-cmd/folderB/otest
/home/lar/linux-cmd/fmt.out
/home/lar/linux-cmd/echo
/home/lar/linux-cmd/.ipynb\_checkpoints
/home/lar/linux-cmd/.ipynb\_checkpoints/linux-commands-checkpoint.ipynb
/home/lar/linux-cmd/my-news
/home/lar/linux-cmd/folderA
/home/lar/linux-cmd/folderA/127-135.pdf
/home/lar/linux-cmd/ls.out
/home/lar/linux-cmd/news
/home/lar/linux-cmd/fileA
/home/lar/linux-cmd/otest.word
/home/lar/linux-cmd/otest
/home/lar/linux-cmd/item-list
/home/lar/linux-cmd/fileB
/home/lar/linux-cmd/linux-commands.ipynb.bak
/home/lar/linux-cmd/wildcard
/home/lar/linux-cmd/wildcard/graph2
/home/lar/linux-cmd/wildcard/Graph4
/home/lar/linux-cmd/wildcard/superman
/home/lar/linux-cmd/wildcard/hello.txt
/home/lar/linux-cmd/wildcard/abstract.txt
/home/lar/linux-cmd/wildcard/graph4
/home/lar/linux-cmd/wildcard/city
/home/lar/linux-cmd/wildcard/Graph3
/home/lar/linux-cmd/wildcard/maik-khe.food.txt
/home/lar/linux-cmd/wildcard/Graph1
/home/lar/linux-cmd/wildcard/mba.note.txt
/home/lar/linux-cmd/wildcard/matrix
/home/lar/linux-cmd/wildcard/ls.out
/home/lar/linux-cmd/wildcard/graph1
/home/lar/linux-cmd/wildcard/acknowledgements.txt
/home/lar/linux-cmd/wildcard/m
/home/lar/linux-cmd/wildcard/graph3
/home/lar/linux-cmd/wildcard/.my-private-info.txt
/home/lar/linux-cmd/wildcard/graph5
/home/lar/linux-cmd/wildcard/conclusion.txt
/home/lar/linux-cmd/wildcard/Graph2
/home/lar/linux-cmd/otest.tag
/home/lar/linux-cmd/sorted-names
/home/lar/linux-cmd/newfile

    \end{Verbatim}

    အထက်ပါ ခဲ့တဲ့ -not အစား "!" ကိုလည်း သုံးနိုင်ပါတယ်။\\
ဥပမာ find \textasciitilde{}/linux-cmd/ ! -name "d*"

find command ရဲ့ ကောင်းတဲ့အချက် နောက်တစ်ချက်က ဖိုင်တွေကိုရှာဖွေခိုင်းတဲ့
အခါမှာ search criteria တစ်မျိုးထက်မကကို ပေါင်းပြီး
တခါတည်းပေးခိုင်းလို့ရတဲ့ အချက်ပါ။

အောက်ပါ ဥပမာက ဖိုင်နာမည် f နဲ့ စတာကို ရှာပေးပါ။\\
ဒါပေမဲ့ w နဲ့ စတဲ့ ဖိုင်တွေ၊ screen နဲ့ စတဲ့ ဖိုင်တွေကို မရှာပါနဲ့၊
မလိုချင်ဘူးလို့ ကန့်သတ်တာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} find \PYZti{}/linux\PYZhy{}cmd/ \PYZhy{}name \PY{l+s+s2}{\PYZdq{}f*\PYZdq{}} ! \PYZhy{}name \PY{l+s+s2}{\PYZdq{}w*\PYZdq{}} ! \PYZhy{}name \PY{l+s+s2}{\PYZdq{}screen*\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/linux-cmd/folder-new
/home/lar/linux-cmd/folder-new/folder-new
/home/lar/linux-cmd/folder-athit
/home/lar/linux-cmd/folderB
/home/lar/linux-cmd/folderB/fileA
/home/lar/linux-cmd/fmt.out
/home/lar/linux-cmd/folderA
/home/lar/linux-cmd/fileA
/home/lar/linux-cmd/fileB

    \end{Verbatim}

    ဖိုင်ကိုပဲ ရှာပေးပါ။ ဖိုလ်ဒါကိုပဲ ရှာပေးပါဆိုပြီး -type option ပေးပြီး
ကန့်သတ်လို့ရပါတယ်။

-type f က file ကို ကိုယ်စားပြုပါတယ်။\\
-type d က directory ကို ကိုယ်စားပြုပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} find \PYZti{}/linux\PYZhy{}cmd/ \PYZhy{}type f \PYZhy{}name \PY{l+s+s2}{\PYZdq{}*.txt\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/linux-cmd/all-vi-info.txt
/home/lar/linux-cmd/wildcard/hello.txt
/home/lar/linux-cmd/wildcard/abstract.txt
/home/lar/linux-cmd/wildcard/maik-khe.food.txt
/home/lar/linux-cmd/wildcard/mba.note.txt
/home/lar/linux-cmd/wildcard/acknowledgements.txt
/home/lar/linux-cmd/wildcard/.my-private-info.txt
/home/lar/linux-cmd/wildcard/conclusion.txt

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} find \PYZti{}/linux\PYZhy{}cmd/ \PYZhy{}type d \PYZhy{}name \PY{l+s+s2}{\PYZdq{}wild*\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/linux-cmd/wildcard

    \end{Verbatim}

    find command နဲ့ ဖိုင်တွေကို ရှာဖွေခိုင်းတဲ့ အခါမှာ ပုံမှန်အားဖြင့် က
linux ရဲ့ အလုပ်လုပ်တဲ့ ပုံစံအတိုင်း စာလုံးအကြီးအသေးကို ခွဲပြီး အလုပ်
လုပ်ပါတယ်။ အဲဒါကြောင့် ပေးလိုက်တဲ့ နာမည်က စာလုံးအသေးဆိုရင် အသေးကိုပဲ
ရှာပါမည်။ တကယ်လို့ အင်္ဂလိပ်စာ စာလုံးအကြီးအသေး ကို မခွဲချင်ဘူး၊
ကြီးကြီးသေးသေး ဒီနာမည်ပါရင် ပြီးတာပဲ ဆိုတဲ့ အခြေအနေမျိုးကို
လိုချင်ရင်တော့ -iname option ကို သုံးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} find \PYZti{}/linux\PYZhy{}cmd/ \PYZhy{}type d \PYZhy{}iname \PY{l+s+s2}{\PYZdq{}foldera\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/linux-cmd/folderA

    \end{Verbatim}

    တစ်ခုထက်မကတဲ့ ဖိုလ်ဒါအောက်မှာ ရှာခိုင်းချင်တဲ့ အခါမှာ၊ ဝင်ရှာစေချင်တဲ့
ဖိုလ်ဒါနာမည်တွေကို ရှေ့ပိုင်းမှာ တန်းစီပြီး ရိုက်ထည့်ပေးလို့ရပါတယ်။

အောက်ပါ ဥပမာကို ကြည့်ပါ။

ဖိုလ်ဒါ \textasciitilde{}/linux-cmd/folderA နဲ့ ဖိုလ်ဒါ
\textasciitilde{}/linux-cmd/wildcard/ အောက်မှာရှိတဲ့ ဖိုင်တွေထဲမှာမှ "p"
ပါတဲ့ ဖိုင်နာမည်တွေကို ရှာပေးပါဆိုပြီး အမိန့်ပေးတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}31}]:} find \PYZti{}/linux\PYZhy{}cmd/folderA/ \PYZti{}/linux\PYZhy{}cmd/wildcard/ \PYZhy{}name \PY{l+s+s2}{\PYZdq{}*p*\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
/home/lar/linux-cmd/folderA/127-135.pdf
/home/lar/linux-cmd/wildcard/graph2
/home/lar/linux-cmd/wildcard/Graph4
/home/lar/linux-cmd/wildcard/superman
/home/lar/linux-cmd/wildcard/graph4
/home/lar/linux-cmd/wildcard/Graph3
/home/lar/linux-cmd/wildcard/Graph1
/home/lar/linux-cmd/wildcard/graph1
/home/lar/linux-cmd/wildcard/graph3
/home/lar/linux-cmd/wildcard/.my-private-info.txt
/home/lar/linux-cmd/wildcard/graph5
/home/lar/linux-cmd/wildcard/Graph2

    \end{Verbatim}

    ဖိုင်တွေကို ရှာဖွေတဲ့ နေရာမှာ permission option နဲ့ လည်းကန့်သတ်ပြီး
ရှာဖွေနိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}32}]:} find \PYZhy{}type f \PYZhy{}perm \PY{l+m}{644}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
./folderB/otest
./otest.word
./otest
./otest.tag

    \end{Verbatim}

    -user option ကိုသုံးပြီး၊ ဖိုင်တွေကို ရှာဖွေခိုင်းတဲ့ အခါမှာ user
နာမည်နဲ့ (သို့) ဘယ်သူကပိုင်တဲ့ ဖိုင်ကို ရှာပေးပါဆိုပြီးလဲ
အမိန့်ပေးလို့ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} find . \PYZhy{}user lar \PYZhy{}name \PY{l+s+s2}{\PYZdq{}*.txt\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
./all-vi-info.txt
./wildcard/hello.txt
./wildcard/abstract.txt
./wildcard/maik-khe.food.txt
./wildcard/mba.note.txt
./wildcard/acknowledgements.txt
./wildcard/.my-private-info.txt
./wildcard/conclusion.txt

    \end{Verbatim}

    \subsection{28. grep (Global Regular Expression
Print)}\label{grep-global-regular-expression-print}

grep command က standard input ကနေပေးလိုက်တဲ့ စာကြောင်း (သို့)
ဖိုင်တွေထဲမှာ user က ရှာခိုင်းတဲ့ စာလုံး၊ စာကြောင်း၊ Regular Expression
pattern တွေကို ရှာဖွေပေးတဲ့ ပရိုဂရမ်ပါ။ string pattern တွေကို ရှာဖွေတဲ့
နေရာမှာ မြန်ဆန်တဲ့
\href{https://en.wikipedia.org/wiki/Boyer\%E2\%80\%93Moore_string_search_algorithm}{Boyer-Moore
algorithm} ကိုအသုံးပြုထားပါတယ်။

    linux system မှာ register လုပ်ထားတဲ့ user အားလုံးရဲ့ user name,
encrypted password, user ID number (UID), user's group ID number (GID),
full name of the user (GECOS), user home directory, login shell တွေကို
သိမ်းထားတဲ့ passwd ဆိုတဲ့နာမည်နဲ့ ဖိုင်ရှိပါတယ်။ အဲဒီဖိုင်ထဲမှာ guest
ဆိုတဲ့ user name နဲ့ ပတ်သတ်တဲ့ အချက်အလက်ကို ရှာဖွေကြည့်ကြရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} grep guest /etc/passwd
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-red-intense}{\textbf{guest}}-a6syh9:x:999:999:Guest:/tmp/\textcolor{ansi-red-intense}{\textbf{guest}}-a6syh9:/bin/bash
\textcolor{ansi-red-intense}{\textbf{guest}}:x:1001:1001:Guest User,,,:/home/\textcolor{ansi-red-intense}{\textbf{guest}}:/bin/bash

    \end{Verbatim}

    grep command က ရှာခိုင်းတဲ့ စာလုံးတွေ၊ RE pattern တွေကို ရှာလို့တွေ့ရင်
အဲဒီစာလုံးတွေကို အရောင်နဲ့ highlight လုပ်ပြီး ပြပေးပါတယ်။

စာလုံးအကြီး၊ အသေး မခွဲခြားပဲ ရှာပေးပါဆိုရင် -i option ကို သုံးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} grep \PYZhy{}i guest /etc/passwd
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-red-intense}{\textbf{guest}}-a6syh9:x:999:999:\textcolor{ansi-red-intense}{\textbf{Guest}}:/tmp/\textcolor{ansi-red-intense}{\textbf{guest}}-a6syh9:/bin/bash
\textcolor{ansi-red-intense}{\textbf{guest}}:x:1001:1001:\textcolor{ansi-red-intense}{\textbf{Guest}} User,,,:/home/\textcolor{ansi-red-intense}{\textbf{guest}}:/bin/bash

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} grep \PYZhy{}w \PY{l+s+s2}{\PYZdq{}blood\PYZdq{}} fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
My \textcolor{ansi-red-intense}{\textbf{blood}} type is O.

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} grep \PY{l+s+s2}{\PYZdq{}report\PYZdq{}} *.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
       /usr/share/vim/vim74/bug\textcolor{ansi-red-intense}{\textbf{report}}.vim
                      Script to generate a bug \textcolor{ansi-red-intense}{\textbf{report}}.  See ":help bugs".

    \end{Verbatim}

    -c option နဲ့ ဘယ်နှစ်ခါ ရှာတွေ့သလဲ ဆိုတာကို အောက်ပါအတိုင်း
ရေတွက်ခိုင်းလို့ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} grep \PYZhy{}c \PY{l+s+s2}{\PYZdq{}report\PYZdq{}} *.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
2

    \end{Verbatim}

    -H option နဲ့ဆို ရှာခိုင်းခဲ့တဲ့စာလုံး၊ RE pattern တွေကို
ရှာဖွေလို့တွေ့ရှိတဲ့ဖိုင်ရဲ့နာမည်ကိုပါ ရိုက်ပြပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} grep \PYZhy{}H \PY{l+s+s2}{\PYZdq{}report\PYZdq{}} *.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-magenta}{all-vi-info.txt}\textcolor{ansi-cyan}{:}       /usr/share/vim/vim74/bug\textcolor{ansi-red-intense}{\textbf{report}}.vim
\textcolor{ansi-magenta}{all-vi-info.txt}\textcolor{ansi-cyan}{:}                      Script to generate a bug \textcolor{ansi-red-intense}{\textbf{report}}.  See ":help bugs".

    \end{Verbatim}

    ဘယ်နှစ်ကြောင်းမြောက်မှာ ရှာတွေ့တယ် ဆိုတာကို နံပါတ် (line number) နဲ့
ရိုက်ထုတ်ပြခိုင်းချင်ရင် -n option ကို သုံးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}67}]:} grep \PYZhy{}in report *.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-green}{259}\textcolor{ansi-cyan}{:}       /usr/share/vim/vim74/bug\textcolor{ansi-red-intense}{\textbf{report}}.vim
\textcolor{ansi-green}{260}\textcolor{ansi-cyan}{:}                      Script to generate a bug \textcolor{ansi-red-intense}{\textbf{report}}.  See ":help bugs".

    \end{Verbatim}

    grep ကပုံမှန်အားဖြင့် ရှာတွေ့တဲ့ စာလုံး၊ ကိုက်ညီတဲ့ RE pattern တွေကို
အနီရောင်နဲ့ highlight လုပ်ပြီး ပြပေးပါတယ်။ အရောင်ပြောင်းချင်ရင်တော့ grep
command ရဲ့ ရှေ့မှာ GREP\_COLOR variable တစ်ခုဆောက်ပြီး ကိုယ်ကြိုက်တဲ့
အရောင်နဲ့ ရိုက်ခိုင်းလို့ရပါတယ်။ အရောင်ပြောင်းရိုက်ခိုင်းကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}66}]:} \PY{n+nv}{GREP\PYZus{}COLOR}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}01;35\PYZsq{}} grep \PYZhy{}in report *.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-green}{259}\textcolor{ansi-cyan}{:}       /usr/share/vim/vim74/bug\textcolor{ansi-magenta-intense}{\textbf{report}}.vim
\textcolor{ansi-green}{260}\textcolor{ansi-cyan}{:}                      Script to generate a bug \textcolor{ansi-magenta-intense}{\textbf{report}}.  See ":help bugs".

    \end{Verbatim}

    -B option နဲ့ ရှာလို့တွေတဲ့ စာကြောင်းရဲ့ အထက်မှာရှိတဲ့
ဘယ်နှစ်ကြောင်းကိုလည်း တွဲပြီးရိုက်ပြပေးပါ ဆိုပြီး ခိုင်းလို့ရပါတယ်။
တချို့အလုပ်တွေမှာက ရှာဖွေလို့တွေ့တဲ့ စာကြောင်းတစ်ကြောင်းထဲကို ပြပေးတာထက်
သူ့အထက်က စာကြောင်း၊ သူ့အောက်က စာကြောင်းတွေနဲ့ပါတွဲပြီး ကြည့်မှ
အဆင်ပြေတဲ့ အခါမျိုး ရှိတတ်လို့ပါ။

အောက်ပါ ဥပမာက -B 2 option နဲ့ ရှာတွေ့တဲ့ စာကြောင်းရဲ့ အထက်
နှစ်ကြောင်းကိုပါ အတူတူရိုက်ပြပေးပါလို့ option ပေးတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} grep \PYZhy{}B \PY{l+m}{2} \PY{l+s+s2}{\PYZdq{}blood\PYZdq{}} fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
I am fileA.
I was born in April.
My \textcolor{ansi-red-intense}{\textbf{blood}} type is O.

    \end{Verbatim}

    -A option နဲ့ grep ပရိုဂရမ်ကို ရှာခိုင်းလို့သွားတွေ့တဲ့ စာကြောင်းရဲ့
အောက်ဘက် ဘယ်နှစ်ကြောင်းရိုက်ပြပေးပါဆိုပြီး လဲ လုပ်ခိုင်းလို့ရပါတယ်။

အောက်ပါ ဥပမာက -A 3 option နဲ့ သွားတွေ့တဲ့ စာကြောင်းသာမက သူ့ရဲ့ အောက်ဖက်က
စာကြောင်း သုံးကြောင်းကိုပါ တွဲရိုက်ပြပေးပါဆိုပြီး အမိန့်ပေးတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} grep \PYZhy{}A \PY{l+m}{3} \PY{l+s+s2}{\PYZdq{}Hi\PYZdq{}} fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-red-intense}{\textbf{Hi}}!
I am fileB.
I was born in November.
My blood type is O.

    \end{Verbatim}

    တခြား linux command တွေလိုပါပဲ။ grep မှာလည်း option တွေကို တခုထက်မက
တွဲပြီး အလုပ်လုပ်ခိုင်းလို့ရပါတယ်။ -B နဲ့ -A ကိုတွဲပြီး run ကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} grep \PYZhy{}B \PY{l+m}{1} \PYZhy{}A \PY{l+m}{1} \PY{l+s+s2}{\PYZdq{}November\PYZdq{}} fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
I am fileB.
I was born in \textcolor{ansi-red-intense}{\textbf{November}}.
My blood type is O.

    \end{Verbatim}

    -B နဲ့ -A option နှစ်ခုအစား -C option ကိုလည်း သုံးရင်လည်း အလုပ်
အတူတူလုပ်ပေးပါလိမ့်မယ်။ အောက်ပါ ဥပမာကို ကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} grep \PYZhy{}C \PY{l+m}{1} \PY{l+s+s2}{\PYZdq{}November\PYZdq{}} fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
I am fileB.
I was born in \textcolor{ansi-red-intense}{\textbf{November}}.
My blood type is O.

    \end{Verbatim}

    -o option နဲ့ ရှာခိုင်းလို့ သွားတွေ့တဲ့စာကြောင်း တစ်ကြောင်းလုံးကို
ရိုက်မပြစေချင်ပဲ၊ တွေ့တဲ့စာလုံးကိုပဲ သီးသန့်ရိုက်ထုတ်ပါ ဆိုပြီးလဲ
ခိုင်းလို့ရပါတယ်။ အောက်ပါ ဥပမာက လက်ရှိဖိုလ်ဒါအောက်မှာ ရှိတဲ့ .txt နဲ့
ဆုံးတဲ့ ဖိုင်တွေထဲမှာ "This" ဆိုတဲ့ စာလုံးကို
ဘယ်နှစ်ခါသုံးထားသလဲဆိုတာကို သိချင်တဲ့ အခါမျိုးမှာ အသုံးပြုပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}33}]:} grep \PYZhy{}o \PY{l+s+s2}{\PYZdq{}This\PYZdq{}} *.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-red-intense}{\textbf{This}}
\textcolor{ansi-red-intense}{\textbf{This}}
\textcolor{ansi-red-intense}{\textbf{This}}
\textcolor{ansi-red-intense}{\textbf{This}}
\textcolor{ansi-red-intense}{\textbf{This}}
\textcolor{ansi-red-intense}{\textbf{This}}
\textcolor{ansi-red-intense}{\textbf{This}}
\textcolor{ansi-red-intense}{\textbf{This}}
\textcolor{ansi-red-intense}{\textbf{This}}

    \end{Verbatim}

    ကျွန်တော်တို့ အရေအတွက် ဘယ်လောက်ရှိသလဲဆိုတာကို အထက်မှာ သင်ပေးခဲ့တဲ့ wc
command ကို pipe နဲ့ ပို့ပေးပြီး ရေတွက်ခိုင်းလို့ရတယ်လေ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} grep \PYZhy{}o \PY{l+s+s2}{\PYZdq{}This\PYZdq{}} *.txt \PY{p}{|} wc
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
      9       9      45

    \end{Verbatim}

    \subsection{29. egrep (Extended grep)}\label{egrep-extended-grep}

egrep က grep command ကို -E option နဲ့တွဲသုံးတာနဲ့ အတူတူပါပဲ။
ပေးလိုက်တဲ့ pattern ကို Extended Regular Expression Set အနေနဲ့
ဖတ်ပြီးအလုပ်လုပ်ပေးပါတယ်။

ဥပမာ grep command ကို အောက်ပါအတိုင်း blood စာလုံး (သို့) Hi ဆိုတဲ့
စာလုံးကို ရှာပေးပါလို့ ခိုင်းရင် အလုပ်မလုပ်ပေးတာကို တွေ့ရပါလိမ့်မယ်။
ဘာ့ကြောင့်လဲ ဆိုတော့ blood\textbar{}Hi ကို စာလုံးတစ်လုံးလို ဖတ်ပြီး
ရှာပေးလို့ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} grep \PYZhy{}w \PY{l+s+s1}{\PYZsq{}blood|Hi\PYZsq{}} fileA fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]

    \end{Verbatim}

    egrep command ကတော့ "\textbar{}" ကို "or" လို့ နားလည်ပေးပါတယ်။ RE အနေနဲ့
ဖတ်ပြီး အလုပ်လုပ်ပေးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}42}]:} egrep \PYZhy{}w \PY{l+s+s1}{\PYZsq{}blood|Hi\PYZsq{}} fileA fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-magenta}{fileA}\textcolor{ansi-cyan}{:}My \textcolor{ansi-red-intense}{\textbf{blood}} type is O.
\textcolor{ansi-magenta}{fileB}\textcolor{ansi-cyan}{:}\textcolor{ansi-red-intense}{\textbf{Hi}}!
\textcolor{ansi-magenta}{fileB}\textcolor{ansi-cyan}{:}My \textcolor{ansi-red-intense}{\textbf{blood}} type is O.

    \end{Verbatim}

    အထက်ပါ အလုပ်ကို အောက်ပါအတိုင်း grep command ကို -E နဲ့ option နဲ့
တွဲပြီး လုပ်ခိုင်းလို့ရပါတယ်။ ရလဒ်က အတူတူပဲ ဖြစ်ပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}39}]:} grep \PYZhy{}E \PYZhy{}w \PY{l+s+s1}{\PYZsq{}blood|Hi\PYZsq{}} fileA fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{ansi-magenta}{fileA}\textcolor{ansi-cyan}{:}My \textcolor{ansi-red-intense}{\textbf{blood}} type is O.
\textcolor{ansi-magenta}{fileB}\textcolor{ansi-cyan}{:}\textcolor{ansi-red-intense}{\textbf{Hi}}!
\textcolor{ansi-magenta}{fileB}\textcolor{ansi-cyan}{:}My \textcolor{ansi-red-intense}{\textbf{blood}} type is O.

    \end{Verbatim}

    ဘာဖြစ်လို့ ဒီလို grep -E နဲ့ လုပ်လို့ရရဲ့သားနဲ့ egrep ဆိုပြီး
ပရိုဂရမ်သပ်သပ်ရှိနေရတာလဲဆိုရင် ဟိုးအရင်က grep နဲ့ egrep ဆိုပြီး
ပရိုဂရမ်သပ်သပ်စီ ရှိနေခဲ့ကြလို့ပါ။ နောက်ပိုင်းကြမှ grep မှာ egrep
လိုမျိုးအလုပ်လုပ်လို့ရအောင် -E option ဆိုပြီး ထပ်ထည့်တာမို့လို့ပါ။

    RE pattern တွေနဲ့ ရှာတာဖွေတာလုပ်မယ် ဆိုရင် egrep (သို့) grep -E
နှစ်မျိုးစလုံးနဲ့ အသုံးပြုနိုင်ပါတယ်။

လက်တွေ့ RE pattern တစ်ခုဖြစ်တဲ့ "rep.*t" ကို သုံးကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} egrep \PY{l+s+s1}{\PYZsq{}rep.*t\PYZsq{}} *.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
       /usr/share/vim/vim74/bug\textcolor{ansi-red-intense}{\textbf{report}}.vim
                      Script to generate a bug \textcolor{ansi-red-intense}{\textbf{report}}.  See ":help bugs".
       Note  that  a  number  of things that may be regarded as bugs by some, are in fact caused by a too-faithful \textcolor{ansi-red-intense}{\textbf{reproduction of Vi's behaviour.  And if you think other t}}hings are bugs "because Vi

    \end{Verbatim}

    \subsection{30. sed (stream editor for filtering and transforming
text)}\label{sed-stream-editor-for-filtering-and-transforming-text}

ဖိုင်ထဲမှာရှိတဲ့ စာသားတွေကို အပြောင်းအလဲလုပ်ဖို့အတွက်ဆိုရင် sed command
က အသုံးဝင်ပါတယ်။ တကယ့်ကို powerful ဖြစ်တဲ့ tool တစ်ခုလည်းဖြစ်ပါတယ်။
သုံးပုံသုံးနည်း တချို့ကို ဒီနေရာမှာ မိတ်ဆက်ပါမယ်။

sed program မှာ command တွေအများကြီးရှိပါတယ်။ ကျွန်တော်အသုံးများတာကတော့
ဖိုင်ထဲမှာ ရှိနေတဲ့ စာလုံးတွေကို တခြားစာလုံးနဲ့ အစားထိုးတဲ့အခါမှာသုံးတဲ့
substitute command ပါ။ အတိုကောက် အနေနဲ့ "s" ပါ။ RE ကို အသုံးပြုသလို
slash သုံးခုပုံစံ (s/ရှိနေတဲ့စာလုံး/အစားထိုးမဲ့စာလုံး/) ပါပဲ။

ဥပမာ fruit.txt ဖိုင်ထဲမှာရှိနေတာက mango ဆိုပါစို့။ mango ကို orange နဲ့
အစားထိုးမယ်ဆိုရင် အောက်ပါအတိုင်း sed command ပေးခိုင်းလို့ရပါတယ်။

အရင်ဆုံး fruit.txt ဖိုင်ထဲမှာ ဘာတွေရှိသလဲဆိုတာကို cat နဲ့ ကြည့်ရအောင်

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} cat ./fruit.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
I love mango.
I ate two mango.
mango is mango.

    \end{Verbatim}

    s/mango/orange/ နဲ့ fruit.txt ဖိုင် ထဲက mango တွေကို orange
နဲ့အစားထိုးပြီး fruit-orange.txt ဖိုင်ထဲမှာ သိမ်းပါမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} sed s/mango/orange/ fruit.txt \PYZgt{} fruit\PYZhy{}orange.txt
\end{Verbatim}

    fruit-orange.txt ဖိုင်ထဲမှာ ဘယ်လိုပြောင်းလဲသွားသလဲ ဆိုတာကို ကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} cat fruit\PYZhy{}orange.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
I love orange.
I ate two orange.
orange is mango.

    \end{Verbatim}

    အထက်ပါ output ကိုကြည့်ပြီးနောက်ဆုံးစာကြောင်းက ဒုတိယmango ကို orange
အဖြစ်ပြောင်းမပေးတာကို သတိထားမိမယ်လို့ထင်ပါတယ်။ အဲဒါက substitute
လုပ်ခိုင်းတဲ့ အခါမှာ g (global) ဆိုတဲ့ parameter ကိုမပေးခဲ့လို့ပါ။
တကယ်လို့ ကျွန်တော်တို့က g parameter ကိုသာပေးခဲ့မယ်ဆိုရင်
စာကြောင်းတစ်ကြောင်းမှာ ပထမဆုံးတွေတဲ့ mango ကို orange နဲ့ အစားထိုးပြီး
ရပ်မသွားပဲ၊ နောက်ထပ် ထပ်တွေ့တဲ့ ဒုတိယ mango ကိုလည်း orange နဲ့
အစားထိုးပေးပါလိမ့်မယ်။ s/orange/mango/g နဲ့ run ကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} sed s/mango/orange/g fruit.txt \PYZgt{} fruit\PYZhy{}orange.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} cat ./fruit\PYZhy{}orange.txt
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
I love orange.
I ate two orange.
orange is orange.

    \end{Verbatim}

    အခုဆိုရင် mango အားလုံးကို orange အဖြစ် ပြောင်းပေးသွားတာတွေ့ရပါမယ်။

    ပုံမှန်အားဖြင့် စာလုံးတစ်လုံးကို အခြားစာလုံးတစ်လုံးနဲ့ အစားထိုးတဲ့အခါမှာ
s ကိုရိုက်ပြီး slash (/) သုံးခုနဲ့ ရေးတဲ့ syntax ဖြစ်တဲ့
's/old\_word/new\_word/' ဆိုတဲ့ ပုံစံကို သုံးကြပေမဲ့၊ နောက်ထပ်
အသုံးဝင်တဲ့ ပုံစံတခုကို ရှင်းပြပါမယ်။

တကယ်တမ်းက ကျွန်တော်တို့ slash အစား တခြားစာလုံးကိုလည်း delimiter
အဖြစ်သုံးလို့ရပါတယ်။ တစ်ခါတလေ အဲဒါကပိုပြီးတော့ အဆင်ပြေပါတယ်။ ဥပမာ
website URL တွေလို အစားထိုးမဲ့ စာကြောင်းမှာ slash တွေပါနေတဲ့
အခါမျိုးမှာပါ။

အောက်ပါ ဥပမာက ".com/burmese" ကို ".org/myanmar" နဲ့ အစားထိုးတဲ့ ဥပမာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n+nb}{echo} \PY{l+s+s2}{\PYZdq{}http://www.bbc.com/burmese\PYZdq{}} \PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}s\PYZus{}com/burmese\PYZus{}org/myanmar\PYZus{}\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
http://www.bbc.org/myanmar

    \end{Verbatim}

    \subsubsection{Excution Cycle of sed}\label{excution-cycle-of-sed}

sed နဲ့ input stream ထဲမှာရှိတဲ့ စာသားတွေထဲက၊ ကိုယ်လိုချင်တဲ့
အစိတ်ပိုင်းတစ်ပိုင်းကိုပဲ ရိုက်ထုတ်တာ၊ စာလုံးတွေကို ဝင်ပြင်တာ၊ format
ပြောင်းတာ စသည်ဖြင့် လုပ်လို့ရတဲ့ အလုပ်တွေအများကြီးရှိပါတယ်။ အဲဒီလို
အလုပ်တွေအများကြီးကို command line ကနေ (သို့) bash shell script တွေထဲကနေ
သုံးဖို့ဆိုရင်၊ sed command ရဲ့ အလုပ်လုပ်တဲ့ပုံစံ (excution cycle) ကို
သိထားသင့်ပါတယ်။

sed မှာ ဝင်လာတဲ့ဒေတာတွေကို ကိုင်တွယ်ပြီး အလုပ်လုပ်ဖို့အတွက် pattern
space နဲ့ hold space ဆိုပြီး data buffer နှစ်မျိုးရှိပါတယ်။ Pattern
space က temporary buffer ပါပဲ။ လက်ရှိလုပ်နေတဲ့ အလုပ်နဲ့ ပတ်သက်တဲ့ ဒေတာ
(သို့) စာကြောင်းကို သိမ်းထားပါတယ်။ Hold space ကတော့
လိုတဲ့အခါပြန်ယူပြီးသုံးဖို့အတွက် သိမ်းထားတဲ့ long term buffer ဖြစ်ပါတယ်။
sed က နောက်လာမဲ့ command တွေမှာ အရင်လုပ်ခဲ့တဲ့ ဒေတာနဲ့ ပတ်သက်ပြီး
နှိုင်းယှဉ်ကြည့်ဖို့လိုအပ်တဲ့ အခါ၊ အရင်ဒေတာကိုပါယူသုံးရတဲ့ အခါမျိုးမှာ
hold space ကနေ ယူသုံးပါတယ်။

အလုပ်လုပ်တဲ့အခါမှာ ကျွန်တော်တို့က Hold space ကို တိုက်ရိုက်ကိုင်တွယ်ပြီး
အလုပ်မလုပ်ပါဘူး။ Hold space ကဒေတာကို လိုအပ်တဲ့ အခါမှာ pattern space
ပေါ်ကို ကော်ပီကူး ပြီးသုံးတာမျိုး၊ pattern space မှာရှိနေတဲ့ ဒေတာနဲ့
ပေါင်းစပ်ပြီး (append to pattern space) သုံးတာမျိုးပဲ လုပ်ကြပါတယ်။

sed ပရိုဂရမ်ကို စာကြောင်းတွေ၊ စာပိုဒ်တွေကို ရိုက်ထုတ်ခိုင်းတဲ့ အခါမျိုး
မှာ pattern space က ဒေတာကို ရိုက်ထုတ်ပေးတာပါ။ အထက်မှာ sed အသုံးပြုပုံ
ဥပမာအဖြစ် ပြခဲ့တဲ့ substitute အလုပ်ကလည်း pattern space ပေါ်မှာပဲ
အလုပ်လုပ်သွားတာပါ။ မော်နီတာမှာ "p" နဲ့ ရိုက်ထုတ်ခိုင်းတဲ့ အခါမှာလဲ
pattern space က ဒေတာကိုပဲ ရိုက်ထုတ်ပေးတာပါ။

sed က pattern space, hold space ကို သုံးပြီး အလုပ်လုပ်တဲ့ ပုံစံကို
နားလည်လွယ်အောင် လက်တွေ့ ဥပမာနဲ့ ရှင်းပြပါမယ်။

စာကြောင်းသုံးကြောင်း (line 1., line 2. နဲ့ line 3.) ကို echo command နဲ့
ရိုက်ထုတ်ကြည့်ရင် အောက်ပါအတိုင်း မြင်ရပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}line 1.\PYZbs{}nline 2.\PYZbs{}nline 3.\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line 1.
line 2.
line 3.

    \end{Verbatim}

    ဆိုကြပါစို့ အထက်ပါစာကြောင်းသုံးကြောင်းကို input stream တစ်ခုအနေနဲ့ sed
ပရိုဂရမ်ဆီကို "\textbar{}" (piping) နဲ့ ပို့ပေးပြီး -n '1!G;h;\$p'
ဆိုတဲ့ command ပေးရင် အောက်ပါအတိုင်း output ကို မြင်ရပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}line 1.\PYZbs{}nline 2.\PYZbs{}nline 3.\PYZdq{}}\PY{p}{|} sed \PYZhy{}n \PY{l+s+s1}{\PYZsq{}1!G;h;\PYZdl{}p\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line 3.
line 2.
line 1.

    \end{Verbatim}

    အထက်ပါအတိုင်း echo နဲ့ pass လုပ်ပေးလိုက်တဲ့ စာကြောင်းသုံးကြောင်းကို sed
က ပြောင်းပြန် ရိုက်ထုတ်ပေးတာကို မြင်ရပါလိမ့်မယ်။

'1!G;h;\$p' ဆိုတဲ့ စာကြောင်းမှာ 1!G ရယ် h နဲ့ \$p ဆိုပြီး command
သုံးခုပါဝင်ပါတယ်။

1!G; မှာ "G" က hold space ထဲက ဒေတာကို pattern space ဆီကို ပေါင်းထည့်ပေး
(append) လုပ်ပေးပါတယ်။ "1" က ပထမဆုံး စာကြောင်း ကို ညွန်းတာပါ။
အလုပ်လုပ်မဲ့ စာကြောင်းကို ညွန်းတာ ပါ။ address ပေးတာလို့လည်း ပြောကြပါတယ်။
"!" သင်္ကေတက ပေးလိုက်တဲ့ အမိန့်ကို ဆန့်ကျင်ဘက်၊ not (သို့) negate
လုပ်ပေးပါလို့ ခိုင်းတာပါ။ ဒီနေရာမှာတော့ "1!G" မို့လို့
ပထမဆုံးစာကြောင်းကလွဲပြီး ကျန်တဲ့စာကြောင်းတိုင်းကို pattern space ဆီကို
append လုပ်ပေးပါလို့ ဆိုလိုပါတယ်။

နောက်ထပ် အမိန့်တခုဖြစ်တဲ့ "h" ကတော့ pattern space မှာရှိနေတဲ့ ဒေတာတွေကို
hold space ဆီကို ကော်ပီကူးပေးပါလို့ ဆိုလိုပါတယ်။ အဲဒီလိုလုပ်တဲ့အခါမှာ
hold space ထဲမှာရှိတဲ့ ဒေတာတွေကို overwrite လုပ်သွားပါလိမ့်မယ်။ ဒီ "h"
command ကတော့ pattern space စာကြောင်းတွေအားလုံးကို လုပ်ပေးပါလိမ့်မယ်။

\$p မှာ "\$"ကတော့ နောက်ဆုံးစာကြောင်းကို ညွှန်းပါတယ်။ "p" ကတော့ လက်ရှိ
pattern space ကို မော်နီတာစကရင်မှာ ရိုက်ထုတ်ပေးပါလို့ခိုင်းတာပါ။
အဲဒါကြောင့် "\$p" က နောက်ဆုံးစာကြောင်းကို ရောက်ရှိတဲ့ အချိန်မှာ pattern
space ကို print လုပ်ပေးပါလို့ ဆိုလိုပါတယ်။

    အထက်ပါ '1!G;h;\$p' ရဲ့ အလုပ်လုပ်ပုံကို ပိုပြီးတော့ မြင်သာအောင် sed
command က တစ်ကြောင်းပြီး တစ်ကြောင်း ဖတ်ပြီး command တွေကို run နေစဉ်မှာ
pattern space/hold space ထဲမှာ ရှိနေမဲ့ ဒေတာကို ဇယားပုံစံမျိုးနဲ့
ပြသပါမယ်။

    \begin{longtable}[c]{@{}lll@{}}
\toprule
ဝင်လာတဲ့ စာကြောင်း & Pattern space နဲ့ Hold space ထဲကဒေတာ & Run ခဲ့တဲ့
command\tabularnewline
\midrule
\endhead
line1 & line1.\$ & h\tabularnewline
line2 & line2.\nline1.\$ & 1!G;h\tabularnewline
line3 & line3.\nline2.\nline1.\$ & 1!G;h;\$p\tabularnewline
\bottomrule
\end{longtable}

    တကယ်လို့ pattern space ရဲ့ အပြောင်းအလဲကို တစ်ကြောင်းပြီး
တစ်ကြောင်းကြည့်ချင်ရင် "l" command ကိုသုံးပြီး ကြည့်နိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}line 1.\PYZbs{}nline 2.\PYZbs{}nline 3.\PYZdq{}} \PY{p}{|} sed \PYZhy{}n \PY{l+s+s1}{\PYZsq{}1!G;h;l;\PYZdl{}p\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line 1.\$
line 2.\textbackslash{}nline 1.\$
line 3.\textbackslash{}nline 2.\textbackslash{}nline 1.\$
line 3.
line 2.
line 1.

    \end{Verbatim}

    \subsection{Some more examples of sed}\label{some-more-examples-of-sed}

    "q" command က လက်ရှိလုပ်နေတဲ့ sed ရဲ့အလုပ်ကို ရပ်ခိုင်းတဲ့ "quit" (သို့)
"exit-code" ဖြစ်ပါတယ်။ "2q" ဆိုပြီး command ပေးရင် pattern space ထဲမှာ
ရှိတဲ့ စာကြောင်းတွေထဲက နှစ်ကြောင်းအထိ မော်နီတာစကရင်မှာ ရိုက်ပေးပြီးရင်
quit လုပ်သွားပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}line 1.\PYZbs{}nline 2.\PYZbs{}nline 3.\PYZdq{}}\PY{p}{|} sed 2q
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line 1.
line 2.

    \end{Verbatim}

    "d" command က pattern space ကိုဖျက်ပေးပါတယ်။ ဥပမာ "1d" ဆိုပြီး command
ပေးရင် pattern space ထဲမှာရှိတဲ့စာကြောင်းတွေထဲက ပထမဆုံးစာကြောင်းကို
ဖျက်ပြီး ကျန်တာကို မော်နီတာစကရင်မှာ ရိုက်ထုတ်ပြပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}line 1.\PYZbs{}nline 2.\PYZbs{}nline 3.\PYZdq{}}\PY{p}{|} sed 1d
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line 2.
line 3.

    \end{Verbatim}

    sed ရဲ့ "p" command နဲ့ ရိုက်ချင်တဲ့ စာကြောင်းကို ရိုက်ခိုင်းလို့ရပါတယ်။
"3p" က pattern space ထဲက စာကြောင်း သုံးကြောင်းမြောက်ကိုရိုက်ခိုင်းတာပါ။
အဲဒီလိုရိုက်ခိုင်းတဲ့ အခါမှာ ပုံမှန်အားဖြင့် pattern space ထဲမှာရှိနေတဲ့
စာကြောင်း၊ စာပိုဒ် စတာတွေ အားလုံးကိုပါ မော်နီတာ စကရင်မှာရိုက်ပေးပါတယ်။
အဲဒီလို မရိုက်အောင် -n (သို့) -\/-quiet (သို့) -\/-silent နဲ့
တားဆီးနိုင်ပါတယ်။ "p" command က "-n" option နဲ့ အမြဲတွဲသုံးပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}line 1.\PYZbs{}nline 2.\PYZbs{}nline 3.\PYZdq{}}\PY{p}{|} sed \PYZhy{}n 3p
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line 3.

    \end{Verbatim}

    "-n" option ကို ဖြုတ်ပြီး run ကြည့်ရင် အောက်ပါအတိုင်း pattern space
ပေါ်မှာရှိနေတဲ့ စာကြောင်းသုံးကြောင်းကိုပါ အတူတူတွဲရိုက်ပေးတာကို
တွေ့ရပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}line 1.\PYZbs{}nline 2.\PYZbs{}nline 3.\PYZdq{}}\PY{p}{|} sed 3p
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line 1.
line 2.
line 3.
line 3.

    \end{Verbatim}

    command တစ်ခုထက်မက ကိုပေးချင်တယ်ဆိုရင်၊ command တွေကို တွန့်ကွင်း
နှစ်ခုအကြားမှာ ထည့်ပြီးပေးရပါတယ်။ bash shell script တွေမှာ သုံးတဲ့
ပုံစံအတိုင်း၊ command တစ်ခုနဲ့ တစ်ခုအကြားမှာတော့ ";" နဲ့ခြားပေးရပါတယ်။
အောက်ပါ ဥပမာက "1p" နဲ့ "3p" command နှစ်ခုနဲ့ စာကြောင်းနံပါတ် ၁ နဲ့
စာကြောင်းနံပါတ် ၃ ကို ရိုက်ခိုင်းတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}line 1.\PYZbs{}nline 2.\PYZbs{}nline 3.\PYZdq{}}\PY{p}{|} sed \PYZhy{}n \PY{l+s+s1}{\PYZsq{}\PYZob{}1p;3p\PYZcb{}\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line 1.
line 3.

    \end{Verbatim}

    အထက်မှာ သင်ကြားခဲ့သလို head နဲ့ tail command နှစ်ခုကို သုံးပြီး၊
ဖိုင်ထဲမှာ ရှိတဲ့စာကြောင်းတွေထဲက ဘယ်စာကြောင်းကနေ ဘယ်စာကြောင်းအထိ
ရိုက်ပေးပါလို့ ခိုင်းတဲ့ကိစ္စမျိုးကို sed command တစ်ခုထဲနဲ့
အောက်ပါအတိုင်း ခိုင်းလို့ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} sed \PYZhy{}n \PY{l+s+s1}{\PYZsq{}201,205p\PYZsq{}} otest.tag
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
n adj n part v part part punc
n n ppm pron ppm n v ppm punc
v part part pron ppm v part punc
n n n n ppm n v n n ppm adj v n part v conj n adv v ppm punc
conj n n ppm n conj v part v conj v ppm punc

    \end{Verbatim}

    အထက်ပါ '201,205p' က otest.tag ဖိုင်ထဲကနေ စာကြောင်း နံပါတ် ၂၀၁ ကနေ ၂၀၅
အထိ ရိုက်ထုတ်ပေးပါလို့ ခိုင်းတာ ဖြစ်ပါတယ်။

    \subsection{Using RE with sed command}\label{using-re-with-sed-command}

လက်တွေ့မှာ Regular Expression နဲ့ sed ကို ကောင်းကောင်း တွဲသုံးကြပါတယ်။\\
syntax ကတော့ လွယ်လွယ်ရှင်းပါဆိုရင် /RE\_pattern/action ဆိုတဲ့ ပုံစံပါ။
ဒီနေရာမှာ action ဆိုတာက sed command က support လုပ်ထားတဲ့ "p" (print),
"d" (delete) စတဲ့ command တွေပါ။

    ဥပမာ RE patten ဖြစ်တဲ့ "b" ပါတဲ့ စာကြောင်းကို တွေ့ရင်၊ အဲဒီစာကြောင်းရဲ့
အထက်မှာ blank line တစ်ကြောင်းထည့်ပေးစေချင်ရင် အောက်ပါအတိုင်း command
ပေးလို့ ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}a\PYZbs{}nb\PYZbs{}nc\PYZbs{}nd\PYZbs{}n\PYZdq{}} \PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}/b/\PYZob{}x;p;x;\PYZcb{}\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
a

b
c
d


    \end{Verbatim}

    အထက်ပါ sed command ဖြစ်တဲ့ "\{x;p;x;\}" မှာ "x" command က hold space နဲ့
pattern space ကို exchange လုပ်ပေးပါတယ်။ "b" စာကြောင်း ကိုတွေ့တဲ့
အချိန်မှာ၊ hold space ထဲမှာက ဘာမှ မရှိတဲ့ အနေအထားပါ။ လက်ရှိ pattern
space မှာက b စာကြောင်းက ရှိနေပါတယ်။ exchange လုပ်လိုက်တဲ့ အခါမှာတော့
pattern space မှာ ဘာမှ မရှိတော့ပဲ၊ hold space မှာ "b" ရှိပါလိမ့်မယ်။
အဲဒီလိုအခြေအနေမှာ "p" command နဲ့ pattern space ကို print လုပ်လို့ blank
line ကို မော်နီတာမှာ ရိုက်ထုတ်ပေးပါလိမ့်မယ်။ ပြီးတော့ "x" command နဲ့
hold space နဲ့ pattern space ကို ဒုတိယအခေါက် exchange လုပ်ပါတယ်။
အဲဒါကြောင့် pattern space ဆီကို "b" ပြန်ရောက်သွားပါတယ်။

    နောက် ဥပမာတစ်ခုကို ကြည့်ရအောင်။ ဒီတစ်ခါတော့ "G" command ကို
သုံးကြည့်ပါမယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}a\PYZbs{}nb\PYZbs{}nc\PYZbs{}nd\PYZbs{}n\PYZdq{}} \PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}/b/G\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
a
b

c
d


    \end{Verbatim}

    အထက်ပါ output အတိုင်း RE pattern ဖြစ်တဲ့ b ကို တွေ့တဲ့အခါ blank line
တစ်ကြောင်းရိုက်ပေးပါလိမ့်မယ်။

"G" command ရဲ့ အလုပ်လုပ်ပုံကတော့ အရင်ဆုံး \n (new line) ကို pattern
space မှာ ပေါင်းထည့်ပေး (append) ပါတယ်။ ပြီးတော့ hold space မှာ ရှိတဲ့
ဒေတာကို pattern space မှာ ပေါင်းထည့်ပေးပါတယ်။ အဲဒီအချိန်မှာ hold space
မှာက ဘာမှရှိမနေတော့ blank line ကို append လုပ်သွားပါလိမ့်မယ်။

    အထက်မှာ ဥပမာအဖြစ် run ပြခဲ့တဲ့ sed '/b/\{x;p;x;\}' နဲ့ sed '/b/G'
နှစ်ကြောင်းကို ပေါင်းပြီး sed '/b/\{x;p;x;G;\}' အနေနဲ့ run ကြည့်ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{n+nb}{echo} \PYZhy{}e \PY{l+s+s2}{\PYZdq{}a\PYZbs{}nb\PYZbs{}nc\PYZbs{}nd\PYZbs{}n\PYZdq{}} \PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}/b/\PYZob{}x;p;x;G;\PYZcb{}\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
a

b

c
d


    \end{Verbatim}

    အထက်ပါ output အတိုင်း "b" စာကြောင်းကို တွေ့တဲ့အခါမှာ အပေါ်နဲ့အောက်မှာ
blank line တစ်ကြောင်းစီ ရိုက်ပေးပါလိမ့်မယ်။

    \subsection{Address and address range of
sed}\label{address-and-address-range-of-sed}

sed command က ဘာမှာ မပြောရင် ဖိုင် (သို့) input လုပ်ပေးတဲ့ stream
ထဲမှာရှိတဲ့ စာကြောင်းတိုင်းကို တစ်ကြောင်းချင်းစီဖတ်ပြီး ခိုင်းတဲ့
command အတိုင်း အလုပ်လုပ်ပေးပါတယ်။

တကယ်လို့ ကျွန်တော်တို့က ဘယ်စာကြောင်းကိုပဲ၊ ဘယ်စာကြောင်းကနေ
ဘယ်စာကြောင်းအထိ စသည်ဖြင့် သတ်မှတ်ပြီး ပေးလိုက်တဲ့ command ကို apply
လုပ်ခိုင်းလို့ရပါတယ်။ address (သို့) address range ပေးတယ်လို့ ပြောပါတယ်။

ကိုယ်က အလုပ်လုပ်စေချင်တဲ့ စာကြောင်းတွေကို နံပါတ်နဲ့ ညွှန်းလို့ရပါတယ်။
address ပေးလို့ရပါတယ်။\\
အောက်ပါ sed command ရဲ့ '1d;3d;5d;' က စာကြောင်းနံပါတ် ၁၊ ၃ နှင့် ၅ ကို
ဖျက်ပေးပါလို့ခိုင်းတာပါ။ အဲဒါကြောင့် brace expansion \{1..6\} က
အမှန်တကယ် line1 ကနေ line6 အထိ စုစုပေါင်း စာကြောင်းရေ ခြောက်ကြောင်း
generate လုပ်ပေးပေမဲ့၊ line2, line4 နဲ့ line6 ကိုပဲ ရိုက်ထုတ်ပြတာပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}51}]:} \PY{n+nb}{echo} \PYZhy{}e line\PY{o}{\PYZob{}}\PY{l+m}{1}..6\PY{o}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}\PYZbs{}n\PYZsq{}}\PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}1d;3d;5d;\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
 line2
 line4
 line6


    \end{Verbatim}

    address range ပေးတဲ့ ကိစ္စကို လုပ်ကြည့်ရပေးအောင်။\\
စာကြောင်းနံပါတ် ၁ ကနေ ၃ အထိဖျက်ပေးစေချင်ရင် '1,3d' ဆိုပြီး
ကော်မာနဲ့ခြားပြီး ညွှန်းလို့ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}53}]:} \PY{n+nb}{echo} \PYZhy{}e line\PY{o}{\PYZob{}}\PY{l+m}{1}..6\PY{o}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}\PYZbs{}n\PYZsq{}}\PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}1,3d\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
 line4
 line5
 line6


    \end{Verbatim}

    အောက်ပါ sed ဥပမာက စာကြောင်းနံပါတ်၁ကို ဖျက်ပေးပြီး၊ နောက်ထပ် သုံးကြောင်း
ဆက်ပြီးဖျက်ပေးပါလို့ ခိုင်းခဲ့ပါတာ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}54}]:} \PY{n+nb}{echo} \PYZhy{}e line\PY{o}{\PYZob{}}\PY{l+m}{1}..6\PY{o}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}\PYZbs{}n\PYZsq{}}\PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}1,+3d\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
 line5
 line6


    \end{Verbatim}

    အောက်ပါ '2,5!d' ဆိုတာက စာကြောင်းနံပါတ် ၂ ကနေ ၅ ကလွဲရင် ကျန်တဲ့
စာကြောင်းတွေကို ဖျက်ပေးပါလို့ ခိုင်းတာပါ။ အဲဒါကြောင့် စာကြောင်းရေ နံပါတ်
၁ နဲ့ ၆ ကို ဖျက်ပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}55}]:} \PY{n+nb}{echo} \PYZhy{}e line\PY{o}{\PYZob{}}\PY{l+m}{1}..6\PY{o}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}\PYZbs{}n\PYZsq{}}\PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}2,5!d\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
 line2
 line3
 line4
 line5

    \end{Verbatim}

    အောက်ပါ '1\textasciitilde{}4d' command က စာကြောင်းနံပါတ် ၁ကိုဖျက်ပြီးရင်
စာကြောင်းနံပါတ်၄ အထိခုန်ပြီး၊ စာကြောင်းနံပါတ်၅ ကိုဖျက်ပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{n+nb}{echo} \PYZhy{}e line\PY{o}{\PYZob{}}\PY{l+m}{1}..6\PY{o}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}\PYZbs{}n\PYZsq{}}\PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}1\PYZti{}4d\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
 line2
 line3
 line4
 line6


    \end{Verbatim}

    အောက်ပါ sed '4,2d' နဲ့ ဆိုရင် စာကြောင်းရေနံပါတ်၄ ကိုပဲ ဖျက်ပေးပြီး၊
စာကြောင်းရေ နံပါတ်၂ ကို ဖျက်မပေးတာတွေ့ရပါလိမ့်မယ်။ ဘာကြောင့်လဲဆိုတော့
sed command က reverse direction အလုပ်မလုပ်နိုင်လို့ပါ။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n+nb}{echo} \PYZhy{}e line\PY{o}{\PYZob{}}\PY{l+m}{1}..6\PY{o}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}\PYZbs{}n\PYZsq{}}\PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}4,2d\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line1
 line2
 line3
 line5
 line6


    \end{Verbatim}

    sed မှာလည်း character class တွေရှိပါတယ်။ ဥပမာ ဝင်လာမဲ့ စာကြောင်းတွေထဲက
နံပါတ်နဲ့ဆုံးတဲ့ စာကြောင်းတွေကိုပဲ ရိုက်ပြပေးစေချင်ရင် sed -n
'/{[}{[}:digit:{]}{]}\$/p' ဆိုပြီး command ပေးလို့ရပါတယ်။ ဒီနေရာမှာ
{[}{[}:digit:{]}{]} ဆိုတာ နံပါတ် {[}0-9{]} ကိုဆိုလိုပြီး၊ ရှေ့မှာ RE
အကြောင်းရှင်းပြတုန်းက ပြောပြခဲ့သလိုပဲ \$ အမှတ်အသားကတော့
စာကြောင်းအဆုံးကို ကိုယ်စားပြုပါတယ်။ input လုပ်တဲ့ စာကြောင်းတိုင်းက
နံပါတ်နဲ့ ဆုံးနေလို့ line1 ကနေ line6 အားလုံးကို ရိုက်ပြပေးပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{n+nb}{echo} \PYZhy{}e line\PY{o}{\PYZob{}}\PY{l+m}{1}..6\PY{o}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}\PYZbs{}n\PYZsq{}} \PY{p}{|} sed \PYZhy{}n \PY{l+s+s1}{\PYZsq{}/[[:digit:]]\PYZdl{}/p\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
line1
 line2
 line3
 line4
 line5
 line6

    \end{Verbatim}

    sed command သုံးပုံသုံးနည်းကို echo command ကနေ ဒေတာကို piping လုပ်ပြီး
အများကြီးပြခဲ့ပေမဲ့၊ linux ရဲ့ တခြား command တွေလိုပဲ ဖိုင်ကနေဒေတာကို
pass လုပ်လို့ရတယ်ဆိုတာကိုလည်း မြင်ကြမယ်လို့ ထင်ပါတယ်။

sed command ကို သုံးတတ်ရင် သုံးတတ်သလိုပါပဲ။ Text processing မှာ
အများကြီး အထောက်အကူဖြစ်ပါလိမ့်မယ်။ စသုံးစမှာ ခက်ပါလိမ့်မယ်။ ဒါပေမဲ့ sed
command ရဲ့ syntax ကအောက်ပါအတိုင်း ပုံစံလေးမျိုးရှိတယ်လို့
ကျွန်တော်ကတော့ မှတ်သားထားပါတယ်။

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  {[}address{]} command
\item
  {[}line-address{]} command
\item
  address \{\\
  command1\\
  command2\\
  command3\\
  \}
\item
  sed {[}options{]} commands {[}file-to-edit{]}
\end{enumerate}

    sed ရဲ့ option တွေကို အသေးစိတ်သိချင်ရင် info sed ကို ဖတ်ပါ။ man sed ထက်
ပိုပြည့်စုံပါတယ်။

    \subsection{31. awk}\label{awk}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} 
\end{Verbatim}

    sed raw data\\
awk structure data

    \subsection{32. tac (concatenate and print files in
reverse)}\label{tac-concatenate-and-print-files-in-reverse}

ဖိုင်ထဲမှာရှိတဲ့ စာကြောင်းတွေကို ဖိုင်ရဲ့နောက်ဆုံးစာကြောင်းကနေ
ထိပ်ဆုံးအကြောင်းထိ ပြောင်းပြန်ပြန်ရိုက်ပေးတဲ့ command ပါ။\\
(တနည်းအားဖြင့် ရှေ့ပိုင်းမှာ လေ့လာခဲ့တဲ့ cat command ရဲ့ ဆန့်ကျင်ဘက်
အလုပ်ကို လုပ်ပေးပါတယ်)

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} tac fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
My blood type is O.
I was born in April.
I am fileA.
Mingalar bar!

    \end{Verbatim}

    အောက်ပါအတိုင်း fileA ကို cat နဲ့ ရိက်ကြည့်ပြီး tac command ရဲ့ output
နဲ့ နှိုင်းယှဉ်ကြည့်ရင် ဘယ်လိုကွာသလဲဆိုတာကို မြင်ပါလိမ့်မယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} cat fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Mingalar bar!
I am fileA.
I was born in April.
My blood type is O.

    \end{Verbatim}

    \subsection{33. rev (reverse lines
characterwise)}\label{rev-reverse-lines-characterwise}

rev command က ဖိုင်ထဲမှာ ရှိတဲ့ စာကြောင်း တစ်ကြောင်းချင်းစီကို
ပြောင်းပြန်ပြန်ရိုက်ပေးတဲ့ အလုပ်ကို လုပ်ပေးပါတယ်။

ရှေ့မှာ အကြိမ်ကြိမ် သုံးခဲ့တဲ့ fileA ကို rev command ကို သုံးပြီး
ပြောင်းပြန်ပြန်ရိုက်ခိုင်းကြည့်ရအောင်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} rev fileA
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
!rab ralagniM
.Aelif ma I
.lirpA ni nrob saw I
.O si epyt doolb yM

    \end{Verbatim}

    \subsection{34. paste (merge lines of
files)}\label{paste-merge-lines-of-files}

ဖိုင်တွေထဲမှာရှိတဲ့ စာကြောင်းတွေကို ပေါင်းပြီး ရိုက်ထုတ်ချင်တဲ့ အခါ၊
ပေါင်းပြီး သိမ်းချင်တဲ့ အခါတွေမှာ အသုံးပြုပါတယ်။ လက်တွေ့မှာ အရမ်းကို
အသုံးဝင်တဲ့ command တစ်ခု ဖြစ်ပါတယ်။

ဥပမာ fileA နှင့် fileB ကို ပေါင်းပြီး ရိုက်ထုတ်ပေးခိုင်းချင်တဲ့ အခါမှာ
အောက်ပါအတိုင်း paste command ကို အသုံးပြုနိုင်ပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} paste fileA fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Mingalar bar!	Hi!
I am fileA.	I am fileB.
I was born in April.	I was born in November.
My blood type is O.	My blood type is O.
	

    \end{Verbatim}

    ဘာ parameter မှ မပေးဘူးဆိုရင် paste command က ဖိုင်တစ်ဖိုင်နဲ့
တစ်ဖိုင်ကြားကို tab နဲ့ ခြားပေးပါလိမ့်မယ်။ တကယ်လို့
ကိုယ်ကခြားပေးစေချင်တဲ့ စာလုံးကို -d (သို့) -\/-delimiters ဆိုတဲ့
parameter နဲ့ ညွှန်ကြားပေးရင်၊ အဲဒီညွှန်ကြားပေးတဲ့ parameter နဲ့ခြားပြီး
မော်နီတာ စကရင်မှာ ရိုက်ထုတ်ပေးပါလိမ့်မယ်။

ဥပမာ fileA နှင့် fileB အကြားက စာကြောင်းတွေကို pipe စာလုံး ("\textbar{}")
နဲ့ ခြားပေးစေချင်ရင် အောက်ပါအတိုင်း command ပေးလို့ ရပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} paste \PYZhy{}d\PY{l+s+s1}{\PYZsq{}\PYZbs{}|\PYZsq{}} fileA fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Mingalar bar!|Hi!
I am fileA.|I am fileB.
I was born in April.|I was born in November.
My blood type is O.|My blood type is O.
|

    \end{Verbatim}

    အထက်ပါ output မှာ နောက်ဆုံးစာကြောင်းက pipe တစ်ခုပဲ မြင်နေရတာက၊ fileB မှာ
စာဘာမှ မရိုက်ထားပဲ enter ခေါက်ထားခဲ့တဲ့ စာကြောင်းရှိလို့ပါ။

နောက်ထပ် ဥပမာ တစ်ခုအနေနဲ့ fileA နှင့် fileB အကြားက စာကြောင်းတွေကို
စာကြောင်းတစ်ကြောင်းစီအနေနဲ့ အလှည့်ကျ ရိုက်ထုတ်ပေးချင်တဲ့ အခါမှာ
အောက်ပါအတိုင်း အသုံးပြုပါတယ်။

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} paste \PYZhy{}d\PY{l+s+s1}{\PYZsq{}\PYZbs{}n\PYZsq{}} fileA fileB
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Mingalar bar!
Hi!
I am fileA.
I am fileB.
I was born in April.
I was born in November.
My blood type is O.
My blood type is O.



    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{k}{for} i in \PY{o}{\PYZob{}}\PY{l+m}{1}..5\PY{o}{\PYZcb{}}\PY{p}{;} \PY{k}{do} \PY{n+nb}{echo} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{This is line }\PY{n+nv}{\PYZdl{}i}\PY{l+s+s2}{.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{;} \PY{k}{done}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
This is line 1.
This is line 2.
This is line 3.
This is line 4.
This is line 5.

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}42}]:} \PY{c+ch}{\PYZsh{}!/bin/sh}
         
         \PY{k}{for} file in ./test/accessory\PYZhy{}box/*  ./test/box/*  ./test/cup/*  ./test/emo/*  ./test/goldfish/*  ./test/lunch\PYZhy{}box/*  ./test/penguin/*  ./test/piggy\PYZhy{}bank/*  ./test/pikachyuu/*  ./test/totoro/*
         \PY{k}{do}
         
         \PY{n+nv}{filestr}\PY{o}{=}\PY{l+s+sb}{`}basename \PY{n+nv}{\PYZdl{}file}\PY{l+s+sb}{`}
         
         \PY{n+nv}{train\PYZus{}file}\PY{o}{=}\PY{l+s+sb}{`}\PY{n+nb}{echo} \PY{n+nv}{\PYZdl{}file} \PY{p}{|} sed \PY{l+s+s1}{\PYZsq{}s/test/train/\PYZsq{}}\PY{l+s+sb}{`}
         \PY{n+nv}{dirstr}\PY{o}{=}\PY{l+s+sb}{`}dirname \PY{n+nv}{\PYZdl{}train\PYZus{}file}\PY{l+s+sb}{`}
         
         \PY{k}{if} \PY{o}{[} \PY{l+s+sb}{`}ls \PY{n+nv}{\PYZdl{}dirstr} \PY{p}{|} grep \PYZhy{}c \PY{n+nv}{\PYZdl{}filestr}\PY{l+s+sb}{`} \PYZhy{}eq \PY{l+m}{1} \PY{o}{]}\PY{p}{;} \PY{k}{then}
         
            \PY{n+nb}{echo} \PY{l+s+s2}{\PYZdq{}}\PY{n+nv}{\PYZdl{}file}\PY{l+s+s2}{ exists in }\PY{n+nv}{\PYZdl{}dirstr}\PY{l+s+s2}{\PYZdq{}}
            \PY{c+c1}{\PYZsh{}ls \PYZdl{}dirstr | grep \PYZdl{}filestr}
            ls \PY{n+nv}{\PYZdl{}train\PYZus{}file}
            \PY{c+c1}{\PYZsh{}rm \PYZdl{}train\PYZus{}file}
         \PY{k}{fi}
         \PY{k}{done}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
ls: cannot access './train/accessory-box': No such file or directory
grep: data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
bash: [: too many arguments
ls: cannot access './train/box': No such file or directory
grep: data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
bash: [: too many arguments
ls: cannot access './train/cup': No such file or directory
grep: data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
bash: [: too many arguments
ls: grep: cannot access './train/emo': No such file or directory
data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
bash: [: too many arguments
grep: data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
ls: cannot access './train/goldfish': No such file or directory
bash: [: too many arguments
grep: data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
ls: cannot access './train/lunch-box': No such file or directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
bash: [: too many arguments
ls: cannot access './train/penguin': No such file or directory
grep: data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
bash: [: too many arguments
grep: data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
ls: cannot access './train/piggy-bank': No such file or directory
bash: [: too many arguments
ls: cannot access './train/pikachyuu': No such file or directory
grep: data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
bash: [: too many arguments
ls: cannot access './train/totoro': No such file or directory
grep: data1: Is a directory
grep: data2: Is a directory
grep: data3: Is a directory
grep: data4: Is a directory
grep: data5: Is a directory
grep: folderA: Is a directory
grep: folder-athit: Is a directory
grep: folderB: Is a directory
grep: folder-new: Is a directory
grep: screen: Is a directory
grep: wildcard: Is a directory
bash: [: too many arguments

    \end{Verbatim}

    Note: ls -ltr, gzip, bzip2, unzip, zless, tar, shutdown, ps, free, top,
df, kill, chmod, chown, passwd, whereis, locate, man, sudo, apt-get,
date, cal, wget, echo, env, export, ifconfig, ping, tee, fg, bg, jobs,
whoami, nautilus, ln unalias, uniq, sort, source, vi, emacs, history,
tr, at, w, set ( to show your current enviroment in zsh or bash),
display, eog, fmt convert

\section{dos2unix (I am not telling)}\label{dos2unix-i-am-not-telling}

How to sort a file by a column

Columns are separated by a space, we sort numerically (-n) and we sort
by the 10'th column (-k10) bash does the job here, no perl needed ;)

sort -t' ' -n -k10 eSet1\_both.txt

======

sudo apt-get install tree tree -d -L 1

. ├── bin ├── boot ├── cdrom ├── data1 ├── data2 ├── dev ├── etc ├──
home ├── lib ├── lib64 ├── lost+found ├── media ├── mnt ├── opt ├── proc
├── root ├── run ├── sbin ├── srv ├── sys ├── tmp ├── usr └── var

uname -a lsb\_release -a cat /etc/lsb-release cat /etc/debian\_version

Wild Card Regular Expression Directives such as \textgreater{}
\textbar{} \textgreater{}\textgreater{} \&

Some useful line editing key bindings provided by the Readline library:

Ctrl-A: go to the beginning of line\\
Ctrl-E: go to the end of line\\
Alt-B: skip one word backward\\
Alt-F: skip one word forward\\
Ctrl-U: delete to the beginning of line\\
Ctrl-K: delete to the end of line\\
Alt-D: delete to the end of word

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Ctrl + a -- go to the start of the command line\\
Ctrl + e -- go to the end of the command line\\
Ctrl + k -- delete from cursor to the end of the command line\\
Ctrl + u -- delete from cursor to the start of the command line\\
Ctrl + w -- delete from cursor to start of word (i.e. delete backwards
one word)\\
Ctrl + y -- paste word or text that was cut using one of the deletion
shortcuts (such as the one above) after the cursor\\
Ctrl + xx -- move between start of command line and current cursor
position (and back again)\\
Alt + b -- move backward one word (or go to start of word the cursor is
currently on)\\
Alt + f -- move forward one word (or go to end of word the cursor is
currently on)\\
Alt + d -- delete to end of word starting at cursor (whole word if
cursor is at the beginning of word)\\
Alt + c -- capitalize to end of word starting at cursor (whole word if
cursor is at the beginning of word)\\
Alt + u -- make uppercase from cursor to end of word\\
Alt + l -- make lowercase from cursor to end of word\\
Alt + t -- swap current word with previous\\
Ctrl + f -- move forward one character\\
Ctrl + b -- move backward one character\\
Ctrl + d -- delete character under the cursor\\
Ctrl + h -- delete character before the cursor\\
Ctrl + t -- swap character under cursor with the previous one

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Wildcard Matches * zero or more characters ? exactly one character
{[}abcde{]} exactly one character listed {[}a-e{]} exactly one character
in the given range {[}!abcde{]} any character that is not listed
{[}!a-e{]} any character that is not in the given range \{debian,linux\}
exactly one entire word in the options given

========

!ls

Executes the most recently executed command that begins with the letters
ls. !!

Would re-execute the most recently executed command.

cd - !\$ (is the "end" of the previous command) \textless{}-\/-\/-
useful :) \(_ (different with !\))

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Ctrl+D, -\/- various usage, EOF, work as "logout", work as "exit"

Ctrl+C

find / -type f ! -perm 777 Ctrl + S and Ctrl+Q

================

Can recall command lines by history number or by string-matching.
!identifier is replaced by part or all of previous command line: \% !!
...substituted with previous command \% lpr !\$ ...last argument of
previous command \% !23 ...all of command 23 \% lpr !23:\$ ...last
argument of command 23 \% !vi ...all of the last vi command \% lpr
!vi:\$ ...last argument of last vi command ...and many more!
\textsuperscript{old}new does quick substitution to previous command
line: \% emasc /usr/local/src/foo/file.c emasc: command not found. \%
\textsuperscript{sc}cs emacs /usr/local/src/foo/file.c

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Delete an extra character, an "s": \^{}s \% emacss foofile emacss:
command not found \% \^{}s emacs foofile

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Globally substitute anywhere \% lp file\_a2461.c file\_b1831.c
file\_c1900.c ... ...later... \% !lp:gs/.c/.txt/ lp file\_a2461.txt
file\_b1831.txt file\_c1900.txt ..
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

Run the command inside backquotes (\texttt{...}), replace that command
with its output. Example: Print all files modified in past day: \% lpr
\texttt{find\ *\ -type\ f\ -mtime\ -1\ -print}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Executing multiple commands in bash\\
\$ ./configure; make; make install\\
OR\\
\$ ./configure \&\& make \&\& make install

    In final, conclusion:\\
mkdir data\{1..10\}\\
ပြောပြမယ် touch file\{1..1000\}\\
ls -d /etc/pa*\\
Error case:\\
file{[}1-3{]} expands into files named file1, file2, file3. Filename
expansion happens only if matching files exist. If not, the pattern is
left as-is. Therefore, with files named file1, file2, file3,
file{[}1-3{]} expands to file1 file2 file3. Without these files, it
doesn't expand, and remains as file{[}1-3{]}. With \{...\}, the
filenames don't have to exist, so file\{1..3\} expands to file1 file2
file3 irrespective of the files being present or absent.\\
Braces are also used to execute a sequence of commands in the current
shell context, e.g.\\
\$ \{ date; top -b -n1 \textbar{} head ; \} \textgreater{}logfile\\
'date' and 'top' output are concatenated,\\
could be useful sometimes to hunt for a top loader )

\$ \{ date; make 2\textgreater{}\&1; date; \} \textbar{} tee logfile\\
\# now we can calculate the duration of a build from the logfile\\
There is a subtle syntactic difference with ( ), though (see bash
reference) ; essentially, a semicolon ; after the last command within
braces is a must, and the braces \{, \} must be surrounded by spaces.\\
echo "\$((11*13))"

I have to introduce about "\&\&" and "\textbar{}\textbar{}"

    \subsection{References}\label{references}

\href{https://en.wikipedia.org/wiki/ANSI_escape_code}{http://www.unicode.org/charts/}\\
\url{http://www.unicode.org/charts/}\\
\href{https://en.wikipedia.org/wiki/List_of_mathematical_symbols_by_subject\#Probability_theory}{Wiki
List of Mathematical Symbols by Subject}\\
\href{http://www.jpeek.com/talks/osu_20010508/}{Why Use a Command Line
Instead of a GUI?}\\
\href{http://shop.oreilly.com/product/9780596528126.do}{Mastering
Regular Expressions by Jeffrey Friedl, 3rd Edition}\\
\href{http://www.regular-expressions.info/tutorial.html}{Regular-Expression.info}\\
\href{https://stackoverflow.com/questions/2301285/what-do-lazy-and-greedy-mean-in-the-context-of-regular-expressions}{Stackoverflow
of Greedy and Lazy}
\href{https://en.wikipedia.org/wiki/Boyer\%E2\%80\%93Moore_string_search_algorithm}{Boyer-Moore
algorithm}\\
\href{https://unix.stackexchange.com/questions/17949/what-is-the-difference-between-grep-egrep-and-fgrep}{what-is-the-difference-between-grep-egrep-and-fgrep}\\
\href{https://stackoverflow.com/questions/12833714/the-concept-of-hold-space-and-pattern-space-in-sed}{the-concept-of-hold-space-and-pattern-space-in-sed}\\
\href{https://www.gnu.org/software/sed/manual/sed.html}{GNU sed command
manual}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} date
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Sat Jul 29 10:34:15 JST 2017

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} cal
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
     July 2017        
Su Mo Tu We Th Fr Sa  
                   1  
 2  3  4  5  6  7  8  
 9 10 11 12 13 14 15  
16 17 18 19 20 21 22  
23 24 25 26 27 28 29  
30 31                 

    \end{Verbatim}

    At final, I wish to make conclusion with we can combine all linux
command and creat bash scripts. I wanna show some bash scripts and
running for loop at command lines.

for num in \{1000..1021\}; do echo -e "\u\$num"; don

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{k}{for} num in \PY{o}{\PYZob{}}A..Z\PY{o}{\PYZcb{}}\PY{p}{;} \PY{k}{do} \PY{n+nb}{echo} \PYZhy{}e \PYZhy{}n \PY{l+s+s2}{\PYZdq{}}\PY{n+nv}{\PYZdl{}num}\PY{l+s+s2}{\PYZbs{}t}\PY{l+s+s2}{\PYZdq{}}\PY{p}{;} \PY{k}{done}
        \PY{k}{for} num in \PY{o}{\PYZob{}}\PY{l+m}{1000}..1021\PY{o}{\PYZcb{}}\PY{p}{;} \PY{k}{do} \PY{n+nb}{echo} \PYZhy{}e \PYZhy{}n \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZbs{}u}\PY{n+nv}{\PYZdl{}num}\PY{l+s+s2}{\PYZdq{}}\PY{p}{;} \PY{k}{done}
        \PY{n+nb}{printf} \PY{l+s+s2}{\PYZdq{}\PYZpc{}b\PYZdq{}} \PY{l+s+s2}{\PYZdq{}Unicode Character (U+0965) \PYZbs{}U0965 \PYZbs{}n\PYZdq{}}
        \PY{n+nb}{echo} \PY{l+s+s1}{\PYZdl{}\PYZsq{}Unicode Character (U+0965) \PYZbs{}U0965\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
A	B	C	D	E	F	G	H	I	J	K	L	M	N	O	P	Q	R	S	T	U	V	W	X	Y	Z	\textbackslash{}u1000\textbackslash{}u1001\textbackslash{}u1002\textbackslash{}u1003\textbackslash{}u1004\textbackslash{}u1005\textbackslash{}u1006\textbackslash{}u1007\textbackslash{}u1008\textbackslash{}u1009\textbackslash{}u1010\textbackslash{}u1011\textbackslash{}u1012\textbackslash{}u1013\textbackslash{}u1014\textbackslash{}u1015\textbackslash{}u1016\textbackslash{}u1017\textbackslash{}u1018\textbackslash{}u1019\textbackslash{}u1020\textbackslash{}u1021Unicode Character (U+0965) \textbackslash{}u0965 
Unicode Character (U+0965) \textbackslash{}u0965

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} 
\end{Verbatim}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
